<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>laueimproc.geometry API documentation</title>
<meta name="description" content="Implement the Bragg diffraction rules â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>laueimproc.geometry</code></h1>
</header>
<section id="section-intro">
<p>Implement the Bragg diffraction rules.</p>
<p><img alt="" src="../../../build/media/IMGGeometryGraph.avif"></p>
<h2 id="bases">Bases</h2>
<ul>
<li><span><span class="MathJax_Preview">\mathcal{B^c}</span><script type="math/tex">\mathcal{B^c}</script></span>: The orthonormal base of the crystal
<span><span class="MathJax_Preview">[\mathbf{C_1}, \mathbf{C_2}, \mathbf{C_3}]</span><script type="math/tex">[\mathbf{C_1}, \mathbf{C_2}, \mathbf{C_3}]</script></span>.</li>
<li><span><span class="MathJax_Preview">\mathcal{B^l}</span><script type="math/tex">\mathcal{B^l}</script></span>: The orthonormal base of the lab
<span><span class="MathJax_Preview">[\mathbf{L_1}, \mathbf{L_2}, \mathbf{L_3}]</span><script type="math/tex">[\mathbf{L_1}, \mathbf{L_2}, \mathbf{L_3}]</script></span> in pyfai.</li>
</ul>
<h2 id="lattice-parameters">Lattice Parameters</h2>
<ul>
<li><span><span class="MathJax_Preview">[a, b, c, \alpha, \beta, \gamma]</span><script type="math/tex">[a, b, c, \alpha, \beta, \gamma]</script></span>: The lattice scalars parameters.</li>
<li><span><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>: The primitive column vectors <span><span class="MathJax_Preview">[\mathbf{e_1}, \mathbf{e_2}, \mathbf{e_3}]</span><script type="math/tex">[\mathbf{e_1}, \mathbf{e_2}, \mathbf{e_3}]</script></span>
in an orthonormal base.</li>
<li><span><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>: The reciprocal column vectors <span><span class="MathJax_Preview">[\mathbf{e_1^*}, \mathbf{e_2^*}, \mathbf{e_3^*}]</span><script type="math/tex">[\mathbf{e_1^*}, \mathbf{e_2^*}, \mathbf{e_3^*}]</script></span>
in an orthonormal base.</li>
</ul>
<h2 id="angles">Angles</h2>
<ul>
<li><span><span class="MathJax_Preview">\phi_{ij}</span><script type="math/tex">\phi_{ij}</script></span>: The angular distance between <span><span class="MathJax_Preview">u_{q_i}</span><script type="math/tex">u_{q_i}</script></span> and <span><span class="MathJax_Preview">u_{q_j}</span><script type="math/tex">u_{q_j}</script></span>, <span><span class="MathJax_Preview">\phi \in [0, \pi]</span><script type="math/tex">\phi \in [0, \pi]</script></span>.</li>
<li><span><span class="MathJax_Preview">\theta</span><script type="math/tex">\theta</script></span>: The half deviation angle in radian in the plan <span><span class="MathJax_Preview">(u_f, \mathbf{L_3})</span><script type="math/tex">(u_f, \mathbf{L_3})</script></span>,
<span><span class="MathJax_Preview">\theta \in [0, \frac{\pi}{2}]</span><script type="math/tex">\theta \in [0, \frac{\pi}{2}]</script></span>.</li>
<li><span><span class="MathJax_Preview">\chi</span><script type="math/tex">\chi</script></span>: The rotation angle in radian from the vertical plan <span><span class="MathJax_Preview">(\mathbf{L_1}, \mathbf{L_3})</span><script type="math/tex">(\mathbf{L_1}, \mathbf{L_3})</script></span>
to the plan <span><span class="MathJax_Preview">(u_f, \mathbf{L_3})</span><script type="math/tex">(u_f, \mathbf{L_3})</script></span>, <span><span class="MathJax_Preview">\chi \in [-\pi, \pi]</span><script type="math/tex">\chi \in [-\pi, \pi]</script></span>.</li>
<li><span><span class="MathJax_Preview">[\omega_1, \omega_2, \omega_3]</span><script type="math/tex">[\omega_1, \omega_2, \omega_3]</script></span>: The 3 elementary rotations about an orthonormal base,
witch consitute the rotation matrix <span><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>, <span><span class="MathJax_Preview">
[\omega_1, \omega_2, \omega_3]
\in [-\pi, \pi] \times [-\frac{\pi}{2}, \frac{\pi}{2}] \times [-\pi, \pi]
</span><script type="math/tex">
[\omega_1, \omega_2, \omega_3]
\in [-\pi, \pi] \times [-\frac{\pi}{2}, \frac{\pi}{2}] \times [-\pi, \pi]
</script></span>.</li>
</ul>
<h2 id="diffraction">Diffraction</h2>
<ul>
<li><span><span class="MathJax_Preview">u_f</span><script type="math/tex">u_f</script></span>: The unit vector of the diffracted ray, often expressed in the lab base <span><span class="MathJax_Preview">\mathcal{B^l}</span><script type="math/tex">\mathcal{B^l}</script></span>.</li>
<li><span><span class="MathJax_Preview">u_q</span><script type="math/tex">u_q</script></span>: The unit vector normal to the diffracting plane,
often expressed in the lab base <span><span class="MathJax_Preview">\mathcal{B^l}</span><script type="math/tex">\mathcal{B^l}</script></span>.</li>
<li><span><span class="MathJax_Preview">\mathbf{R}</span><script type="math/tex">\mathbf{R}</script></span>: "La matrice de passage de <span><span class="MathJax_Preview">\mathcal{B^l}</span><script type="math/tex">\mathcal{B^l}</script></span> a <span><span class="MathJax_Preview">\mathcal{B^c}</span><script type="math/tex">\mathcal{B^c}</script></span>", such as
<span><span class="MathJax_Preview">\mathbf{x_{\mathcal{B^l}}} = \mathbf{R} . \mathbf{x_{\mathcal{B^c}}}</span><script type="math/tex">\mathbf{x_{\mathcal{B^l}}} = \mathbf{R} . \mathbf{x_{\mathcal{B^c}}}</script></span>.</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

r&#34;&#34;&#34;Implement the Bragg diffraction rules.

.. image:: ../../../build/media/IMGGeometryGraph.avif

Bases
-----

* \(\mathcal{B^c}\): The orthonormal base of the crystal
    \([\mathbf{C_1}, \mathbf{C_2}, \mathbf{C_3}]\).
* \(\mathcal{B^l}\): The orthonormal base of the lab
    \([\mathbf{L_1}, \mathbf{L_2}, \mathbf{L_3}]\) in pyfai.

Lattice parameters
------------------

* \([a, b, c, \alpha, \beta, \gamma]\): The lattice scalars parameters.
* \(\mathbf{A}\): The primitive column vectors \([\mathbf{e_1}, \mathbf{e_2}, \mathbf{e_3}]\)
    in an orthonormal base.
* \(\mathbf{B}\): The reciprocal column vectors \([\mathbf{e_1^*}, \mathbf{e_2^*}, \mathbf{e_3^*}]\)
    in an orthonormal base.

Angles
------

* \(\phi_{ij}\): The angular distance between \(u_{q_i}\) and \(u_{q_j}\), \(\phi \in [0, \pi]\).
* \(\theta\): The half deviation angle in radian in the plan \((u_f, \mathbf{L_3})\),
    \(\theta \in [0, \frac{\pi}{2}]\).
* \(\chi\): The rotation angle in radian from the vertical plan \((\mathbf{L_1}, \mathbf{L_3})\)
    to the plan \((u_f, \mathbf{L_3})\), \(\chi \in [-\pi, \pi]\).
* \([\omega_1, \omega_2, \omega_3]\): The 3 elementary rotations about an orthonormal base,
    witch consitute the rotation matrix \(\mathbf{R}\), \(
        [\omega_1, \omega_2, \omega_3]
        \in [-\pi, \pi] \times [-\frac{\pi}{2}, \frac{\pi}{2}] \times [-\pi, \pi]
    \).

Diffraction
-----------

* \(u_f\): The unit vector of the diffracted ray, often expressed in the lab base \(\mathcal{B^l}\).
* \(u_q\): The unit vector normal to the diffracting plane,
    often expressed in the lab base \(\mathcal{B^l}\).
* \(\mathbf{R}\): &#34;La matrice de passage de \(\mathcal{B^l}\) a \(\mathcal{B^c}\)&#34;, such as
    \(\mathbf{x_{\mathcal{B^l}}} = \mathbf{R} . \mathbf{x_{\mathcal{B^c}}}\).
&#34;&#34;&#34;

from .bragg import (
    hkl_reciprocal_to_energy, hkl_reciprocal_to_uq, hkl_reciprocal_to_uq_energy,
    uf_to_uq, uq_to_uf,
)
from .hkl import select_hkl
from .lattice import lattice_to_primitive, primitive_to_lattice
from .link import Geometry
from .metric import compute_matching_rate, compute_matching_rate_continuous, ray_phi_dist
from .projection import detector_to_ray, ray_to_detector
from .reciprocal import primitive_to_reciprocal, reciprocal_to_primitive
from .rotation import omega_to_rot, rot_to_omega, rotate_crystal
from .thetachi import thetachi_to_uf, uf_to_thetachi


__all__ = [
    &#34;hkl_reciprocal_to_energy&#34;, &#34;hkl_reciprocal_to_uq&#34;, &#34;hkl_reciprocal_to_uq_energy&#34;,
    &#34;uf_to_uq&#34;, &#34;uq_to_uf&#34;,
    &#34;select_hkl&#34;,
    &#34;lattice_to_primitive&#34;, &#34;primitive_to_lattice&#34;,
    &#34;Geometry&#34;,
    &#34;compute_matching_rate&#34;, &#34;compute_matching_rate_continuous&#34;, &#34;ray_phi_dist&#34;,
    &#34;detector_to_ray&#34;, &#34;ray_to_detector&#34;,
    &#34;primitive_to_reciprocal&#34;, &#34;reciprocal_to_primitive&#34;,
    &#34;omega_to_rot&#34;, &#34;rot_to_omega&#34;, &#34;rotate_crystal&#34;,
    &#34;thetachi_to_uf&#34;, &#34;uf_to_thetachi&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="laueimproc.geometry.bragg" href="bragg.html">laueimproc.geometry.bragg</a></code></dt>
<dd>
<div class="desc"><p>Simulation of the bragg diffraction.</p></div>
</dd>
<dt><code class="name"><a title="laueimproc.geometry.hkl" href="hkl.html">laueimproc.geometry.hkl</a></code></dt>
<dd>
<div class="desc"><p>Help to select the hkl indices.</p></div>
</dd>
<dt><code class="name"><a title="laueimproc.geometry.indexation" href="indexation/index.html">laueimproc.geometry.indexation</a></code></dt>
<dd>
<div class="desc"><p>Index and refine a multi-grain diagram using a variety of methods.</p></div>
</dd>
<dt><code class="name"><a title="laueimproc.geometry.lattice" href="lattice.html">laueimproc.geometry.lattice</a></code></dt>
<dd>
<div class="desc"><p>Link the lattice parameters and the primitive vectors <span><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>.</p></div>
</dd>
<dt><code class="name"><a title="laueimproc.geometry.link" href="link.html">laueimproc.geometry.link</a></code></dt>
<dd>
<div class="desc"><p>Combines atomic functions to provide an overview.</p></div>
</dd>
<dt><code class="name"><a title="laueimproc.geometry.metric" href="metric.html">laueimproc.geometry.metric</a></code></dt>
<dd>
<div class="desc"><p>Implement some loss functions.</p></div>
</dd>
<dt><code class="name"><a title="laueimproc.geometry.projection" href="projection.html">laueimproc.geometry.projection</a></code></dt>
<dd>
<div class="desc"><p>Project rays on a physical or virtual plane.</p></div>
</dd>
<dt><code class="name"><a title="laueimproc.geometry.reciprocal" href="reciprocal.html">laueimproc.geometry.reciprocal</a></code></dt>
<dd>
<div class="desc"><p>Enables communication between primitive <span><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span> and reciprocal space <span><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span>.</p></div>
</dd>
<dt><code class="name"><a title="laueimproc.geometry.rotation" href="rotation.html">laueimproc.geometry.rotation</a></code></dt>
<dd>
<div class="desc"><p>Help for making rotation matrix.</p></div>
</dd>
<dt><code class="name"><a title="laueimproc.geometry.symmetry" href="symmetry.html">laueimproc.geometry.symmetry</a></code></dt>
<dd>
<div class="desc"><p>Find the crystal symmetries and equivalence.</p></div>
</dd>
<dt><code class="name"><a title="laueimproc.geometry.thetachi" href="thetachi.html">laueimproc.geometry.thetachi</a></code></dt>
<dd>
<div class="desc"><p>Convertion of diffracted ray to angles â€¦</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="laueimproc.geometry.compute_matching_rate"><code class="name flex">
<span>def <span class="ident">compute_matching_rate</span></span>(<span>uq_exp:Â torch.Tensor, uq_theo:Â torch.Tensor, phi_max:Â numbers.Real) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the matching rate.</p>
<p>It is the number of ray in <code>uq_theo</code>, close engouth to at least one ray of <code>uq_exp</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uq_exp</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The unitary experimental uq vector of shape (*n, e, 3).</dd>
<dt><strong><code>uq_theo</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The unitary simulated theorical uq vector of shape (*n', t, 3).
It can be in any device.</dd>
<dt><strong><code>phi_max</code></strong> :&ensp;<code>float</code></dt>
<dd>The maximum positive angular distance in radian to consider that the rays are closed enough.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>match</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The matching rate of shape broadcast(n, n') in the <code>uq_exp</code> device.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import torch
&gt;&gt;&gt; from laueimproc.geometry.metric import compute_matching_rate
&gt;&gt;&gt; uq_exp = torch.randn(1000, 3)
&gt;&gt;&gt; uq_exp /= torch.linalg.norm(uq_exp, dim=1, keepdims=True)
&gt;&gt;&gt; uq_theo = torch.randn(5000, 3)
&gt;&gt;&gt; uq_theo /= torch.linalg.norm(uq_theo, dim=1, keepdims=True)
&gt;&gt;&gt; rate = compute_matching_rate(uq_exp, uq_theo, 0.5 * torch.pi/180)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_matching_rate(
    uq_exp: torch.Tensor, uq_theo: torch.Tensor, phi_max: numbers.Real, *, _no_c: bool = False
) -&gt; torch.Tensor:
    r&#34;&#34;&#34;Compute the matching rate.

    It is the number of ray in ``uq_theo``, close engouth to at least one ray of ``uq_exp``.

    Parameters
    ----------
    uq_exp : torch.Tensor
        The unitary experimental uq vector of shape (\*n, e, 3).
    uq_theo : torch.Tensor
        The unitary simulated theorical uq vector of shape (\*n&#39;, t, 3).
        It can be in any device.
    phi_max : float
        The maximum positive angular distance in radian to consider that the rays are closed enough.

    Returns
    -------
    match : torch.Tensor
        The matching rate of shape broadcast(n, n&#39;) in the ``uq_exp`` device.

    Examples
    --------
    &gt;&gt;&gt; import torch
    &gt;&gt;&gt; from laueimproc.geometry.metric import compute_matching_rate
    &gt;&gt;&gt; uq_exp = torch.randn(1000, 3)
    &gt;&gt;&gt; uq_exp /= torch.linalg.norm(uq_exp, dim=1, keepdims=True)
    &gt;&gt;&gt; uq_theo = torch.randn(5000, 3)
    &gt;&gt;&gt; uq_theo /= torch.linalg.norm(uq_theo, dim=1, keepdims=True)
    &gt;&gt;&gt; rate = compute_matching_rate(uq_exp, uq_theo, 0.5 * torch.pi/180)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(uq_exp, torch.Tensor), uq_exp.__class__.__name__
    assert uq_exp.ndim &gt;= 2 and uq_exp.shape[-1] == 3, uq_exp.shape
    assert isinstance(uq_theo, torch.Tensor), uq_theo.__class__.__name__
    assert uq_theo.ndim &gt;= 2 and uq_theo.shape[-1] == 3, uq_theo.shape
    *batch_exp, size_e, _ = uq_exp.shape
    *batch_theo, size_t, _ = uq_theo.shape
    assert size_e * size_t, &#34;can not compute distance of empty matrix&#34;

    if not _no_c and c_metric is not None:
        batch_n = torch.broadcast_shapes(batch_exp, batch_theo)
        uq_exp = torch.broadcast_to(
            uq_exp, batch_n + (size_e, 3)
        ).reshape(int(np.prod(batch_n)), size_e, 3)
        uq_theo = torch.broadcast_to(
            uq_theo, batch_n + (size_t, 3)
        ).reshape(int(np.prod(batch_n)), size_t, 3)
        if threading.current_thread().name == &#34;MainThread&#34;:
            with multiprocessing.pool.ThreadPool() as pool:
                rate = pool.starmap(
                    c_metric.matching_rate,
                    (
                        (theo, phi_max, exp, 4.0*phi_max, ray_to_table(exp, 4.0*phi_max))
                        for theo, exp in zip(uq_theo.numpy(force=True), uq_exp.numpy(force=True))
                    ),
                )
        else:
            rate = [
                c_metric.matching_rate(
                    theo, phi_max, exp, 4.0*phi_max, ray_to_table(exp, 4.0*phi_max),
                )
                for theo, exp in zip(uq_theo.numpy(force=True), uq_exp.numpy(force=True))
            ]
        return torch.asarray(rate, dtype=torch.int32, device=uq_exp.device).reshape(batch_n)

    assert isinstance(phi_max, numbers.Real), phi_max.__class__.__name__
    assert 0 &lt;= phi_max &lt; math.pi, phi_max
    dist = ray_cosine_dist(uq_exp, uq_theo.to(uq_exp.device))  # (*n, e, t)
    dist = dist &gt; math.cos(phi_max)
    dist = torch.any(dist, dim=-2)  # (*n, t)
    rate = torch.count_nonzero(dist, dim=-1)  # (*n,)
    rate = rate.to(torch.int32)
    return rate</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.compute_matching_rate_continuous"><code class="name flex">
<span>def <span class="ident">compute_matching_rate_continuous</span></span>(<span>uq_exp:Â torch.Tensor, uq_theo:Â torch.Tensor, phi_max:Â numbers.Real) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the matching rate.</p>
<p>This is a continuity extension of the disctere function
<code><a title="laueimproc.geometry.metric.compute_matching_rate" href="metric.html#laueimproc.geometry.metric.compute_matching_rate">compute_matching_rate()</a></code>.
Let <span><span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script></span> be the angle between two rays.
The matching rate is defined with <span><span class="MathJax_Preview">r = \sum f(\phi_i)</span><script type="math/tex">r = \sum f(\phi_i)</script></span>
with <span><span class="MathJax_Preview">f(\phi) = e^{-\frac{\log(2)}{\phi_{max}}\phi}</span><script type="math/tex">f(\phi) = e^{-\frac{\log(2)}{\phi_{max}}\phi}</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uq_exp</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The unitary experimental uq vector of shape (*n, e, 3).</dd>
<dt><strong><code>uq_theo</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The unitary simulated theorical uq vector of shape (*n', t, 3).</dd>
<dt><strong><code>phi_max</code></strong> :&ensp;<code>float</code></dt>
<dd>The maximum positive angular distance in radian to consider that the rays are closed enough.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rate</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The continuous matching rate of shape broadcast(n, n').</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import torch
&gt;&gt;&gt; from laueimproc.geometry.metric import compute_matching_rate_continuous
&gt;&gt;&gt; uq_exp = torch.randn(1000, 3)
&gt;&gt;&gt; uq_exp /= torch.linalg.norm(uq_exp, dim=1, keepdims=True)
&gt;&gt;&gt; uq_theo = torch.randn(5000, 3)
&gt;&gt;&gt; uq_theo /= torch.linalg.norm(uq_theo, dim=1, keepdims=True)
&gt;&gt;&gt; rate = compute_matching_rate_continuous(uq_exp, uq_theo, 0.5 * torch.pi/180)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_matching_rate_continuous(
    uq_exp: torch.Tensor, uq_theo: torch.Tensor, phi_max: numbers.Real, *, _no_c: bool = False
) -&gt; torch.Tensor:
    r&#34;&#34;&#34;Compute the matching rate.

    This is a continuity extension of the disctere function
    ``laueimproc.geometry.metric.compute_matching_rate``.
    Let \(\phi\) be the angle between two rays.
    The matching rate is defined with \(r = \sum f(\phi_i)\)
    with \(f(\phi) = e^{-\frac{\log(2)}{\phi_{max}}\phi}\).

    Parameters
    ----------
    uq_exp : torch.Tensor
        The unitary experimental uq vector of shape (\*n, e, 3).
    uq_theo : torch.Tensor
        The unitary simulated theorical uq vector of shape (\*n&#39;, t, 3).
    phi_max : float
        The maximum positive angular distance in radian to consider that the rays are closed enough.

    Returns
    -------
    rate : torch.Tensor
        The continuous matching rate of shape broadcast(n, n&#39;).

    Examples
    --------
    &gt;&gt;&gt; import torch
    &gt;&gt;&gt; from laueimproc.geometry.metric import compute_matching_rate_continuous
    &gt;&gt;&gt; uq_exp = torch.randn(1000, 3)
    &gt;&gt;&gt; uq_exp /= torch.linalg.norm(uq_exp, dim=1, keepdims=True)
    &gt;&gt;&gt; uq_theo = torch.randn(5000, 3)
    &gt;&gt;&gt; uq_theo /= torch.linalg.norm(uq_theo, dim=1, keepdims=True)
    &gt;&gt;&gt; rate = compute_matching_rate_continuous(uq_exp, uq_theo, 0.5 * torch.pi/180)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(uq_exp, torch.Tensor), uq_exp.__class__.__name__
    assert uq_exp.ndim &gt;= 2 and uq_exp.shape[-1] == 3, uq_exp.shape
    assert isinstance(uq_theo, torch.Tensor), uq_theo.__class__.__name__
    assert uq_theo.ndim &gt;= 2 and uq_theo.shape[-1] == 3, uq_theo.shape
    *batch_exp, size_e, _ = uq_exp.shape
    *batch_theo, size_t, _ = uq_theo.shape
    assert size_e * size_t, &#34;can not compute distance of empty matrix&#34;

    factor = -math.log(2.0) / phi_max

    if not _no_c and c_metric is not None:
        batch_n = torch.broadcast_shapes(batch_exp, batch_theo)
        uq_exp = torch.broadcast_to(
            uq_exp, batch_n + (size_e, 3)
        ).reshape(int(np.prod(batch_n)), size_e, 3)
        uq_theo = torch.broadcast_to(
            uq_theo, batch_n + (size_t, 3)
        ).reshape(int(np.prod(batch_n)), size_t, 3)
        if threading.current_thread().name == &#34;MainThread&#34;:
            with multiprocessing.pool.ThreadPool() as pool:
                pairs = pool.starmap(
                    c_metric.link_close_rays,
                    (
                        (theo, phi_max, exp, 4.0*phi_max, ray_to_table(exp, 4.0*phi_max))
                        for theo, exp in zip(
                            uq_theo.to(torch.float32).numpy(force=True),
                            uq_exp.to(torch.float32).numpy(force=True),
                        )
                    ),
                )
        else:
            pairs = [
                c_metric.link_close_rays(
                    theo, phi_max, exp, 4.0*phi_max, ray_to_table(exp, 4.0*phi_max)
                )
                for theo, exp in zip(
                    uq_theo.to(torch.float32).numpy(force=True),
                    uq_exp.to(torch.float32).numpy(force=True),
                )
            ]
        dists = [
            torch.exp(factor * ray_phi_dist(
                uq_exp[i, pair[:, 1], None], uq_theo[i, pair[:, 0], None]
            )[:, 0, 0]) for i, pair in enumerate(pairs)
        ]
        return torch.cat([  # dist[dist &gt;= 0.5].sum() failed if no matching
            dist.where(dist &gt; 0.5, 0.0).sum().unsqueeze(0) for dist in dists
        ]).reshape(batch_n)

    assert isinstance(phi_max, numbers.Real), phi_max.__class__.__name__
    assert 0 &lt;= phi_max &lt; math.pi, phi_max
    phi = ray_phi_dist(uq_exp, uq_theo)  # (*n, e, t)
    phi = torch.amin(phi, dim=-2)  # (*n, t)
    dist = torch.exp(factor * phi)
    dist = dist.where(dist &gt; 0.5, 0.0)  # (*n, t), &#34;dist[dist &lt; 0.5] = 0.0&#34; failed backward
    rate = torch.sum(dist, dim=-1)  # (*n,)
    return rate</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.detector_to_ray"><code class="name flex">
<span>def <span class="ident">detector_to_ray</span></span>(<span>point:Â torch.Tensor, poni:Â torch.Tensor) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Find light ray witch intersected on the detector.</p>
<p>Bijection of <code><a title="laueimproc.geometry.projection.ray_to_detector" href="projection.html#laueimproc.geometry.projection.ray_to_detector">ray_to_detector()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The 2d point in meter in the referencial of the detector of shape (*r, *p, 2).</dd>
<dt><strong><code>poni</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The point of normal incidence, callibration parameters according the pyfai convention.
Values are [dist, poni_1, poni_2, rot_1, rot_2, rot_3] of shape (*p', 6).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ray</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The unitary ray vector of shape (*r, *broadcast(p, p'), 3).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detector_to_ray(point: torch.Tensor, poni: torch.Tensor) -&gt; torch.Tensor:
    r&#34;&#34;&#34;Find light ray witch intersected on the detector.

    Bijection of ``laueimproc.geometry.projection.ray_to_detector``.

    Parameters
    ----------
    point : torch.Tensor
        The 2d point in meter in the referencial of the detector of shape (\*r, \*p, 2).
    poni : torch.Tensor
        The point of normal incidence, callibration parameters according the pyfai convention.
        Values are [dist, poni_1, poni_2, rot_1, rot_2, rot_3] of shape (\*p&#39;, 6).

    Returns
    -------
    ray : torch.Tensor
        The unitary ray vector of shape (\*r, \*broadcast(p, p&#39;), 3).
    &#34;&#34;&#34;
    assert isinstance(point, torch.Tensor), point.__class__.__name__
    assert point.shape[-1:] == (2,), point.shape
    assert isinstance(poni, torch.Tensor), poni.__class__.__name__
    assert poni.shape[-1:] == (6,), poni.shape

    *batch, _ = point.shape
    *batch_poni, _ = poni.shape
    batch_ray = batch[:len(batch)-len(batch_poni)]
    batch_poni = torch.broadcast_shapes(batch_poni, batch[len(batch)-len(batch_poni):])

    point = point - poni[*((None,) * len(batch_ray)), ..., 1:3]  # detector shift
    ray = torch.empty(*batch_ray, *batch_poni, 3, dtype=point.dtype, device=point.device)
    ray[..., :2] = point
    ray[..., 2] = poni[*((None,) * len(batch_ray)), ..., 0]
    rot = omega_to_rot(poni[..., 3], poni[..., 4], -poni[..., 5], cartesian_product=False)
    rot = rot[*((None,) * len(batch_ray)), ..., :, :]
    ray = (rot.mT @ ray[..., None]).squeeze(-1)
    ray = ray * torch.rsqrt(torch.sum(ray * ray, dim=-1, keepdim=True))
    return ray</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.hkl_reciprocal_to_energy"><code class="name flex">
<span>def <span class="ident">hkl_reciprocal_to_energy</span></span>(<span>hkl:Â torch.Tensor, reciprocal:Â torch.Tensor, **kwargs) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Alias to <code><a title="laueimproc.geometry.bragg.hkl_reciprocal_to_uq_energy" href="bragg.html#laueimproc.geometry.bragg.hkl_reciprocal_to_uq_energy">hkl_reciprocal_to_uq_energy()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hkl_reciprocal_to_energy(hkl: torch.Tensor, reciprocal: torch.Tensor, **kwargs) -&gt; torch.Tensor:
    &#34;&#34;&#34;Alias to ``laueimproc.geometry.bragg.hkl_reciprocal_to_uq_energy``.&#34;&#34;&#34;
    _, energy = hkl_reciprocal_to_uq_energy(hkl, reciprocal, _return_uq=False, **kwargs)
    return energy</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.hkl_reciprocal_to_uq"><code class="name flex">
<span>def <span class="ident">hkl_reciprocal_to_uq</span></span>(<span>hkl:Â torch.Tensor, reciprocal:Â torch.Tensor, **kwargs) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Alias to <code><a title="laueimproc.geometry.bragg.hkl_reciprocal_to_uq_energy" href="bragg.html#laueimproc.geometry.bragg.hkl_reciprocal_to_uq_energy">hkl_reciprocal_to_uq_energy()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hkl_reciprocal_to_uq(hkl: torch.Tensor, reciprocal: torch.Tensor, **kwargs) -&gt; torch.Tensor:
    &#34;&#34;&#34;Alias to ``laueimproc.geometry.bragg.hkl_reciprocal_to_uq_energy``.&#34;&#34;&#34;
    u_q, _ = hkl_reciprocal_to_uq_energy(hkl, reciprocal, _return_energy=False, **kwargs)
    return u_q</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.hkl_reciprocal_to_uq_energy"><code class="name flex">
<span>def <span class="ident">hkl_reciprocal_to_uq_energy</span></span>(<span>hkl:Â torch.Tensor, reciprocal:Â torch.Tensor, *, cartesian_product:Â boolÂ =Â True) â€‘>Â tuple[torch.Tensor,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Thanks to the bragg relation, compute the energy of each diffracted ray.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hkl</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The h, k, l indices of shape (*n, 3) we want to mesure.</dd>
<dt><strong><code>reciprocal</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>Matrix <span><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span> of shape (*r, 3, 3) in the lab base <span><span class="MathJax_Preview">\mathcal{B^l}</span><script type="math/tex">\mathcal{B^l}</script></span>.</dd>
<dt><strong><code>cartesian_product</code></strong> :&ensp;<code>boolean</code>, default=<code>True</code></dt>
<dd>
<p>If True (default value), batch dimensions are iterated independently like neasted for loop.
Overwise, the batch dimensions are broadcasted like a zip.</p>
<ul>
<li>True: The final shape are (*n, *r, 3) and (*n, *r).</li>
<li>False: The final shape are (*broadcast(n, r), 3) and broadcast(n, r).</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>u_q</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>All the unitary diffracting plane normal vector of shape (&hellip;, 3),
in the lab base <span><span class="MathJax_Preview">\mathcal{B^l}</span><script type="math/tex">\mathcal{B^l}</script></span>.</dd>
<dt><strong><code>energy</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The energy of each ray in J as a tensor of shape (&hellip;,).
<span><span class="MathJax_Preview">\begin{cases}
E = \frac{hc}{\lambda} \\
\lambda = 2d\sin(\theta) \\
\sin(\theta) = \left| \langle u_i, u_q \rangle \right| \\
\end{cases}</span><script type="math/tex">\begin{cases}
E = \frac{hc}{\lambda} \\
\lambda = 2d\sin(\theta) \\
\sin(\theta) = \left| \langle u_i, u_q \rangle \right| \\
\end{cases}</script></span></dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>According the pyfai convention, <span><span class="MathJax_Preview">u_i = \mathbf{L_1}</span><script type="math/tex">u_i = \mathbf{L_1}</script></span>.</li>
</ul>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import torch
&gt;&gt;&gt; from laueimproc.geometry.bragg import hkl_reciprocal_to_uq_energy
&gt;&gt;&gt; reciprocal = torch.torch.tensor([[ 1.6667e+09,  0.0000e+00,  0.0000e+00],
...                                  [ 9.6225e+08,  3.0387e+09, -0.0000e+00],
...                                  [-6.8044e+08, -2.1488e+09,  8.1653e+08]])
&gt;&gt;&gt; hkl = torch.tensor([1, 2, -1])
&gt;&gt;&gt; u_q, energy = hkl_reciprocal_to_uq_energy(hkl, reciprocal)
&gt;&gt;&gt; u_q
tensor([ 0.1798,  0.7595, -0.6252])
&gt;&gt;&gt; 6.24e18 * energy  # convertion J -&gt; eV
tensor(9200.6816)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hkl_reciprocal_to_uq_energy(
    hkl: torch.Tensor, reciprocal: torch.Tensor,
    *, cartesian_product: bool = True, _return_uq: bool = True, _return_energy: bool = True
) -&gt; tuple[torch.Tensor, torch.Tensor]:
    r&#34;&#34;&#34;Thanks to the bragg relation, compute the energy of each diffracted ray.

    Parameters
    ----------
    hkl : torch.Tensor
        The h, k, l indices of shape (\*n, 3) we want to mesure.
    reciprocal : torch.Tensor
        Matrix \(\mathbf{B}\) of shape (\*r, 3, 3) in the lab base \(\mathcal{B^l}\).
    cartesian_product : boolean, default=True
        If True (default value), batch dimensions are iterated independently like neasted for loop.
        Overwise, the batch dimensions are broadcasted like a zip.

        * True: The final shape are (\*n, \*r, 3) and (\*n, \*r).
        * False: The final shape are (\*broadcast(n, r), 3) and broadcast(n, r).

    Returns
    -------
    u_q : torch.Tensor
        All the unitary diffracting plane normal vector of shape (..., 3),
        in the lab base \(\mathcal{B^l}\).
    energy : torch.Tensor
        The energy of each ray in J as a tensor of shape (...,).
        \(\begin{cases}
            E = \frac{hc}{\lambda} \\
            \lambda = 2d\sin(\theta) \\
            \sin(\theta) = \left| \langle u_i, u_q \rangle \right| \\
        \end{cases}\)

    Notes
    -----
    * According the pyfai convention, \(u_i = \mathbf{L_1}\).

    Examples
    --------
    &gt;&gt;&gt; import torch
    &gt;&gt;&gt; from laueimproc.geometry.bragg import hkl_reciprocal_to_uq_energy
    &gt;&gt;&gt; reciprocal = torch.torch.tensor([[ 1.6667e+09,  0.0000e+00,  0.0000e+00],
    ...                                  [ 9.6225e+08,  3.0387e+09, -0.0000e+00],
    ...                                  [-6.8044e+08, -2.1488e+09,  8.1653e+08]])
    &gt;&gt;&gt; hkl = torch.tensor([1, 2, -1])
    &gt;&gt;&gt; u_q, energy = hkl_reciprocal_to_uq_energy(hkl, reciprocal)
    &gt;&gt;&gt; u_q
    tensor([ 0.1798,  0.7595, -0.6252])
    &gt;&gt;&gt; 6.24e18 * energy  # convertion J -&gt; eV
    tensor(9200.6816)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(reciprocal, torch.Tensor), reciprocal.__class__.__name__
    assert reciprocal.shape[-2:] == (3, 3), reciprocal.shape
    assert isinstance(hkl, torch.Tensor), hkl.__class__.__name__
    assert hkl.shape[-1:] == (3,), hkl.shape
    assert not hkl.dtype.is_complex and not hkl.dtype.is_floating_point, hkl.dtype
    assert isinstance(cartesian_product, bool), cartesian_product.__class__.__name__

    if cartesian_product:
        *batch_r, _, _ = reciprocal.shape
        *batch_n, _ = hkl.shape
        reciprocal = reciprocal[*((None,)*len(batch_n)), ..., :, :]  # (*n, *r, 3, 3)
        hkl = hkl[..., *((None,)*len(batch_r)), :]  # (*n, *r, 3)

    hkl = hkl[..., :, None]  # (..., 3, 1)
    u_q = reciprocal @ hkl.to(reciprocal.device, reciprocal.dtype)  # (..., 3, 1)
    inv_d_square = u_q.mT @ u_q  # (..., 1, 1)
    u_q = u_q.squeeze(-1)  # (..., 3)
    inv_d_square = inv_d_square.squeeze(-1)  # (..., 1)

    energy = None
    if _return_energy:
        ui_dot_uq = u_q[..., 2]  # (...,)
        inv_d_sin_theta = inv_d_square.squeeze(-1) / ui_dot_uq
        energy = torch.abs((0.5 * PLANK_H * CELERITY_C) * inv_d_sin_theta)

    if _return_uq:
        u_q = u_q * torch.rsqrt(inv_d_square)

    return u_q, energy</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.lattice_to_primitive"><code class="name flex">
<span>def <span class="ident">lattice_to_primitive</span></span>(<span>lattice:Â torch.Tensor) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the lattice parameters into primitive vectors.</p>
<p><img alt="" src="../../../build/media/IMGLatticeBc.avif"></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lattice</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The array of lattice parameters of shape (&hellip;, 6).
Values are <span><span class="MathJax_Preview">[a, b, c, \alpha, \beta, \gamma]]</span><script type="math/tex">[a, b, c, \alpha, \beta, \gamma]]</script></span> in meters and radians.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>primitive</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>Matrix <span><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span> of shape (&hellip;, 3, 3) in the crystal base <span><span class="MathJax_Preview">\mathcal{B^c}</span><script type="math/tex">\mathcal{B^c}</script></span>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import torch
&gt;&gt;&gt; from laueimproc.geometry.lattice import lattice_to_primitive
&gt;&gt;&gt; lattice = torch.tensor([6.0e-10, 3.8e-10, 15e-10, torch.pi/3, torch.pi/2, 2*torch.pi/3])
&gt;&gt;&gt; lattice_to_primitive(lattice)
tensor([[ 6.0000e-10, -1.9000e-10, -6.5567e-17],
        [ 0.0000e+00,  3.2909e-10,  8.6603e-10],
        [ 0.0000e+00,  0.0000e+00,  1.2247e-09]])
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lattice_to_primitive(lattice: torch.Tensor) -&gt; torch.Tensor:
    r&#34;&#34;&#34;Convert the lattice parameters into primitive vectors.

    .. image:: ../../../build/media/IMGLatticeBc.avif

    Parameters
    ----------
    lattice : torch.Tensor
        The array of lattice parameters of shape (..., 6).
        Values are \([a, b, c, \alpha, \beta, \gamma]]\) in meters and radians.

    Returns
    -------
    primitive : torch.Tensor
        Matrix \(\mathbf{A}\) of shape (..., 3, 3) in the crystal base \(\mathcal{B^c}\).

    Examples
    --------
    &gt;&gt;&gt; import torch
    &gt;&gt;&gt; from laueimproc.geometry.lattice import lattice_to_primitive
    &gt;&gt;&gt; lattice = torch.tensor([6.0e-10, 3.8e-10, 15e-10, torch.pi/3, torch.pi/2, 2*torch.pi/3])
    &gt;&gt;&gt; lattice_to_primitive(lattice)
    tensor([[ 6.0000e-10, -1.9000e-10, -6.5567e-17],
            [ 0.0000e+00,  3.2909e-10,  8.6603e-10],
            [ 0.0000e+00,  0.0000e+00,  1.2247e-09]])
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(lattice, torch.Tensor), lattice.__class__.__name__
    assert lattice.shape[-1:] == (6,), lattice.shape

    lat_a, lat_b, lat_c, alpha, beta, gamma = lattice.movedim(-1, 0)
    zero = torch.zeros_like(lat_a)
    cos_beta = torch.cos(beta)
    sin_gamma = torch.sin(gamma)
    cos_gamma = torch.cos(gamma)
    e3_c2 = (torch.cos(alpha) - cos_gamma*cos_beta) / sin_gamma

    return torch.cat([
        lat_a.unsqueeze(-1),  # e1_c1
        (lat_b * cos_gamma).unsqueeze(-1),  # e2_c1
        (lat_c * cos_beta).unsqueeze(-1),  # e3_c1
        zero.unsqueeze(-1),  # e1_c2
        (lat_b * sin_gamma).unsqueeze(-1),  # e2_c2
        (lat_c * e3_c2).unsqueeze(-1),  # e3_c2
        zero.unsqueeze(-1),  # e1_c3
        zero.unsqueeze(-1),  # e2_c3
        (lat_c * torch.sqrt(torch.sin(beta)**2 - e3_c2**2)).unsqueeze(-1),  # e3_c3
    ], dim=-1).reshape(*lattice.shape[:-1], 3, 3)</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.omega_to_rot"><code class="name flex">
<span>def <span class="ident">omega_to_rot</span></span>(<span>omega1:Â torch.TensorÂ |Â numbers.RealÂ =Â 0, omega2:Â torch.TensorÂ |Â numbers.RealÂ =Â 0, omega3:Â torch.TensorÂ |Â numbers.RealÂ =Â 0, *, cartesian_product:Â boolÂ =Â True) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a rotation matrix from the given angles.</p>
<p>The rotation are following the pyfai convention.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>omega1</code></strong> :&ensp;<code>torch.Tensor</code> or <code>float</code></dt>
<dd>The first rotation angle of shape (*a,).
<span><span class="MathJax_Preview">
rot_1 =
\begin{pmatrix}
1 &amp; 0
&amp;
0 \\
0 &amp; \cos(\omega_1) &amp; -\sin(\omega_1) \\
c &amp; \sin(\omega_1) &amp;
\cos(\omega_1) \\
\end{pmatrix}
</span><script type="math/tex">
rot_1 =
\begin{pmatrix}
1 & 0
&
0 \\
0 & \cos(\omega_1) & -\sin(\omega_1) \\
c & \sin(\omega_1) &
\cos(\omega_1) \\
\end{pmatrix}
</script></span></dd>
<dt><strong><code>omega2</code></strong> :&ensp;<code>torch.Tensor</code> or <code>float</code></dt>
<dd>The second rotation angle of shape (*b,).
<span><span class="MathJax_Preview">
rot_2 =
\begin{pmatrix}
\cos(\omega_2) &amp; 0 &amp; \sin(\omega_2) \\
0 &amp; 1 &amp;
0 \\
-\sin(\omega_2) &amp; 0 &amp; \cos(\omega_2) \\
\end{pmatrix}
</span><script type="math/tex">
rot_2 =
\begin{pmatrix}
\cos(\omega_2) & 0 & \sin(\omega_2) \\
0 & 1 &
0 \\
-\sin(\omega_2) & 0 & \cos(\omega_2) \\
\end{pmatrix}
</script></span></dd>
<dt><strong><code>omega3</code></strong> :&ensp;<code>torch.Tensor</code> or <code>float</code></dt>
<dd>The third rotation angle of shape (*c,). (inverse of pyfai convention)
<span><span class="MathJax_Preview">
rot_3 =
\begin{pmatrix}
\cos(\omega_3) &amp; -\sin(\omega_3) &amp; 0 \\
\sin(\omega_3) &amp;
\cos(\omega_3) &amp; 0 \\
0 &amp;
0 &amp; 1 \\
\end{pmatrix}
</span><script type="math/tex">
rot_3 =
\begin{pmatrix}
\cos(\omega_3) & -\sin(\omega_3) & 0 \\
\sin(\omega_3) &
\cos(\omega_3) & 0 \\
0 &
0 & 1 \\
\end{pmatrix}
</script></span></dd>
<dt><strong><code>cartesian_product</code></strong> :&ensp;<code>boolean</code>, default=<code>True</code></dt>
<dd>
<p>If True (default value), batch dimensions are iterated independently like neasted for loop.
Overwise, the batch dimensions are broadcasted like a zip.</p>
<ul>
<li>True: The final shape is (*a, *b, *c, 3, 3).</li>
<li>False: The final shape is (*broadcast(a, b, c), 3, 3).</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rot</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The global rotation <span><span class="MathJax_Preview">rot_3 . rot_2 . rot_1</span><script type="math/tex">rot_3 . rot_2 . rot_1</script></span>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>To be bijective with the function <code><a title="laueimproc.geometry.rotation.rot_to_omega" href="rotation.html#laueimproc.geometry.rotation.rot_to_omega">rot_to_omega()</a></code>,
you have to respect: <span><span class="MathJax_Preview">
[\omega_1, \omega_2, \omega_3]
\in [-\pi, \pi] \times [-\frac{\pi}{2}, \frac{\pi}{2}] \times [-\pi, \pi]
</span><script type="math/tex">
[\omega_1, \omega_2, \omega_3]
\in [-\pi, \pi] \times [-\frac{\pi}{2}, \frac{\pi}{2}] \times [-\pi, \pi]
</script></span></p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import torch
&gt;&gt;&gt; from laueimproc.geometry.rotation import omega_to_rot
&gt;&gt;&gt; omega_to_rot(omega1=torch.pi/6, omega2=torch.pi/6, omega3=torch.pi/6)
tensor([[ 0.7500, -0.2165,  0.6250],
        [ 0.4330,  0.8750, -0.2165],
        [-0.5000,  0.4330,  0.7500]])
&gt;&gt;&gt; omega_to_rot(torch.randn(4), torch.randn(5, 6), torch.randn(7, 8, 9)).shape
torch.Size([4, 5, 6, 7, 8, 9, 3, 3])
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def omega_to_rot(
    omega1: torch.Tensor | numbers.Real = 0,
    omega2: torch.Tensor | numbers.Real = 0,
    omega3: torch.Tensor | numbers.Real = 0,
    *, cartesian_product: bool = True,
) -&gt; torch.Tensor:
    r&#34;&#34;&#34;Generate a rotation matrix from the given angles.

    The rotation are following the pyfai convention.

    Parameters
    ----------
    omega1 : torch.Tensor or float
        The first rotation angle of shape (\*a,).
        \(
            rot_1 =
            \begin{pmatrix}
                1 &amp; 0              &amp;               0 \\
                0 &amp; \cos(\omega_1) &amp; -\sin(\omega_1) \\
                c &amp; \sin(\omega_1) &amp;  \cos(\omega_1) \\
            \end{pmatrix}
        \)
    omega2 : torch.Tensor or float
        The second rotation angle of shape (\*b,).
        \(
            rot_2 =
            \begin{pmatrix}
                 \cos(\omega_2) &amp; 0 &amp; \sin(\omega_2) \\
                              0 &amp; 1 &amp;              0 \\
                -\sin(\omega_2) &amp; 0 &amp; \cos(\omega_2) \\
            \end{pmatrix}
        \)
    omega3 : torch.Tensor or float
        The third rotation angle of shape (\*c,). (inverse of pyfai convention)
        \(
            rot_3 =
            \begin{pmatrix}
                \cos(\omega_3) &amp; -\sin(\omega_3) &amp; 0 \\
                \sin(\omega_3) &amp;  \cos(\omega_3) &amp; 0 \\
                             0 &amp;               0 &amp; 1 \\
            \end{pmatrix}
        \)
    cartesian_product : boolean, default=True
        If True (default value), batch dimensions are iterated independently like neasted for loop.
        Overwise, the batch dimensions are broadcasted like a zip.

        * True: The final shape is (\*a, \*b, \*c, 3, 3).
        * False: The final shape is (\*broadcast(a, b, c), 3, 3).

    Returns
    -------
    rot : torch.Tensor
        The global rotation \(rot_3 . rot_2 . rot_1\).

    Notes
    -----
    To be bijective with the function ``laueimproc.geometry.rotation.rot_to_omega``,
    you have to respect: \(
        [\omega_1, \omega_2, \omega_3]
        \in [-\pi, \pi] \times [-\frac{\pi}{2}, \frac{\pi}{2}] \times [-\pi, \pi]
    \)

    Examples
    --------
    &gt;&gt;&gt; import torch
    &gt;&gt;&gt; from laueimproc.geometry.rotation import omega_to_rot
    &gt;&gt;&gt; omega_to_rot(omega1=torch.pi/6, omega2=torch.pi/6, omega3=torch.pi/6)
    tensor([[ 0.7500, -0.2165,  0.6250],
            [ 0.4330,  0.8750, -0.2165],
            [-0.5000,  0.4330,  0.7500]])
    &gt;&gt;&gt; omega_to_rot(torch.randn(4), torch.randn(5, 6), torch.randn(7, 8, 9)).shape
    torch.Size([4, 5, 6, 7, 8, 9, 3, 3])
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(omega1, torch.Tensor | numbers.Real), omega1.__class__.__name__
    assert isinstance(omega2, torch.Tensor | numbers.Real), omega2.__class__.__name__
    assert isinstance(omega3, torch.Tensor | numbers.Real), omega3.__class__.__name__
    assert isinstance(cartesian_product, bool), cartesian_product.__class__.__name__

    # find dtype and device
    dtype = (
        {a.dtype for a in (omega1, omega2, omega3) if isinstance(a, torch.Tensor)}
        or {torch.float32}
    )
    dtype = max(dtype, key=lambda t: t.itemsize)
    device = (
        {a.device for a in (omega1, omega2, omega3) if isinstance(a, torch.Tensor)}
        or {torch.device(&#34;cpu&#34;)}
    ).pop()

    # cast into tensor
    if isinstance(omega1, numbers.Real):
        omega1 = torch.tensor(omega1, device=device, dtype=dtype)
    if isinstance(omega2, numbers.Real):
        omega2 = torch.tensor(omega2, device=device, dtype=dtype)
    if isinstance(omega3, numbers.Real):
        omega3 = torch.tensor(omega3, device=device, dtype=dtype)

    # expand dims
    if cartesian_product:
        omega1, omega2, omega3 = (
            omega1[..., *((None,)*omega2.ndim), *((None,)*omega3.ndim)],
            omega2[*((None,)*omega1.ndim), ..., *((None,)*omega3.ndim)],
            omega3[*((None,)*omega1.ndim), *((None,)*omega2.ndim), ...],
        )
    batch = torch.broadcast_shapes(omega1.shape, omega2.shape, omega3.shape)

    # precompute sin and cos
    sin1, cos1 = torch.sin(omega1), torch.cos(omega1)
    sin2, cos2 = torch.sin(omega2), torch.cos(omega2)
    sin3, cos3 = torch.sin(omega3), torch.cos(omega3)

    # full matrix
    sin1sin2 = sin1 * sin2
    cos1sin2 = cos1 * sin2
    return torch.cat([
        (cos2*cos3).expand(batch).unsqueeze(-1),
        (sin1sin2*cos3 - cos1*sin3).expand(batch).unsqueeze(-1),
        (cos1sin2*cos3 + sin1*sin3).expand(batch).unsqueeze(-1),
        (cos2*sin3).expand(batch).unsqueeze(-1),
        (sin1sin2*sin3 + cos1*cos3).expand(batch).unsqueeze(-1),
        (cos1sin2*sin3 - sin1*cos3).expand(batch).unsqueeze(-1),
        (-sin2).expand(batch).unsqueeze(-1),
        (sin1*cos2).expand(batch).unsqueeze(-1),
        (cos1*cos2).expand(batch).unsqueeze(-1),
    ], dim=-1).reshape(*batch, 3, 3)</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.primitive_to_lattice"><code class="name flex">
<span>def <span class="ident">primitive_to_lattice</span></span>(<span>primitive:Â torch.Tensor) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the primitive vectors to the lattice parameters.</p>
<p>Bijection of <code><a title="laueimproc.geometry.lattice.lattice_to_primitive" href="lattice.html#laueimproc.geometry.lattice.lattice_to_primitive">lattice_to_primitive()</a></code>.</p>
<p><img alt="" src="../../../build/media/IMGLattice.avif"></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>primitive</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>Matrix <span><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span> in any orthonormal base.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>lattice</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The array of lattice parameters of shape (&hellip;, 6).
Values are <span><span class="MathJax_Preview">[a, b, c, \alpha, \beta, \gamma]</span><script type="math/tex">[a, b, c, \alpha, \beta, \gamma]</script></span> in meters and radians.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>We have always <code>primitive_to_lattice(lattice_to_primitive(lattice)) == lattice</code>,
but it is not always the case for the inverse composition because the numerical
value of <span><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span> is expressed in the crystal base <span><span class="MathJax_Preview">\mathcal{B^c}</span><script type="math/tex">\mathcal{B^c}</script></span>.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import torch
&gt;&gt;&gt; from laueimproc.geometry.lattice import primitive_to_lattice
&gt;&gt;&gt; primitive = torch.tensor([[ 6.0000e-10, -1.9000e-10, -6.5567e-17],
...                           [ 0.0000e+00,  3.2909e-10,  8.6603e-10],
...                           [ 0.0000e+00,  0.0000e+00,  1.2247e-09]])
&gt;&gt;&gt; primitive_to_lattice(primitive)  # quartz lattice
tensor([6.0000e-10, 3.8000e-10, 1.5000e-09, 1.0472e+00, 1.5708e+00, 2.0944e+00])
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def primitive_to_lattice(primitive: torch.Tensor) -&gt; torch.Tensor:
    r&#34;&#34;&#34;Convert the primitive vectors to the lattice parameters.

    Bijection of ``laueimproc.geometry.lattice.lattice_to_primitive``.

    .. image:: ../../../build/media/IMGLattice.avif

    Parameters
    ----------
    primitive : torch.Tensor
        Matrix \(\mathbf{A}\) in any orthonormal base.

    Returns
    -------
    lattice : torch.Tensor
        The array of lattice parameters of shape (..., 6).
        Values are \([a, b, c, \alpha, \beta, \gamma]\) in meters and radians.

    Notes
    -----
    We have always `primitive_to_lattice(lattice_to_primitive(lattice)) == lattice`,
    but it is not always the case for the inverse composition because the numerical
    value of \(\mathbf{A}\) is expressed in the crystal base \(\mathcal{B^c}\).

    Examples
    --------
    &gt;&gt;&gt; import torch
    &gt;&gt;&gt; from laueimproc.geometry.lattice import primitive_to_lattice
    &gt;&gt;&gt; primitive = torch.tensor([[ 6.0000e-10, -1.9000e-10, -6.5567e-17],
    ...                           [ 0.0000e+00,  3.2909e-10,  8.6603e-10],
    ...                           [ 0.0000e+00,  0.0000e+00,  1.2247e-09]])
    &gt;&gt;&gt; primitive_to_lattice(primitive)  # quartz lattice
    tensor([6.0000e-10, 3.8000e-10, 1.5000e-09, 1.0472e+00, 1.5708e+00, 2.0944e+00])
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(primitive, torch.Tensor), primitive.__class__.__name__
    assert primitive.shape[-2:] == (3, 3), primitive.shape

    abc = torch.sqrt(torch.sum(primitive * primitive, dim=-2))  # (..., 3)
    e_123 = primitive / abc.unsqueeze(-2)  # (..., 3, 3)
    e_1, e_2, e_3 = e_123.movedim(-1, 0)
    alpha = torch.acos(torch.sum(e_2 * e_3, dim=-1, keepdim=True))  # (..., 1)
    beta = torch.acos(torch.sum(e_1 * e_3, dim=-1, keepdim=True))  # (..., 1)
    gamma = torch.acos(torch.sum(e_1 * e_2, dim=-1, keepdim=True))  # (..., 1)
    return torch.cat([abc, alpha, beta, gamma], dim=-1)</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.primitive_to_reciprocal"><code class="name flex">
<span>def <span class="ident">primitive_to_reciprocal</span></span>(<span>primitive:Â torch.Tensor) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the primitive vectors into the reciprocal base vectors.</p>
<p>Bijection of <code><a title="laueimproc.geometry.reciprocal.reciprocal_to_primitive" href="reciprocal.html#laueimproc.geometry.reciprocal.reciprocal_to_primitive">reciprocal_to_primitive()</a></code>.</p>
<p><img alt="" src="../../../build/media/IMGPrimitiveReciprocal.avif"></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>primitive</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>Matrix <span><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span> in any orthonormal base.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>reciprocal</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>Matrix <span><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span> in the same orthonormal base.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import torch
&gt;&gt;&gt; from laueimproc.geometry.reciprocal import primitive_to_reciprocal
&gt;&gt;&gt; primitive = torch.tensor([[ 6.0000e-10, -1.9000e-10, -6.5567e-17],
...                           [ 0.0000e+00,  3.2909e-10,  8.6603e-10],
...                           [ 0.0000e+00,  0.0000e+00,  1.2247e-09]])
&gt;&gt;&gt; primitive_to_reciprocal(primitive)
tensor([[ 1.6667e+09,  0.0000e+00,  0.0000e+00],
        [ 9.6225e+08,  3.0387e+09, -0.0000e+00],
        [-6.8044e+08, -2.1488e+09,  8.1653e+08]])
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def primitive_to_reciprocal(primitive: torch.Tensor) -&gt; torch.Tensor:
    r&#34;&#34;&#34;Convert the primitive vectors into the reciprocal base vectors.

    Bijection of ``laueimproc.geometry.reciprocal.reciprocal_to_primitive``.

    .. image:: ../../../build/media/IMGPrimitiveReciprocal.avif

    Parameters
    ----------
    primitive : torch.Tensor
        Matrix \(\mathbf{A}\) in any orthonormal base.

    Returns
    -------
    reciprocal : torch.Tensor
        Matrix \(\mathbf{B}\) in the same orthonormal base.

    Examples
    --------
    &gt;&gt;&gt; import torch
    &gt;&gt;&gt; from laueimproc.geometry.reciprocal import primitive_to_reciprocal
    &gt;&gt;&gt; primitive = torch.tensor([[ 6.0000e-10, -1.9000e-10, -6.5567e-17],
    ...                           [ 0.0000e+00,  3.2909e-10,  8.6603e-10],
    ...                           [ 0.0000e+00,  0.0000e+00,  1.2247e-09]])
    &gt;&gt;&gt; primitive_to_reciprocal(primitive)
    tensor([[ 1.6667e+09,  0.0000e+00,  0.0000e+00],
            [ 9.6225e+08,  3.0387e+09, -0.0000e+00],
            [-6.8044e+08, -2.1488e+09,  8.1653e+08]])
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(primitive, torch.Tensor), primitive.__class__.__name__
    assert primitive.shape[-2:] == (3, 3), primitive.shape

    reciprocal = torch.empty_like(primitive)

    volume = torch.linalg.det(primitive).unsqueeze(-1)
    volume_inv = 1.0 / volume
    reciprocal[..., 0] = volume_inv * torch.linalg.cross(primitive[..., 1], primitive[..., 2])
    reciprocal[..., 1] = volume_inv * torch.linalg.cross(primitive[..., 2], primitive[..., 0])
    reciprocal[..., 2] = volume_inv * torch.linalg.cross(primitive[..., 0], primitive[..., 1])
    return reciprocal

    # the version bellow if faster when compiled but slowler with conventional evaluation
    # e1x, e2x, e3x = primitive[..., 0, 0], primitive[..., 0, 1], primitive[..., 0, 2]
    # e1y, e2y, e3y = primitive[..., 1, 0], primitive[..., 1, 1], primitive[..., 1, 2]
    # e1z, e2z, e3z = primitive[..., 2, 0], primitive[..., 2, 1], primitive[..., 2, 2]
    # x_0 = e2y * e3z
    # x_1 = e2z * e3y
    # x_2 = e1y * e2z
    # x_3 = e1z * e3y
    # x_4 = e1y * e3z
    # x_5 = e1z * e2y
    # dx0x1 = x_0 - x_1
    # dx3x4 = x_3 - x_4
    # dx2x5 = x_2 - x_5
    # vol = 1.0 / (e1x*dx0x1 + e2x*dx3x4 + e3x*dx2x5)
    # return torch.cat([
    #     (vol * dx0x1).unsqueeze(-1),
    #     (vol * dx3x4).unsqueeze(-1),
    #     (vol * dx2x5).unsqueeze(-1),
    #     (vol * (e2z*e3x - e2x*e3z)).unsqueeze(-1),
    #     (vol * (e1x*e3z - e1z*e3x)).unsqueeze(-1),
    #     (vol * (e1z*e2x - e1x*e2z)).unsqueeze(-1),
    #     (vol * (e2x*e3y - e2y*e3x)).unsqueeze(-1),
    #     (vol * (e1y*e3x - e1x*e3y)).unsqueeze(-1),
    #     (vol * (e1x*e2y - e1y*e2x)).unsqueeze(-1),
    # ], dim=-1).reshape(primitive.shape)</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.ray_phi_dist"><code class="name flex">
<span>def <span class="ident">ray_phi_dist</span></span>(<span>ray_point_1:Â torch.Tensor, ray_point_2:Â torch.Tensor, poni:Â NoneÂ |Â torch.TensorÂ =Â None) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the angle distance matrix of the rays pairwise.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ray_point_1</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The 2d point associated to uf in the referencial of the detector of shape (*n, r1, 2).
Could be directly the unitary ray vector uf or uq of shape (*n, r1, 3).</dd>
<dt><strong><code>ray_point_2</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The 2d point associated to uf in the referencial of the detector of shape (*n', r2, 2)).
Could be directly the unitary ray vector uf or uq of shape (*n', r2, 3).</dd>
<dt><strong><code>poni</code></strong> :&ensp;<code>torch.Tensor</code>, optional</dt>
<dd>Only use if the ray are projected points.
The point of normal incidence, callibration parameters according the pyfai convention.
Values are [dist, poni_1, poni_2, rot_1, rot_2, rot_3] of shape (*p, 6).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>phi</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The distance matrix <span><span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script></span> of shape (*broadcast(n, n'), *p, r1, r2).
<span><span class="MathJax_Preview">\phi \in [0, \pi]</span><script type="math/tex">\phi \in [0, \pi]</script></span>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>It's mathematically equivalent to calculating acos of
<code><a title="laueimproc.geometry.metric.ray_cosine_dist" href="metric.html#laueimproc.geometry.metric.ray_cosine_dist">ray_cosine_dist()</a></code>,
but this function is numerically more stable for small angles.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import torch
&gt;&gt;&gt; from laueimproc.geometry.metric import ray_phi_dist
&gt;&gt;&gt; ray_1 = torch.randn(500, 3)
&gt;&gt;&gt; ray_1 /= torch.linalg.norm(ray_1, dim=1, keepdims=True)
&gt;&gt;&gt; ray_2 = torch.randn(2000, 3)
&gt;&gt;&gt; ray_2 /= torch.linalg.norm(ray_2, dim=1, keepdims=True)
&gt;&gt;&gt; ray_phi_dist(ray_1, ray_2).shape
torch.Size([500, 2000])
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ray_phi_dist(
    ray_point_1: torch.Tensor, ray_point_2: torch.Tensor, poni: None | torch.Tensor = None
) -&gt; torch.Tensor:
    r&#34;&#34;&#34;Compute the angle distance matrix of the rays pairwise.

    Parameters
    ----------
    ray_point_1 : torch.Tensor
        The 2d point associated to uf in the referencial of the detector of shape (\*n, r1, 2).
        Could be directly the unitary ray vector uf or uq of shape (\*n, r1, 3).
    ray_point_2 : torch.Tensor
        The 2d point associated to uf in the referencial of the detector of shape (\*n&#39;, r2, 2)).
        Could be directly the unitary ray vector uf or uq of shape (\*n&#39;, r2, 3).
    poni : torch.Tensor, optional
        Only use if the ray are projected points.
        The point of normal incidence, callibration parameters according the pyfai convention.
        Values are [dist, poni_1, poni_2, rot_1, rot_2, rot_3] of shape (\*p, 6).

    Returns
    -------
    phi : torch.Tensor
        The distance matrix \(\phi\) of shape (\*broadcast(n, n&#39;), \*p, r1, r2).
        \(\phi \in [0, \pi]\).

    Notes
    -----
    It&#39;s mathematically equivalent to calculating acos of
    ``laueimproc.geometry.metric.ray_cosine_dist``,
    but this function is numerically more stable for small angles.

    Examples
    --------
    &gt;&gt;&gt; import torch
    &gt;&gt;&gt; from laueimproc.geometry.metric import ray_phi_dist
    &gt;&gt;&gt; ray_1 = torch.randn(500, 3)
    &gt;&gt;&gt; ray_1 /= torch.linalg.norm(ray_1, dim=1, keepdims=True)
    &gt;&gt;&gt; ray_2 = torch.randn(2000, 3)
    &gt;&gt;&gt; ray_2 /= torch.linalg.norm(ray_2, dim=1, keepdims=True)
    &gt;&gt;&gt; ray_phi_dist(ray_1, ray_2).shape
    torch.Size([500, 2000])
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(ray_point_1, torch.Tensor), ray_point_1.__class__.__name__
    assert isinstance(ray_point_2, torch.Tensor), ray_point_2.__class__.__name__

    if ray_point_1.shape[-1] == 2:
        assert poni is not None
        ray_1 = detector_to_ray(ray_point_1, poni)  # (*broadcast(p, p&#39;), *r1, 3)
    elif ray_point_1.shape[-1] == 3:
        ray_1 = ray_point_1
    else:
        raise ValueError(&#34;only shape 2 and 3 allow&#34;)
    if ray_point_2.shape[-1] == 2:
        assert poni is not None
        ray_2 = detector_to_ray(ray_point_2, poni)  # (*broadcast(p, p&#39;), *r2, 3)
    elif ray_point_2.shape[-1] == 3:
        ray_2 = ray_point_2
    else:
        raise ValueError(&#34;only shape 2 and 3 allow&#34;)

    ray_1 = ray_1[..., :, None, :]
    ray_2 = ray_2[..., None, :, :]

    cosine_dist = torch.sum(ray_1 * ray_2, dim=-1)

    mask_p1 = cosine_dist &gt; 0.707
    mask_m1 = cosine_dist &lt; -0.707
    ray_1, ray_2 = torch.broadcast_tensors(ray_1, ray_2)
    cross_p1 = torch.sqrt(torch.sum(torch.linalg.cross(ray_1[mask_p1], ray_2[mask_p1])**2, dim=-1))
    cross_m1 = torch.sqrt(torch.sum(torch.linalg.cross(ray_1[mask_m1], ray_2[mask_m1])**2, dim=-1))
    phi_p1 = torch.asin(cross_p1)
    phi_m1 = torch.pi - torch.asin(cross_m1)

    phi = torch.empty_like(cosine_dist)
    phi[~(mask_p1 | mask_m1)] = torch.acos(cosine_dist[~(mask_p1 | mask_m1)])
    phi[mask_p1] = phi_p1
    phi[mask_m1] = phi_m1
    return phi</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.ray_to_detector"><code class="name flex">
<span>def <span class="ident">ray_to_detector</span></span>(<span>ray:Â torch.Tensor, poni:Â torch.Tensor, *, cartesian_product:Â boolÂ =Â True) â€‘>Â tuple[torch.Tensor,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Find the intersection of the light ray with the detector.</p>
<p>Bijection of <code><a title="laueimproc.geometry.projection.detector_to_ray" href="projection.html#laueimproc.geometry.projection.detector_to_ray">detector_to_ray()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ray</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The unitary ray vector of shape (*r, 3).</dd>
<dt><strong><code>poni</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The point of normal incidence, callibration parameters according the pyfai convention.
Values are [dist, poni_1, poni_2, rot_1, rot_2, rot_3] of shape (*p, 6).</dd>
<dt><strong><code>cartesian_product</code></strong> :&ensp;<code>boolean</code>, default=<code>True</code></dt>
<dd>
<p>If True (default value), batch dimensions are iterated independently like neasted for loop.
Overwise, the batch dimensions are broadcasted like a zip.</p>
<ul>
<li>True: The final shape are (*r, *p, 2) and (*r, *p).</li>
<li>False: The final shape are (*broadcast(r, p), 2) and broadcast(r, p).</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The 2d points in meter in the referencial of the detector of shape (&hellip;, 2).</dd>
<dt><strong><code>dist</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The algebrical distance of the ray between the sample and the detector.
a positive value means that the beam crashs on the detector.
A negative value means it is moving away. The shape is (&hellip;,).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ray_to_detector(
    ray: torch.Tensor,
    poni: torch.Tensor,
    *, cartesian_product: bool = True,
) -&gt; tuple[torch.Tensor, torch.Tensor]:
    r&#34;&#34;&#34;Find the intersection of the light ray with the detector.

    Bijection of ``laueimproc.geometry.projection.detector_to_ray``.

    Parameters
    ----------
    ray : torch.Tensor
        The unitary ray vector of shape (\*r, 3).
    poni : torch.Tensor
        The point of normal incidence, callibration parameters according the pyfai convention.
        Values are [dist, poni_1, poni_2, rot_1, rot_2, rot_3] of shape (\*p, 6).
    cartesian_product : boolean, default=True
        If True (default value), batch dimensions are iterated independently like neasted for loop.
        Overwise, the batch dimensions are broadcasted like a zip.

        * True: The final shape are (\*r, \*p, 2) and (\*r, \*p).
        * False: The final shape are (\*broadcast(r, p), 2) and broadcast(r, p).

    Returns
    -------
    point : torch.Tensor
        The 2d points in meter in the referencial of the detector of shape (..., 2).
    dist : torch.Tensor
        The algebrical distance of the ray between the sample and the detector.
        a positive value means that the beam crashs on the detector.
        A negative value means it is moving away. The shape is (...,).
    &#34;&#34;&#34;
    assert isinstance(ray, torch.Tensor), ray.__class__.__name__
    assert ray.shape[-1:] == (3,), ray.shape
    assert isinstance(poni, torch.Tensor), poni.__class__.__name__
    assert poni.shape[-1:] == (6,), poni.shape
    assert isinstance(cartesian_product, bool), cartesian_product.__class__.__name__

    if cartesian_product:
        poni_batch = poni.ndim - 1
        poni = poni[*((None,) * (ray.ndim - 1)), ..., :]  # (*r, *p, 6)
        ray = ray[..., *((None,) * poni_batch), :]  # (*r, *p, 3)

    rot = omega_to_rot(poni[..., 3], poni[..., 4], -poni[..., 5], cartesian_product=False)
    rectified_ray = (rot @ ray[..., :, None]).squeeze(-1)  # (..., 3)
    ray_dist = poni[..., 0] / rectified_ray[..., 2]
    point = ray_dist.unsqueeze(-1) * rectified_ray[..., :2]
    point = point + poni[..., 1:3]  # detector shift

    return point, ray_dist</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.reciprocal_to_primitive"><code class="name flex">
<span>def <span class="ident">reciprocal_to_primitive</span></span>(<span>reciprocal:Â torch.Tensor) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the reciprocal vectors into the primitive base vectors.</p>
<p>Bijection of <code><a title="laueimproc.geometry.reciprocal.primitive_to_reciprocal" href="reciprocal.html#laueimproc.geometry.reciprocal.primitive_to_reciprocal">primitive_to_reciprocal()</a></code>.</p>
<p><img alt="" src="../../../build/media/IMGPrimitiveReciprocal.avif"></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reciprocal</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>Matrix <span><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span> in any orthonormal base.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>primitive</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>Matrix <span><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span> in the same orthonormal base.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reciprocal_to_primitive(reciprocal: torch.Tensor) -&gt; torch.Tensor:
    r&#34;&#34;&#34;Convert the reciprocal vectors into the primitive base vectors.

    Bijection of ``laueimproc.geometry.reciprocal.primitive_to_reciprocal``.

    .. image:: ../../../build/media/IMGPrimitiveReciprocal.avif

    Parameters
    ----------
    reciprocal : torch.Tensor
        Matrix \(\mathbf{B}\) in any orthonormal base.

    Returns
    -------
    primitive : torch.Tensor
        Matrix \(\mathbf{A}\) in the same orthonormal base.
    &#34;&#34;&#34;
    return primitive_to_reciprocal(reciprocal)  # inv(f) = f</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.rot_to_omega"><code class="name flex">
<span>def <span class="ident">rot_to_omega</span></span>(<span>rot:Â torch.Tensor) â€‘>Â tuple[torch.Tensor,Â torch.Tensor,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the rotation angles from a fulle rotation matrix.</p>
<p>Bijection of <code><a title="laueimproc.geometry.rotation.omega_to_rot" href="rotation.html#laueimproc.geometry.rotation.omega_to_rot">omega_to_rot()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rot</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The rotation matrix <span><span class="MathJax_Preview">rot_3 . rot_2 . rot_1</span><script type="math/tex">rot_3 . rot_2 . rot_1</script></span> of shape (&hellip;, 3, 3).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>omega1</code></strong> :&ensp;<code>torch.Tensor</code> or <code>float</code></dt>
<dd>The first rotation angle of shape (&hellip;,). <span><span class="MathJax_Preview">\omega_1 \in [-\pi, \pi]</span><script type="math/tex">\omega_1 \in [-\pi, \pi]</script></span>
<span><span class="MathJax_Preview">
rot_1 =
\begin{pmatrix}
1 &amp; 0
&amp;
0 \\
0 &amp; \cos(\omega_1) &amp; -\sin(\omega_1) \\
c &amp; \sin(\omega_1) &amp;
\cos(\omega_1) \\
\end{pmatrix}
</span><script type="math/tex">
rot_1 =
\begin{pmatrix}
1 & 0
&
0 \\
0 & \cos(\omega_1) & -\sin(\omega_1) \\
c & \sin(\omega_1) &
\cos(\omega_1) \\
\end{pmatrix}
</script></span></dd>
<dt><strong><code>omega2</code></strong> :&ensp;<code>torch.Tensor</code> or <code>float</code></dt>
<dd>The second rotation angle of shape (&hellip;,). <span><span class="MathJax_Preview">\omega_2 \in [-\frac{\pi}{2}, \frac{\pi}{2}]</span><script type="math/tex">\omega_2 \in [-\frac{\pi}{2}, \frac{\pi}{2}]</script></span>
<span><span class="MathJax_Preview">
rot_2 =
\begin{pmatrix}
\cos(\omega_2) &amp; 0 &amp; \sin(\omega_2) \\
0 &amp; 1 &amp;
0 \\
-\sin(\omega_2) &amp; 0 &amp; \cos(\omega_2) \\
\end{pmatrix}
</span><script type="math/tex">
rot_2 =
\begin{pmatrix}
\cos(\omega_2) & 0 & \sin(\omega_2) \\
0 & 1 &
0 \\
-\sin(\omega_2) & 0 & \cos(\omega_2) \\
\end{pmatrix}
</script></span></dd>
<dt><strong><code>omega3</code></strong> :&ensp;<code>torch.Tensor</code> or <code>float</code></dt>
<dd>The third rotation angle of shape (&hellip;,). (inverse of pyfai convention)
<span><span class="MathJax_Preview">\omega_3 \in [-\pi, \pi]</span><script type="math/tex">\omega_3 \in [-\pi, \pi]</script></span>
<span><span class="MathJax_Preview">
rot_3 =
\begin{pmatrix}
\cos(\omega_3) &amp; -\sin(\omega_3) &amp; 0 \\
\sin(\omega_3) &amp;
\cos(\omega_3) &amp; 0 \\
0 &amp;
0 &amp; 1 \\
\end{pmatrix}
</span><script type="math/tex">
rot_3 =
\begin{pmatrix}
\cos(\omega_3) & -\sin(\omega_3) & 0 \\
\sin(\omega_3) &
\cos(\omega_3) & 0 \\
0 &
0 & 1 \\
\end{pmatrix}
</script></span></dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import torch
&gt;&gt;&gt; from laueimproc.geometry.rotation import rot_to_omega
&gt;&gt;&gt; rot = torch.tensor([[ 0.7500, -0.2165,  0.6250],
...                     [ 0.4330,  0.8750, -0.2165],
...                     [-0.5000,  0.4330,  0.7500]])
&gt;&gt;&gt; theta = rot_to_omega(rot)
&gt;&gt;&gt; torch.rad2deg(theta[..., 0]).round()
tensor(30.)
&gt;&gt;&gt; torch.rad2deg(theta[..., 1]).round()
tensor(30.)
&gt;&gt;&gt; torch.rad2deg(theta[..., 2]).round()
tensor(30.)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rot_to_omega(rot: torch.Tensor) -&gt; tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
    r&#34;&#34;&#34;Extract the rotation angles from a fulle rotation matrix.

    Bijection of ``laueimproc.geometry.rotation.omega_to_rot``.

    Parameters
    ----------
    rot : torch.Tensor
        The rotation matrix \(rot_3 . rot_2 . rot_1\) of shape (..., 3, 3).

    Returns
    -------
    omega1 : torch.Tensor or float
        The first rotation angle of shape (...,). \(\omega_1 \in [-\pi, \pi]\)
        \(
            rot_1 =
            \begin{pmatrix}
                1 &amp; 0              &amp;               0 \\
                0 &amp; \cos(\omega_1) &amp; -\sin(\omega_1) \\
                c &amp; \sin(\omega_1) &amp;  \cos(\omega_1) \\
            \end{pmatrix}
        \)
    omega2 : torch.Tensor or float
        The second rotation angle of shape (...,). \(\omega_2 \in [-\frac{\pi}{2}, \frac{\pi}{2}]\)
        \(
            rot_2 =
            \begin{pmatrix}
                 \cos(\omega_2) &amp; 0 &amp; \sin(\omega_2) \\
                              0 &amp; 1 &amp;              0 \\
                -\sin(\omega_2) &amp; 0 &amp; \cos(\omega_2) \\
            \end{pmatrix}
        \)
    omega3 : torch.Tensor or float
        The third rotation angle of shape (...,). (inverse of pyfai convention)
        \(\omega_3 \in [-\pi, \pi]\)
        \(
            rot_3 =
            \begin{pmatrix}
                \cos(\omega_3) &amp; -\sin(\omega_3) &amp; 0 \\
                \sin(\omega_3) &amp;  \cos(\omega_3) &amp; 0 \\
                             0 &amp;               0 &amp; 1 \\
            \end{pmatrix}
        \)

    Examples
    --------
    &gt;&gt;&gt; import torch
    &gt;&gt;&gt; from laueimproc.geometry.rotation import rot_to_omega
    &gt;&gt;&gt; rot = torch.tensor([[ 0.7500, -0.2165,  0.6250],
    ...                     [ 0.4330,  0.8750, -0.2165],
    ...                     [-0.5000,  0.4330,  0.7500]])
    &gt;&gt;&gt; theta = rot_to_omega(rot)
    &gt;&gt;&gt; torch.rad2deg(theta[..., 0]).round()
    tensor(30.)
    &gt;&gt;&gt; torch.rad2deg(theta[..., 1]).round()
    tensor(30.)
    &gt;&gt;&gt; torch.rad2deg(theta[..., 2]).round()
    tensor(30.)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(rot, torch.Tensor), rot.__class__.__name__
    assert rot.shape[-2:] == (3, 3), rot.shape
    omega1 = torch.atan2(rot[..., 2, 1], rot[..., 2, 2])
    omega2 = -torch.asin(rot[..., 2, 0])
    omega3 = torch.atan2(rot[..., 1, 0], rot[..., 0, 0])
    return torch.cat([omega1.unsqueeze(-1), omega2.unsqueeze(-1), omega3.unsqueeze(-1)], dim=-1)</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.rotate_crystal"><code class="name flex">
<span>def <span class="ident">rotate_crystal</span></span>(<span>crystal:Â torch.Tensor, rot:Â torch.Tensor, *, cartesian_product:Â boolÂ =Â True) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Apply an active rotation to the crystal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>crystal</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The primitive <span><span class="MathJax_Preview">(\mathbf{A})</span><script type="math/tex">(\mathbf{A})</script></span> or reciprocal <span><span class="MathJax_Preview">(\mathbf{B})</span><script type="math/tex">(\mathbf{B})</script></span> in the base <span><span class="MathJax_Preview">\mathcal{B}</span><script type="math/tex">\mathcal{B}</script></span>.
The shape of this parameter is (*c, 3, 3).</dd>
<dt><strong><code>rot</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The active rotation matrix, of shape (*r, 3, 3).</dd>
<dt><strong><code>cartesian_product</code></strong> :&ensp;<code>boolean</code>, default=<code>True</code></dt>
<dd>
<p>If True (default value), batch dimensions are iterated independently like neasted for loop.
Overwise, the batch dimensions are broadcasted like a zip.</p>
<ul>
<li>True: The final shape is (*c, *r, 3, 3).</li>
<li>False: The final shape is (*broadcast(c, r), 3, 3).</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rotated_crystal</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The batched matricial product <code>rot @ crystal</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_crystal(
    crystal: torch.Tensor,
    rot: torch.Tensor,
    *, cartesian_product: bool = True,
) -&gt; torch.Tensor:
    r&#34;&#34;&#34;Apply an active rotation to the crystal.

    Parameters
    ----------
    crystal : torch.Tensor
        The primitive \((\mathbf{A})\) or reciprocal \((\mathbf{B})\) in the base \(\mathcal{B}\).
        The shape of this parameter is (\*c, 3, 3).
    rot : torch.Tensor
        The active rotation matrix, of shape (\*r, 3, 3).
    cartesian_product : boolean, default=True
        If True (default value), batch dimensions are iterated independently like neasted for loop.
        Overwise, the batch dimensions are broadcasted like a zip.

        * True: The final shape is (\*c, \*r, 3, 3).
        * False: The final shape is (\*broadcast(c, r), 3, 3).

    Returns
    -------
    rotated_crystal: torch.Tensor
        The batched matricial product `rot @ crystal`.
    &#34;&#34;&#34;
    assert isinstance(crystal, torch.Tensor), crystal.__class__.__name__
    assert crystal.shape[-2:] == (3, 3), crystal.shape
    assert isinstance(rot, torch.Tensor), rot.__class__.__name__
    assert rot.shape[-2:] == (3, 3), rot.shape
    assert isinstance(cartesian_product, bool), cartesian_product.__class__.__name__

    if cartesian_product:
        *batch_c, _, _ = crystal.shape
        *batch_r, _, _ = rot.shape
        crystal = crystal[..., *((None,)*len(batch_r)), :, :]
        rot = rot[*((None,)*len(batch_c)), ..., :, :]

    return rot @ crystal</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.select_hkl"><code class="name flex">
<span>def <span class="ident">select_hkl</span></span>(<span>reciprocal:Â NoneÂ |Â torch.TensorÂ =Â None, *, hkl_max:Â NoneÂ |Â numbers.IntegralÂ =Â None, e_max:Â numbers.RealÂ =Â inf, keep_harmonics:Â boolÂ =Â True) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Reject the hkl sistematicaly out of energy band.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reciprocal</code></strong> :&ensp;<code>torch.Tensor</code>, optional</dt>
<dd>Matrix <span><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span> in any orthonormal base.</dd>
<dt><strong><code>hkl_max</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The maximum absolute hkl sum such as |h| + |k| + |l| &lt;= hkl_max.
If it is not provided, it is automaticaly find with the max energy.</dd>
<dt><strong><code>e_max</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Indicies that systematicaly have an energy strictely greater than <code>e_max</code> in J are rejected.</dd>
<dt><strong><code>keep_harmonics</code></strong> :&ensp;<code>boolean</code>, default=<code>True</code></dt>
<dd>If False, delete the multiple hkl indices of the other.
In other words, keep only the highest energy armonic.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>hkl</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The int16 hkl of shape (n, 3).</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import torch
&gt;&gt;&gt; from laueimproc.geometry.hkl import select_hkl
&gt;&gt;&gt; reciprocal = torch.tensor([[2.7778e9,        0,        0],
...                            [1.2142e2, 2.7778e9,        0],
...                            [1.2142e2, 1.2142e2, 2.7778e9]])
&gt;&gt;&gt; select_hkl(hkl_max=18)
tensor([[  0, -18,   0],
        [  0, -17,  -1],
        [  0, -17,   0],
        ...,
        [ 17,   0,   1],
        [ 17,   1,   0],
        [ 18,   0,   0]], dtype=torch.int16)
&gt;&gt;&gt; len(_)
4578
&gt;&gt;&gt; select_hkl(hkl_max=18, keep_harmonics=False)
tensor([[  0, -17,  -1],
        [  0, -17,   1],
        [  0, -16,  -1],
        ...,
        [ 17,   0,  -1],
        [ 17,   0,   1],
        [ 17,   1,   0]], dtype=torch.int16)
&gt;&gt;&gt; len(_)
3661
&gt;&gt;&gt; select_hkl(reciprocal, e_max=20e3 * 1.60e-19)  # 20 keV
tensor([[  0, -11,  -3],
        [  0, -11,  -2],
        [  0, -11,  -1],
        ...,
        [ 11,   3,   0],
        [ 11,   3,   1],
        [ 11,   3,   2]], dtype=torch.int16)
&gt;&gt;&gt; len(_)
3519
&gt;&gt;&gt; select_hkl(reciprocal, e_max=20e3 * 1.60e-19, keep_harmonics=False)  # 20 keV
tensor([[  0, -11,  -3],
        [  0, -11,  -2],
        [  0, -11,  -1],
        ...,
        [ 11,   3,   0],
        [ 11,   3,   1],
        [ 11,   3,   2]], dtype=torch.int16)
&gt;&gt;&gt; len(_)
2889
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_hkl(
    reciprocal: None | torch.Tensor = None,
    *,
    hkl_max: None | numbers.Integral = None,
    e_max: numbers.Real = torch.inf,
    keep_harmonics: bool = True,
) -&gt; torch.Tensor:
    r&#34;&#34;&#34;Reject the hkl sistematicaly out of energy band.

    Parameters
    ----------
    reciprocal : torch.Tensor, optional
        Matrix \(\mathbf{B}\) in any orthonormal base.
    hkl_max : int, optional
        The maximum absolute hkl sum such as |h| + |k| + |l| &lt;= hkl_max.
        If it is not provided, it is automaticaly find with the max energy.
    e_max : float, optional
        Indicies that systematicaly have an energy strictely greater than `e_max` in J are rejected.
    keep_harmonics : boolean, default=True
        If False, delete the multiple hkl indices of the other.
        In other words, keep only the highest energy armonic.

    Returns
    -------
    hkl : torch.Tensor
        The int16 hkl of shape (n, 3).

    Examples
    --------
    &gt;&gt;&gt; import torch
    &gt;&gt;&gt; from laueimproc.geometry.hkl import select_hkl
    &gt;&gt;&gt; reciprocal = torch.tensor([[2.7778e9,        0,        0],
    ...                            [1.2142e2, 2.7778e9,        0],
    ...                            [1.2142e2, 1.2142e2, 2.7778e9]])
    &gt;&gt;&gt; select_hkl(hkl_max=18)
    tensor([[  0, -18,   0],
            [  0, -17,  -1],
            [  0, -17,   0],
            ...,
            [ 17,   0,   1],
            [ 17,   1,   0],
            [ 18,   0,   0]], dtype=torch.int16)
    &gt;&gt;&gt; len(_)
    4578
    &gt;&gt;&gt; select_hkl(hkl_max=18, keep_harmonics=False)
    tensor([[  0, -17,  -1],
            [  0, -17,   1],
            [  0, -16,  -1],
            ...,
            [ 17,   0,  -1],
            [ 17,   0,   1],
            [ 17,   1,   0]], dtype=torch.int16)
    &gt;&gt;&gt; len(_)
    3661
    &gt;&gt;&gt; select_hkl(reciprocal, e_max=20e3 * 1.60e-19)  # 20 keV
    tensor([[  0, -11,  -3],
            [  0, -11,  -2],
            [  0, -11,  -1],
            ...,
            [ 11,   3,   0],
            [ 11,   3,   1],
            [ 11,   3,   2]], dtype=torch.int16)
    &gt;&gt;&gt; len(_)
    3519
    &gt;&gt;&gt; select_hkl(reciprocal, e_max=20e3 * 1.60e-19, keep_harmonics=False)  # 20 keV
    tensor([[  0, -11,  -3],
            [  0, -11,  -2],
            [  0, -11,  -1],
            ...,
            [ 11,   3,   0],
            [ 11,   3,   1],
            [ 11,   3,   2]], dtype=torch.int16)
    &gt;&gt;&gt; len(_)
    2889
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(hkl_max, None | numbers.Integral), hkl_max.__class__.__name__
    assert hkl_max is None or 0 &lt; hkl_max &lt;= torch.iinfo(torch.int16).max, hkl_max
    assert isinstance(e_max, numbers.Real), e_max.__class__.__name__
    assert isinstance(keep_harmonics, bool), keep_harmonics.__class__.__name__
    assert isinstance(reciprocal, None | torch.Tensor), reciprocal.__class__.__name__
    assert reciprocal is None or reciprocal.shape[-2:] == (3, 3), reciprocal.shape

    if hkl_max is None:
        assert reciprocal is not None and e_max &lt; torch.inf, \
            &#34;you have to provide &#39;hkl_max&#39; or &#39;reciprocal&#39; and &#39;e_max&#39;&#34;
        q_norm = math.sqrt(float(torch.min(torch.sum(reciprocal * reciprocal, dim=-2))))
        hkl_max = math.ceil(3.47 * e_max / (CELERITY_C * PLANK_H * q_norm))  # |q| &lt; 2*e_max / (H*C)

    hkl = _select_all_hkl(  # (n, 3)
        int(hkl_max), device=(torch.device(&#34;cpu&#34;) if reciprocal is None else reciprocal.device)
    )

    if reciprocal is not None and e_max &lt; torch.inf:
        u_q = reciprocal[..., None, :, :] @ hkl[..., None].to(reciprocal.device, reciprocal.dtype)
        inv_d_square = u_q.mT @ u_q  # (..., n, 1, 1)
        energy = 0.5 * CELERITY_C * PLANK_H * torch.sqrt(inv_d_square[..., :, 0, 0])  # (..., n)
        energy = energy.reshape(-1, len(hkl))  # (:, n)
        hkl = hkl[torch.any(energy &lt;= e_max, dim=0)]  # energy corresponds to the energy max
    else:
        energy = None

    if not keep_harmonics:
        hkl = hkl[torch.gcd(torch.gcd(hkl[:, 0], hkl[:, 1]), hkl[:, 2]) == 1]
        # method to select only the first diffracting harmonic, if e_min &gt; 0 ...
        # family = hkl // torch.gcd(torch.gcd(hkl[:, 0], hkl[:, 1]), hkl[:, 2]).unsqueeze(-1)
        # family = family.tolist()
        # family_dict = {}  # to each family, associate the hkls
        # hkl = hkl.tolist()
        # for family_, hkl_ in zip(family, hkl):
        #     family_ = tuple(family_)
        #     family_dict[family_] = family_dict.get(family_, [])
        #     family_dict[family_].append(hkl_)
        # family_dict = {  # to each family, associate the hkl to keep
        #     family_: min(hkl_list, key=lambda hkl_: sum(map(abs, hkl_)))
        #     for family_, hkl_list in family_dict.items()
        # }
        # hkl = [
        #     hkl_ for hkl_, family_ in zip(hkl, family)
        #     if family_dict[tuple(family_)] == hkl_
        # ]
        # hkl = torch.tensor(hkl, device=lattice.device, dtype=torch.int16)

    return hkl</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.thetachi_to_uf"><code class="name flex">
<span>def <span class="ident">thetachi_to_uf</span></span>(<span>theta:Â torch.Tensor, chi:Â torch.Tensor) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Reconstruct the diffracted ray from the deviation angles.</p>
<p>Bijection of <code><a title="laueimproc.geometry.thetachi.uf_to_thetachi" href="thetachi.html#laueimproc.geometry.thetachi.uf_to_thetachi">uf_to_thetachi()</a></code>.</p>
<p><img alt="" src="../../../build/media/IMGThetaChi.avif"></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The half deviation angle in radian in the plan <span><span class="MathJax_Preview">(u_f, \mathbf{L_3})</span><script type="math/tex">(u_f, \mathbf{L_3})</script></span>,
with <span><span class="MathJax_Preview">\theta \in [0, \frac{\pi}{2}]</span><script type="math/tex">\theta \in [0, \frac{\pi}{2}]</script></span>.</dd>
<dt><strong><code>chi</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The rotation angle in radian from the vertical plan <span><span class="MathJax_Preview">(\mathbf{L_1}, \mathbf{L_3})</span><script type="math/tex">(\mathbf{L_1}, \mathbf{L_3})</script></span>
to the plan <span><span class="MathJax_Preview">(u_f, \mathbf{L_3})</span><script type="math/tex">(u_f, \mathbf{L_3})</script></span>, with <span><span class="MathJax_Preview">\chi \in [-\pi, \pi]</span><script type="math/tex">\chi \in [-\pi, \pi]</script></span>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>u_f</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The unitary diffracted ray of shape (*broadcast(theta.shape, chi.shape), 3).
It is expressed in the lab base <span><span class="MathJax_Preview">\mathcal{B^l}</span><script type="math/tex">\mathcal{B^l}</script></span>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>According the pyfai convention, <span><span class="MathJax_Preview">u_i = \mathbf{L_1}</span><script type="math/tex">u_i = \mathbf{L_1}</script></span>.</li>
<li>This function is slow, use <code><a title="laueimproc.geometry.bragg.uq_to_uf" href="bragg.html#laueimproc.geometry.bragg.uq_to_uf">uq_to_uf()</a></code> if you can.</li>
</ul>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import torch
&gt;&gt;&gt; from laueimproc.geometry.thetachi import thetachi_to_uf
&gt;&gt;&gt; theta = torch.deg2rad(torch.tensor([15., 30., 45.]))
&gt;&gt;&gt; chi = torch.deg2rad(torch.tensor([ -0.,  90., -45.]))
&gt;&gt;&gt; thetachi_to_uf(theta, chi).round(decimals=4)
tensor([[ 0.5000,  0.0000,  0.8660],
        [-0.0000, -0.8660,  0.5000],
        [ 0.7071,  0.7071, -0.0000]])
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thetachi_to_uf(theta: torch.Tensor, chi: torch.Tensor) -&gt; torch.Tensor:
    r&#34;&#34;&#34;Reconstruct the diffracted ray from the deviation angles.

    Bijection of ``laueimproc.geometry.thetachi.uf_to_thetachi``.

    .. image:: ../../../build/media/IMGThetaChi.avif

    Parameters
    ----------
    theta : torch.Tensor
        The half deviation angle in radian in the plan \((u_f, \mathbf{L_3})\),
        with \(\theta \in [0, \frac{\pi}{2}]\).
    chi : torch.Tensor
        The rotation angle in radian from the vertical plan \((\mathbf{L_1}, \mathbf{L_3})\)
        to the plan \((u_f, \mathbf{L_3})\), with \(\chi \in [-\pi, \pi]\).

    Returns
    -------
    u_f : torch.Tensor
        The unitary diffracted ray of shape (*broadcast(theta.shape, chi.shape), 3).
        It is expressed in the lab base \(\mathcal{B^l}\).

    Notes
    -----
    * According the pyfai convention, \(u_i = \mathbf{L_1}\).
    * This function is slow, use ``laueimproc.geometry.bragg.uq_to_uf`` if you can.

    Examples
    --------
    &gt;&gt;&gt; import torch
    &gt;&gt;&gt; from laueimproc.geometry.thetachi import thetachi_to_uf
    &gt;&gt;&gt; theta = torch.deg2rad(torch.tensor([15., 30., 45.]))
    &gt;&gt;&gt; chi = torch.deg2rad(torch.tensor([ -0.,  90., -45.]))
    &gt;&gt;&gt; thetachi_to_uf(theta, chi).round(decimals=4)
    tensor([[ 0.5000,  0.0000,  0.8660],
            [-0.0000, -0.8660,  0.5000],
            [ 0.7071,  0.7071, -0.0000]])
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(theta, torch.Tensor), theta.__class__.__name__
    assert isinstance(chi, torch.Tensor), chi.__class__.__name__

    batch = torch.broadcast_shapes(theta.shape, chi.shape)
    twicetheta = 2.0 * theta
    proj3 = torch.broadcast_to(torch.cos(twicetheta), batch)
    proj12 = torch.sin(twicetheta)
    proj1 = proj12 * torch.cos(chi)
    proj2 = proj12 * torch.sin(-chi)

    return torch.cat([proj1.unsqueeze(-1), proj2.unsqueeze(-1), proj3.unsqueeze(-1)], dim=-1)</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.uf_to_thetachi"><code class="name flex">
<span>def <span class="ident">uf_to_thetachi</span></span>(<span>u_f:Â torch.Tensor) â€‘>Â tuple[torch.Tensor,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Find the angular deviation of the dffracted ray.</p>
<p>Bijection of <code><a title="laueimproc.geometry.thetachi.thetachi_to_uf" href="thetachi.html#laueimproc.geometry.thetachi.thetachi_to_uf">thetachi_to_uf()</a></code>.</p>
<p><img alt="" src="../../../build/media/IMGThetaChi.avif"></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u_f</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The unitary diffracted ray of shape (&hellip;, 3) in the lab base <span><span class="MathJax_Preview">\mathcal{B^l}</span><script type="math/tex">\mathcal{B^l}</script></span>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The half deviation angle in radian, of shape (&hellip;,). <span><span class="MathJax_Preview">\theta \in [0, \frac{\pi}{2}]</span><script type="math/tex">\theta \in [0, \frac{\pi}{2}]</script></span></dd>
<dt><strong><code>chi</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The counterclockwise (trigonometric) rotation of the diffracted ray if you look as u_i.
It is the angle from the vertical plan <span><span class="MathJax_Preview">(\mathbf{L_1}, \mathbf{L_3})</span><script type="math/tex">(\mathbf{L_1}, \mathbf{L_3})</script></span>
to the plan <span><span class="MathJax_Preview">(u_i, \mathcal{B^l_z})</span><script type="math/tex">(u_i, \mathcal{B^l_z})</script></span>.
The shape is (&hellip;,) as well. <span><span class="MathJax_Preview">\chi \in [-\pi, \pi]</span><script type="math/tex">\chi \in [-\pi, \pi]</script></span></dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>According the pyfai convention, <span><span class="MathJax_Preview">u_i = \mathbf{L_1}</span><script type="math/tex">u_i = \mathbf{L_1}</script></span>.</li>
<li>This function is slow, use <code><a title="laueimproc.geometry.bragg.uf_to_uq" href="bragg.html#laueimproc.geometry.bragg.uf_to_uq">uf_to_uq()</a></code> if you can.</li>
</ul>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import torch
&gt;&gt;&gt; from laueimproc.geometry.thetachi import uf_to_thetachi
&gt;&gt;&gt; u_f = torch.tensor([[1/2, 0, 3**(1/2)/2], [0, -3**(1/2)/2, 1/2], [2**(1/2), 2**(1/2), 0]])
&gt;&gt;&gt; theta, chi = uf_to_thetachi(u_f)
&gt;&gt;&gt; torch.rad2deg(theta).round()
tensor([15., 30., 45.])
&gt;&gt;&gt; torch.rad2deg(chi).round()
tensor([ -0.,  90., -45.])
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uf_to_thetachi(u_f: torch.Tensor) -&gt; tuple[torch.Tensor, torch.Tensor]:
    r&#34;&#34;&#34;Find the angular deviation of the dffracted ray.

    Bijection of ``laueimproc.geometry.thetachi.thetachi_to_uf``.

    .. image:: ../../../build/media/IMGThetaChi.avif

    Parameters
    ----------
    u_f : torch.Tensor
        The unitary diffracted ray of shape (..., 3) in the lab base \(\mathcal{B^l}\).

    Returns
    -------
    theta : torch.Tensor
        The half deviation angle in radian, of shape (...,). \(\theta \in [0, \frac{\pi}{2}]\)
    chi : torch.Tensor
        The counterclockwise (trigonometric) rotation of the diffracted ray if you look as u_i.
        It is the angle from the vertical plan \((\mathbf{L_1}, \mathbf{L_3})\)
        to the plan \((u_i, \mathcal{B^l_z})\).
        The shape is (...,) as well. \(\chi \in [-\pi, \pi]\)

    Notes
    -----
    * According the pyfai convention, \(u_i = \mathbf{L_1}\).
    * This function is slow, use ``laueimproc.geometry.bragg.uf_to_uq`` if you can.

    Examples
    --------
    &gt;&gt;&gt; import torch
    &gt;&gt;&gt; from laueimproc.geometry.thetachi import uf_to_thetachi
    &gt;&gt;&gt; u_f = torch.tensor([[1/2, 0, 3**(1/2)/2], [0, -3**(1/2)/2, 1/2], [2**(1/2), 2**(1/2), 0]])
    &gt;&gt;&gt; theta, chi = uf_to_thetachi(u_f)
    &gt;&gt;&gt; torch.rad2deg(theta).round()
    tensor([15., 30., 45.])
    &gt;&gt;&gt; torch.rad2deg(chi).round()
    tensor([ -0.,  90., -45.])
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(u_f, torch.Tensor), u_f.__class__.__name__
    assert u_f.shape[-1:] == (3,), u_f.shape

    theta = 0.5 * torch.acos(u_f[..., 2])  # cos(2 * theta) = &lt;uf, ui&gt;
    chi = torch.atan2(-u_f[..., 1], u_f[..., 0])

    return theta, chi</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.uf_to_uq"><code class="name flex">
<span>def <span class="ident">uf_to_uq</span></span>(<span>u_f:Â torch.Tensor) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the vector normal to the diffracting planes.</p>
<p>Bijection of <code><a title="laueimproc.geometry.bragg.uq_to_uf" href="bragg.html#laueimproc.geometry.bragg.uq_to_uf">uq_to_uf()</a></code>.</p>
<p><span><span class="MathJax_Preview">u_q \propto u_f - u_i</span><script type="math/tex">u_q \propto u_f - u_i</script></span></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u_f</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The unitary diffracted rays of shape (&hellip;, 3) in the lab base <span><span class="MathJax_Preview">\mathcal{B^l}</span><script type="math/tex">\mathcal{B^l}</script></span>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>u_q</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The unitary normals of shape (&hellip;, 3) in the lab base <span><span class="MathJax_Preview">\mathcal{B^l}</span><script type="math/tex">\mathcal{B^l}</script></span>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>According the pyfai convention, <span><span class="MathJax_Preview">u_i = \mathbf{L_1}</span><script type="math/tex">u_i = \mathbf{L_1}</script></span>.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uf_to_uq(u_f: torch.Tensor) -&gt; torch.Tensor:
    r&#34;&#34;&#34;Calculate the vector normal to the diffracting planes.

    Bijection of ``laueimproc.geometry.bragg.uq_to_uf``.

    \(u_q \propto u_f - u_i\)

    Parameters
    ----------
    u_f : torch.Tensor
        The unitary diffracted rays of shape (..., 3) in the lab base \(\mathcal{B^l}\).

    Returns
    -------
    u_q : torch.Tensor
        The unitary normals of shape (..., 3) in the lab base \(\mathcal{B^l}\).

    Notes
    -----
    * According the pyfai convention, \(u_i = \mathbf{L_1}\).
    &#34;&#34;&#34;
    assert isinstance(u_f, torch.Tensor), u_f.__class__.__name__
    assert u_f.shape[-1:] == (3,), u_f.shape

    u_q = u_f.clone()
    u_q[..., 2] -= 1.0  # uf - ui
    norm = torch.sum(u_q * u_q, dim=-1, keepdim=True)
    # eps = torch.finfo(u_q.dtype).eps  # to solve case no deviation
    # norm[norm &lt;= eps] = torch.inf  # to solve case no deviation
    u_q = u_q * torch.rsqrt(norm)
    return u_q</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.uq_to_uf"><code class="name flex">
<span>def <span class="ident">uq_to_uf</span></span>(<span>u_q:Â torch.Tensor) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the diffracted ray from q vector.</p>
<p>Bijection of <code><a title="laueimproc.geometry.bragg.uf_to_uq" href="bragg.html#laueimproc.geometry.bragg.uf_to_uq">uf_to_uq()</a></code>.</p>
<p><span><span class="MathJax_Preview">\begin{cases}
u_f - u_i = \eta u_q \\
\eta = 2 \langle u_q, -u_i \rangle \\
\end{cases}</span><script type="math/tex">\begin{cases}
u_f - u_i = \eta u_q \\
\eta = 2 \langle u_q, -u_i \rangle \\
\end{cases}</script></span></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u_q</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The unitary q vectors of shape (&hellip;, 3) in the lab base <span><span class="MathJax_Preview">\mathcal{B^l}</span><script type="math/tex">\mathcal{B^l}</script></span>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>u_f</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The unitary diffracted ray of shape (&hellip;, 3) in the lab base <span><span class="MathJax_Preview">\mathcal{B^l}</span><script type="math/tex">\mathcal{B^l}</script></span>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li><span><span class="MathJax_Preview">u_f</span><script type="math/tex">u_f</script></span> is not sensitive to the <span><span class="MathJax_Preview">u_q</span><script type="math/tex">u_q</script></span> orientation.</li>
<li>According the pyfai convention, <span><span class="MathJax_Preview">u_i = \mathbf{L_1}</span><script type="math/tex">u_i = \mathbf{L_1}</script></span>.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uq_to_uf(u_q: torch.Tensor) -&gt; torch.Tensor:
    r&#34;&#34;&#34;Calculate the diffracted ray from q vector.

    Bijection of ``laueimproc.geometry.bragg.uf_to_uq``.

    \(\begin{cases}
        u_f - u_i = \eta u_q \\
        \eta = 2 \langle u_q, -u_i \rangle \\
    \end{cases}\)

    Parameters
    ----------
    u_q : torch.Tensor
        The unitary q vectors of shape (..., 3) in the lab base \(\mathcal{B^l}\).

    Returns
    -------
    u_f : torch.Tensor
        The unitary diffracted ray of shape (..., 3) in the lab base \(\mathcal{B^l}\).

    Notes
    -----
    * \(u_f\) is not sensitive to the \(u_q\) orientation.
    * According the pyfai convention, \(u_i = \mathbf{L_1}\).
    &#34;&#34;&#34;
    assert isinstance(u_q, torch.Tensor), u_q.__class__.__name__
    assert u_q.shape[-1:] == (3,), u_q.shape

    uq_dot_ui = u_q[..., 2]  # -&lt;uq, -ui&gt;
    q_norm = -2.0 * uq_dot_ui
    u_f = q_norm.unsqueeze(-1) * u_q
    u_f[..., 2] += 1.0  # eta * uq + ui
    return u_f</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="laueimproc.geometry.Geometry"><code class="flex name class">
<span>class <span class="ident">Geometry</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>General simulation class.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>cam_size</code></strong> :&ensp;<code>None | tuple[float, float]</code></dt>
<dd>The size of the detector in m.</dd>
<dt><strong><code>e_min</code></strong> :&ensp;<code>float</code></dt>
<dd>Low energy limit in J (read and write).</dd>
<dt><strong><code>e_max</code></strong> :&ensp;<code>float</code></dt>
<dd>High energy limit in J (read and write).</dd>
<dt><strong><code>lattice</code></strong> :&ensp;<code>None | torch.Tensor</code></dt>
<dd>The lattice parameters of shape (&hellip;, 6) (read and write).</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>None | torch.Tensor</code></dt>
<dd>The rotation angles of the different grains of shape (&hellip;, 3) (read and write).</dd>
<dt><strong><code>poni</code></strong> :&ensp;<code>torch.Tensor</code>, optional</dt>
<dd>The camera calibration parameters of shape (&hellip;, 6) (read and write).</dd>
<dt><strong><code>primitive_bc</code></strong> :&ensp;<code>None | torch.Tensor</code></dt>
<dd>Matrix <span><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span> of shape (&hellip;, 3, 3) in the crystal base <span><span class="MathJax_Preview">\mathcal{B^c}</span><script type="math/tex">\mathcal{B^c}</script></span> (readonly).</dd>
<dt><strong><code>reciprocal_bc</code></strong> :&ensp;<code>None | torch.Tensor</code></dt>
<dd>Matrix <span><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span> of shape (&hellip;, 3, 3) in the crystal base <span><span class="MathJax_Preview">\mathcal{B^c}</span><script type="math/tex">\mathcal{B^c}</script></span> (readonly).</dd>
<dt><strong><code>reciprocal_bl</code></strong> :&ensp;<code>None | torch.Tensor</code></dt>
<dd>Matrix <span><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span> of shape (&hellip;, 3, 3) in the lab base <span><span class="MathJax_Preview">\mathcal{B^l}</span><script type="math/tex">\mathcal{B^l}</script></span> (readonly).</dd>
<dt><strong><code>rot</code></strong> :&ensp;<code>None | torch.Tensor</code></dt>
<dd>The rotation matrix of shape (&hellip;, 3, 3) (readonly).</dd>
<dt><strong><code>u_f</code></strong> :&ensp;<code>None | torch.Tensor</code></dt>
<dd>The ravel <span><span class="MathJax_Preview">u_f</span><script type="math/tex">u_f</script></span> of shape (n, 3) (readonly).</dd>
<dt><strong><code>u_q</code></strong> :&ensp;<code>None | torch.Tensor</code></dt>
<dd>The ravel <span><span class="MathJax_Preview">u_q</span><script type="math/tex">u_q</script></span> of shape (n, 3) (readonly).</dd>
</dl>
<h2 id="todo">Todo</h2>
<p>This class should be recoded in a more general way, based on a graph.
The current implementation is crude, non-modular and partial.</p>
<p>Initialise the model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cam_size</code></strong> :&ensp;<code>tuple[float, float]</code></dt>
<dd>The size of the detector in m.</dd>
<dt><strong><code>e_min</code></strong>, <strong><code>e_max</code></strong> :&ensp;<code>float</code></dt>
<dd>The light energy band in J.</dd>
<dt><strong><code>lattice</code></strong> :&ensp;<code>torch.Tensor</code>, optional</dt>
<dd>The lattice parameters of the grains to be simulated of shape (&hellip;, 6).</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>torch.Tensor</code>, optional</dt>
<dd>The rotation angles of the different grains of shape (&hellip;, 3).</dd>
<dt><strong><code>poni</code></strong> :&ensp;<code>torch.Tensor</code>, optional</dt>
<dd>The camera calibration parameters of shape (&hellip;, 6).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Geometry(torch.nn.Module):
    r&#34;&#34;&#34;General simulation class.

    Attributes
    ----------
    cam_size : None | tuple[float, float]
        The size of the detector in m.
    e_min : float
        Low energy limit in J (read and write).
    e_max : float
        High energy limit in J (read and write).
    lattice : None | torch.Tensor
        The lattice parameters of shape (..., 6) (read and write).
    phi : None | torch.Tensor
        The rotation angles of the different grains of shape (..., 3) (read and write).
    poni : torch.Tensor, optional
        The camera calibration parameters of shape (..., 6) (read and write).
    primitive_bc : None | torch.Tensor
        Matrix \(\mathbf{A}\) of shape (..., 3, 3) in the crystal base \(\mathcal{B^c}\) (readonly).
    reciprocal_bc : None | torch.Tensor
        Matrix \(\mathbf{B}\) of shape (..., 3, 3) in the crystal base \(\mathcal{B^c}\) (readonly).
    reciprocal_bl : None | torch.Tensor
        Matrix \(\mathbf{B}\) of shape (..., 3, 3) in the lab base \(\mathcal{B^l}\) (readonly).
    rot : None | torch.Tensor
        The rotation matrix of shape (..., 3, 3) (readonly).
    u_f : None | torch.Tensor
        The ravel \(u_f\) of shape (n, 3) (readonly).
    u_q : None | torch.Tensor
        The ravel \(u_q\) of shape (n, 3) (readonly).

    Todo
    ----
    This class should be recoded in a more general way, based on a graph.
    The current implementation is crude, non-modular and partial.
    &#34;&#34;&#34;

    def __init__(self, **kwargs):
        &#34;&#34;&#34;Initialise the model.

        Parameters
        ----------
        cam_size : tuple[float, float]
            The size of the detector in m.
        e_min, e_max : float
            The light energy band in J.
        lattice : torch.Tensor, optional
            The lattice parameters of the grains to be simulated of shape (..., 6).
        phi : torch.Tensor, optional
            The rotation angles of the different grains of shape (..., 3).
        poni : torch.Tensor, optional
            The camera calibration parameters of shape (..., 6).
        &#34;&#34;&#34;
        assert set(kwargs).issubset({&#34;cam_size&#34;, &#34;e_min&#34;, &#34;e_max&#34;, &#34;lattice&#34;, &#34;poni&#34;, &#34;phi&#34;}), \
            sorted(kwargs)

        super().__init__()

        self._cam_size = None
        self._hkl_args = {}
        self._lattice = None
        self._phi = None
        self._poni = None
        self._cache = {}

        self._cam_size = self._select_cam_size(kwargs)
        self._hkl_args.update(self._select_hkl_args(kwargs))  # e_min, e_max
        self._lattice = self._select_lattice(kwargs)
        if self._lattice is not None:
            self._lattice = torch.nn.Parameter(self._lattice)
        self._phi = self._select_phi(kwargs)
        if self._phi is not None:
            self._phi = torch.nn.Parameter(self._phi)
        self._poni = self._select_poni(kwargs)
        if self._poni is not None:
            self._poni = torch.nn.Parameter(self._poni)

    def _select_cam_size(self, kwargs: dict) -&gt; None | tuple[float, float]:
        &#34;&#34;&#34;Recover and checks the parameters `cam_size`.&#34;&#34;&#34;
        if (cam_size := kwargs.get(&#34;cam_size&#34;, None)) is None:
            return self._cam_size
        if self._cam_size is not None:
            warnings.warn(
                &#34;the `cam_size` parameter has already been supplied at initialisation&#34;,
                RuntimeWarning,
            )
        assert hasattr(cam_size, &#34;__iter__&#34;), cam_size.__class__.__name__
        cam_size = list(cam_size)
        assert len(cam_size) == 2, len(cam_size)
        assert isinstance(cam_size[0], numbers.Real) and isinstance(cam_size[1], numbers.Real)
        assert cam_size[0] &gt; 0 and cam_size[1] &gt; 0, cam_size
        return (float(cam_size[0]), float(cam_size[1]))

    def _select_hkl_args(self, kwargs: dict) -&gt; None | dict:
        &#34;&#34;&#34;Recover and checks the parameters e_min and e_max.&#34;&#34;&#34;
        hkl_args = {}
        if (e_min := kwargs.get(&#34;e_min&#34;, None)) is not None:
            assert isinstance(e_min, numbers.Real), e_min.__class__.__name__
            assert e_min &gt;= 0.0, e_min
            hkl_args[&#34;e_min&#34;] = float(e_min)
            if &#34;e_min&#34; in self._hkl_args:
                warnings.warn(
                    &#34;the `e_min` parameter has already been supplied at initialisation&#34;,
                    RuntimeWarning,
                )
        elif (e_min := self._hkl_args.get(&#34;e_min&#34;, None)) is not None:
            hkl_args[&#34;e_min&#34;] = e_min
        if (e_max := kwargs.get(&#34;e_max&#34;, None)) is not None:
            assert isinstance(e_max, numbers.Real), e_max.__class__.__name__
            assert e_max &gt;= hkl_args.get(&#34;e_min&#34;, 0.0), e_max
            hkl_args[&#34;e_max&#34;] = float(e_max)
            if &#34;e_max&#34; in self._hkl_args:
                warnings.warn(
                    &#34;the `e_max` parameter has already been supplied at initialisation&#34;,
                    RuntimeWarning,
                )
        elif (e_max := self._hkl_args.get(&#34;e_max&#34;, None)) is not None:
            hkl_args[&#34;e_max&#34;] = e_max
        return hkl_args

    def _select_lattice(self, kwargs: dict) -&gt; None | torch.Tensor:
        &#34;&#34;&#34;Recover and checks the parameter `lattice`.&#34;&#34;&#34;
        if (lattice := kwargs.get(&#34;lattice&#34;, None)) is None:
            return self._lattice
        if self._lattice is not None:
            warnings.warn(
                &#34;the `lattice` parameter has already been supplied at initialisation&#34;,
                RuntimeWarning,
            )
        assert isinstance(lattice, torch.Tensor), lattice.__class__.__name__
        assert lattice.shape[-1:] == (6,), lattice.shape
        return lattice

    def _select_phi(self, kwargs: dict) -&gt; None | torch.Tensor:
        &#34;&#34;&#34;Recover and checks the parameter `phi`.&#34;&#34;&#34;
        if (phi := kwargs.get(&#34;phi&#34;, None)) is None:
            return self._phi
        if self._phi is not None:
            warnings.warn(
                &#34;the `phi` parameter has already been supplied at initialisation&#34;,
                RuntimeWarning,
            )
        assert isinstance(phi, torch.Tensor), phi.__class__.__name__
        assert phi.shape[-1:] == (3,), phi.shape
        return phi

    def _select_poni(self, kwargs: dict) -&gt; None | torch.Tensor:
        &#34;&#34;&#34;Recover and checks the parameter `poni`.&#34;&#34;&#34;
        if (poni := kwargs.get(&#34;poni&#34;, None)) is None:
            return self._poni
        if self._poni is not None:
            warnings.warn(
                &#34;the `poni` parameter has already been supplied at initialisation&#34;,
                RuntimeWarning,
            )
        assert isinstance(poni, torch.Tensor), poni.__class__.__name__
        assert poni.shape[-1:] == (6,), poni.shape
        return poni

    def _compute_candidate_hkl(self, **kwargs) -&gt; torch.Tensor:
        &#34;&#34;&#34;Get all hkl indices that could potentially diffract.&#34;&#34;&#34;
        reciprocal_bc = self.compute_reciprocal_bc(**kwargs)
        if (e_max := self._select_hkl_args(kwargs).get(&#34;e_max&#34;, None)) is None:
            raise AttributeError(&#34;`e_max` parameter has to be supplied&#34;)
        signature = (&#34;candidate_hkl&#34;, reciprocal_bc.data_ptr(), e_max)
        if (hkl := self._cache.get(signature, None)) is None:
            hkl = self._cache[signature] = select_hkl(reciprocal=reciprocal_bc, e_max=e_max)
        return hkl

    def compute_cam(
        self, **kwargs
    ) -&gt; tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]:
        &#34;&#34;&#34;Get the position of the points on the camera.

        Returns
        -------
        point : torch.Tensor
            The ravel points of shape (n, 2).
        energy : torch.Tensor
            The energy in J of each spot of shape (n,).
        hkl : torch.Tensor
            The full hkl list of shape (m, 3).
        unravel : torch.Tensor
            The int64 indice of each batch dimension of shape (n, o).
            It means that the ith elements comme from the batch unravel[i].
            The dimensions are the batch dimension of ``self.reciprocal_bl + poni``.

        Examples
        --------
        &gt;&gt;&gt; import torch
        &gt;&gt;&gt; from laueimproc.geometry.link import Geometry
        &gt;&gt;&gt; e_max = 25e3 * 1.60e-19  # 25 keV
        &gt;&gt;&gt; lattice = torch.tensor([3.6e-10, 3.6e-10, 3.6e-10, torch.pi/2, torch.pi/2, torch.pi/2])
        &gt;&gt;&gt; poni = torch.tensor([0.07, 73.4e-3, 73.4e-3, 0.0, -torch.pi/2, 0.0])
        &gt;&gt;&gt; phi = torch.zeros(3)
        &gt;&gt;&gt; model = Geometry(e_max=e_max, lattice=lattice, phi=phi, poni=poni)
        &gt;&gt;&gt; point, energy, hkl, _ = model.compute_cam()
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        u_f, energy, hkl, unravel = self.compute_uf(**kwargs)  # (n,)
        if (poni := self._select_poni(kwargs)) is None:  # (...,)
            raise AttributeError(&#34;`poni` parameter has to be supplied&#34;)

        poni_b = poni.shape[:-1]
        point, dist = ray_to_detector(u_f, poni, cartesian_product=True)  # (n, ...)
        cond = dist &gt; 0  # (n, ...)
        if (cam_size := self._select_cam_size(kwargs)) is not None:
            cond &amp;= (
                (point[..., 0] &gt;= 0) &amp; (point[..., 1] &gt;= 0)
                &amp; (point[..., 0] &lt;= cam_size[0]) &amp; (point[..., 1] &lt;= cam_size[1])
            )
        energy = energy[:, *((None,)*len(poni_b))].expand(-1, *poni_b)  # (n, ...)
        hkl = hkl[:, *((None,)*len(poni_b)), :].expand(-1, *poni_b, -1)  # (n, ..., 3)

        point = point[cond]  # (n&#39;, 2)
        energy = energy[cond]  # (n&#39;,)
        hkl = hkl[cond]  # (n&#39;,)

        unravel = unravel[:, *((None,)*len(poni_b)), :].expand(-1, *poni_b, -1)  # (n, ..., o)
        unravel = unravel[cond]  # (n&#39;, o)
        if poni_b:
            indices = torch.meshgrid(  # (...,)
                *(torch.arange(b, device=unravel.device) for b in poni_b), indexing=&#34;ij&#34;
            )
            indices = [  # (n, ...)
                idx.unsqueeze(0).expand(len(u_f), *((-1,)*len(poni_b))) for idx in indices
            ]
            unravel_poni = torch.cat([idx[cond].unsqueeze(1) for idx in indices], dim=1)  # (n&#39;, p)
            unravel = torch.cat([unravel, unravel_poni], dim=1)  # (n&#39;, o+p)

        return point, energy, hkl, unravel

    def compute_primitive_bc(self, **kwargs) -&gt; torch.Tensor:
        r&#34;&#34;&#34;Get \(\mathbf{A}\) of shape (..., 3, 3) in the crystal base \(\mathcal{B^c}\).&#34;&#34;&#34;
        if (lattice := self._select_lattice(kwargs)) is None:
            raise AttributeError(&#34;`lattice` parameter has to be supplied&#34;)
        if lattice.requires_grad:
            return lattice_to_primitive(lattice)
        signature = (&#34;primitive_bc&#34;, lattice.data_ptr())
        if (primitive_bc := self._cache.get(signature, None)) is None:
            primitive_bc = self._cache[signature] = lattice_to_primitive(lattice)
        return primitive_bc

    def compute_reciprocal_bc(self, **kwargs) -&gt; torch.Tensor:
        r&#34;&#34;&#34;Get \(\mathbf{B}\) of shape (..., 3, 3) in the crystal base \(\mathcal{B^c}\).&#34;&#34;&#34;
        primitive_bc = self.compute_primitive_bc(**kwargs)
        if primitive_bc.requires_grad:
            return primitive_to_reciprocal(primitive_bc)
        signature = (&#34;reciprocal_bc&#34;, primitive_bc.data_ptr())
        if (reciprocal_bc := self._cache.get(signature, None)) is None:
            reciprocal_bc = self._cache[signature] = primitive_to_reciprocal(primitive_bc)
        return reciprocal_bc

    def compute_reciprocal_bl(self, **kwargs) -&gt; torch.Tensor:
        r&#34;&#34;&#34;Get \(\mathbf{B}\) of shape (..., 3, 3) in the lab base \(\mathcal{B^l}\).&#34;&#34;&#34;
        reciprocal_bc = self.compute_reciprocal_bc(**kwargs)
        rot = self.compute_rot(**kwargs)
        if rot.requires_grad or reciprocal_bc.requires_grad:
            return rotate_crystal(reciprocal_bc, rot, cartesian_product=False)
        signature = (&#34;reciprocal_bl&#34;, reciprocal_bc.data_ptr(), rot.data_ptr())
        if (reciprocal_bl := self._cache.get(signature, None)) is None:
            reciprocal_bl = self._cache[signature] = (
                rotate_crystal(reciprocal_bc, rot, cartesian_product=False)
            )
        return reciprocal_bl

    def compute_rot(self, **kwargs) -&gt; torch.Tensor:
        &#34;&#34;&#34;Get the rotation matrix of shape (..., 3, 3).&#34;&#34;&#34;
        if (phi := self._select_phi(kwargs)) is None:
            raise AttributeError(&#34;`phi` parameter has to be supplied&#34;)
        if phi.requires_grad:
            return omega_to_rot(*phi.movedim(-1, 0), cartesian_product=False)
        signature = (&#34;rot&#34;, phi.data_ptr())
        if (rot := self._cache.get(signature, None)) is None:
            rot = self._cache[signature] = (
                omega_to_rot(*phi.movedim(-1, 0), cartesian_product=False)
            )
        return rot

    def compute_uf(self, **kwargs) -&gt; tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]:
        r&#34;&#34;&#34;Get the \(u_f\) unitary vector in the lab base \(\mathcal{B^l}\).&#34;&#34;&#34;
        u_q, energy, hkl, unravel = self.compute_uq(**kwargs)
        if u_q.requires_grad:
            return uq_to_uf(u_q), energy, hkl, unravel
        signature = (&#34;uf&#34;, u_q.data_ptr())
        if (u_f := self._cache.get(signature, None)) is None:
            u_f = self._cache[signature] = uq_to_uf(u_q)
        return u_f, energy, hkl, unravel

    def compute_uq(self, **kwargs) -&gt; tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]:
        r&#34;&#34;&#34;Get the \(u_q\) unitary vector in the lab base \(\mathcal{B^l}\).

        Returns
        -------
        u_q : torch.Tensor
            The ravel \(u_q\) of shape (n, 3).
        energy : torch.Tensor
            The energy in J of each \(u_q\) of shape (n,).
        hkl : torch.Tensor
            The full hkl list of shape (n, 3).
        unravel : torch.Tensor
            The int64 indice of each batch dimension of shape (n, o).
            It means that the ith elements comme from the batch unravel[i].
            The dimensions are the batch dimension of ``self.reciprocal_bl``.
        &#34;&#34;&#34;
        hkl = self._compute_candidate_hkl(**kwargs)  # (n, 3)
        reciprocal_bl = self.compute_reciprocal_bl(**kwargs)  # (..., 3, 3)
        e_min = self._select_hkl_args(kwargs).get(&#34;e_min&#34;, 0.0)

        def compute_uq_(hkl, reciprocal_bl, e_min):
            u_q, energy = hkl_reciprocal_to_uq_energy(hkl, reciprocal_bl, cartesian_product=True)
            cond = energy &gt;= e_min  # (m, ...)
            u_q, energy = u_q[cond], energy[cond]
            indices = torch.meshgrid(
                *(torch.arange(b, device=hkl.device) for b in cond.shape), indexing=&#34;ij&#34;
            )
            unravel = torch.cat([idx[cond].unsqueeze(1) for idx in indices], dim=1)
            hkl, unravel = hkl[unravel[:, 0]], unravel[:, 1:]
            return u_q, energy, hkl, unravel

        if reciprocal_bl.requires_grad:
            return compute_uq_(hkl, reciprocal_bl, e_min)
        signature = (&#34;uq&#34;, hkl.data_ptr(), reciprocal_bl.data_ptr(), e_min)
        if (res := self._cache.get(signature, None)) is None:
            res = self._cache[signature] = compute_uq_(hkl, reciprocal_bl, e_min)
        return res

    @property
    def cam_size(self) -&gt; tuple[float, float]:
        &#34;&#34;&#34;Return the camera size.&#34;&#34;&#34;
        return self._cam_size

    @property
    def e_min(self) -&gt; float:
        &#34;&#34;&#34;Return the low energy limit in J.&#34;&#34;&#34;
        return self._hkl_args.get(&#34;e_min&#34;, 0.0)

    @e_min.setter
    def e_min(self, e_min: None | numbers.Real):
        &#34;&#34;&#34;Set the low energy limit.&#34;&#34;&#34;
        if e_min is None:
            if &#34;e_min&#34; in self._hkl_args:
                del self._hkl_args[&#34;e_min&#34;]
        else:
            assert isinstance(e_min, numbers.Real), e_min.__class__.__name__
            assert e_min &gt;= 0.0, e_min
            self._hkl_args[&#34;e_min&#34;] = float(e_min)

    @property
    def e_max(self) -&gt; float:
        &#34;&#34;&#34;Return the high energy limit in J.&#34;&#34;&#34;
        return self._hkl_args.get(&#34;e_max&#34;, torch.inf)

    @e_max.setter
    def e_max(self, e_max: None | numbers.Real):
        &#34;&#34;&#34;Set the high energy limit.&#34;&#34;&#34;
        if e_max is None:
            if &#34;e_max&#34; in self._hkl_args:
                del self._hkl_args[&#34;e_max&#34;]
        else:
            assert isinstance(e_max, numbers.Real), e_max.__class__.__name__
            assert e_max &gt;= self.e_min, e_max
            self._hkl_args[&#34;e_max&#34;] = float(e_max)

    def forward(self):
        &#34;&#34;&#34;Fake method to solve abstract class initialisation.&#34;&#34;&#34;
        raise NotImplementedError(&#34;the forward method has to be overwritten&#34;)

    @property
    def lattice(self) -&gt; None | torch.Tensor:
        &#34;&#34;&#34;Return the lattice parameters of shape (..., 6).&#34;&#34;&#34;
        return self._lattice

    @lattice.setter
    def lattice(self, lattice: None | torch.Tensor):
        &#34;&#34;&#34;Set the lattice parameters.&#34;&#34;&#34;
        if lattice is None:
            self._lattice = None
        else:
            assert isinstance(lattice, torch.Tensor), lattice.__class__.__name__
            assert lattice.shape[-1:] == (6,), lattice.shape
            self._lattice = torch.nn.Parameter(lattice)

    @property
    def phi(self) -&gt; None | torch.Tensor:
        &#34;&#34;&#34;Get the rotation angles of the different grains of shape (..., 3).&#34;&#34;&#34;
        return self._phi

    @phi.setter
    def phi(self, phi: None | torch.Tensor):
        &#34;&#34;&#34;Set the rotation angles.&#34;&#34;&#34;
        if phi is None:
            self._phi = None
        else:
            assert isinstance(phi, torch.Tensor), phi.__class__.__name__
            assert phi.shape[-1:] == (3,), phi.shape
            self._phi = torch.nn.Parameter(phi)

    @property
    def poni(self) -&gt; None | torch.Tensor:
        &#34;&#34;&#34;Return the camera calibration parameters of shape (..., 6).&#34;&#34;&#34;
        return self._poni

    @poni.setter
    def poni(self, poni: None | torch.Tensor):
        &#34;&#34;&#34;Set the camera calibration parameters.&#34;&#34;&#34;
        if poni is None:
            self._poni = None
        else:
            assert isinstance(poni, torch.Tensor), poni.__class__.__name__
            assert poni.shape[-1:] == (6,), poni.shape
            self._poni = torch.nn.Parameter(poni)

    @property
    def primitive_bc(self) -&gt; None | torch.Tensor:
        &#34;&#34;&#34;Alias to ``laueimproc.geometry.link.Geometry.compute_primitive_bc``.&#34;&#34;&#34;
        try:
            return self.compute_primitive_bc()
        except AttributeError:
            return None

    @property
    def reciprocal_bc(self) -&gt; None | torch.Tensor:
        &#34;&#34;&#34;Alias to ``laueimproc.geometry.link.Geometry.compute_reciprocal_bc``.&#34;&#34;&#34;
        try:
            return self.compute_reciprocal_bc()
        except AttributeError:
            return None

    @property
    def reciprocal_bl(self) -&gt; None | torch.Tensor:
        &#34;&#34;&#34;Alias to ``laueimproc.geometry.link.Geometry.compute_reciprocal_bl``.&#34;&#34;&#34;
        try:
            return self.compute_reciprocal_bl()
        except AttributeError:
            return None

    @property
    def rot(self) -&gt; None | torch.Tensor:
        &#34;&#34;&#34;Alias to ``laueimproc.geometry.link.Geometry.compute_rot``.&#34;&#34;&#34;
        try:
            return self.compute_rot()
        except AttributeError:
            return None

    @property
    def u_f(self) -&gt; None | torch.Tensor:
        &#34;&#34;&#34;Alias to ``laueimproc.geometry.link.Geometry.compute_uf``.&#34;&#34;&#34;
        try:
            return self.compute_uf()[0]
        except AttributeError:
            return None

    @property
    def u_q(self) -&gt; None | torch.Tensor:
        &#34;&#34;&#34;Alias to ``laueimproc.geometry.link.Geometry.compute_uq``.&#34;&#34;&#34;
        try:
            return self.compute_uq()[0]
        except AttributeError:
            return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="laueimproc.geometry.Geometry.cam_size"><code class="name">var <span class="ident">cam_size</span> :Â tuple[float,Â float]</code></dt>
<dd>
<div class="desc"><p>Return the camera size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cam_size(self) -&gt; tuple[float, float]:
    &#34;&#34;&#34;Return the camera size.&#34;&#34;&#34;
    return self._cam_size</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.Geometry.e_max"><code class="name">var <span class="ident">e_max</span> :Â float</code></dt>
<dd>
<div class="desc"><p>Return the high energy limit in J.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def e_max(self) -&gt; float:
    &#34;&#34;&#34;Return the high energy limit in J.&#34;&#34;&#34;
    return self._hkl_args.get(&#34;e_max&#34;, torch.inf)</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.Geometry.e_min"><code class="name">var <span class="ident">e_min</span> :Â float</code></dt>
<dd>
<div class="desc"><p>Return the low energy limit in J.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def e_min(self) -&gt; float:
    &#34;&#34;&#34;Return the low energy limit in J.&#34;&#34;&#34;
    return self._hkl_args.get(&#34;e_min&#34;, 0.0)</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.Geometry.lattice"><code class="name">var <span class="ident">lattice</span> :Â NoneÂ |Â torch.Tensor</code></dt>
<dd>
<div class="desc"><p>Return the lattice parameters of shape (&hellip;, 6).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lattice(self) -&gt; None | torch.Tensor:
    &#34;&#34;&#34;Return the lattice parameters of shape (..., 6).&#34;&#34;&#34;
    return self._lattice</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.Geometry.phi"><code class="name">var <span class="ident">phi</span> :Â NoneÂ |Â torch.Tensor</code></dt>
<dd>
<div class="desc"><p>Get the rotation angles of the different grains of shape (&hellip;, 3).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def phi(self) -&gt; None | torch.Tensor:
    &#34;&#34;&#34;Get the rotation angles of the different grains of shape (..., 3).&#34;&#34;&#34;
    return self._phi</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.Geometry.poni"><code class="name">var <span class="ident">poni</span> :Â NoneÂ |Â torch.Tensor</code></dt>
<dd>
<div class="desc"><p>Return the camera calibration parameters of shape (&hellip;, 6).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def poni(self) -&gt; None | torch.Tensor:
    &#34;&#34;&#34;Return the camera calibration parameters of shape (..., 6).&#34;&#34;&#34;
    return self._poni</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.Geometry.primitive_bc"><code class="name">var <span class="ident">primitive_bc</span> :Â NoneÂ |Â torch.Tensor</code></dt>
<dd>
<div class="desc"><p>Alias to <code><a title="laueimproc.geometry.link.Geometry.compute_primitive_bc" href="link.html#laueimproc.geometry.link.Geometry.compute_primitive_bc">Geometry.compute_primitive_bc()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def primitive_bc(self) -&gt; None | torch.Tensor:
    &#34;&#34;&#34;Alias to ``laueimproc.geometry.link.Geometry.compute_primitive_bc``.&#34;&#34;&#34;
    try:
        return self.compute_primitive_bc()
    except AttributeError:
        return None</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.Geometry.reciprocal_bc"><code class="name">var <span class="ident">reciprocal_bc</span> :Â NoneÂ |Â torch.Tensor</code></dt>
<dd>
<div class="desc"><p>Alias to <code><a title="laueimproc.geometry.link.Geometry.compute_reciprocal_bc" href="link.html#laueimproc.geometry.link.Geometry.compute_reciprocal_bc">Geometry.compute_reciprocal_bc()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def reciprocal_bc(self) -&gt; None | torch.Tensor:
    &#34;&#34;&#34;Alias to ``laueimproc.geometry.link.Geometry.compute_reciprocal_bc``.&#34;&#34;&#34;
    try:
        return self.compute_reciprocal_bc()
    except AttributeError:
        return None</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.Geometry.reciprocal_bl"><code class="name">var <span class="ident">reciprocal_bl</span> :Â NoneÂ |Â torch.Tensor</code></dt>
<dd>
<div class="desc"><p>Alias to <code><a title="laueimproc.geometry.link.Geometry.compute_reciprocal_bl" href="link.html#laueimproc.geometry.link.Geometry.compute_reciprocal_bl">Geometry.compute_reciprocal_bl()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def reciprocal_bl(self) -&gt; None | torch.Tensor:
    &#34;&#34;&#34;Alias to ``laueimproc.geometry.link.Geometry.compute_reciprocal_bl``.&#34;&#34;&#34;
    try:
        return self.compute_reciprocal_bl()
    except AttributeError:
        return None</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.Geometry.rot"><code class="name">var <span class="ident">rot</span> :Â NoneÂ |Â torch.Tensor</code></dt>
<dd>
<div class="desc"><p>Alias to <code><a title="laueimproc.geometry.link.Geometry.compute_rot" href="link.html#laueimproc.geometry.link.Geometry.compute_rot">Geometry.compute_rot()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rot(self) -&gt; None | torch.Tensor:
    &#34;&#34;&#34;Alias to ``laueimproc.geometry.link.Geometry.compute_rot``.&#34;&#34;&#34;
    try:
        return self.compute_rot()
    except AttributeError:
        return None</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.Geometry.u_f"><code class="name">var <span class="ident">u_f</span> :Â NoneÂ |Â torch.Tensor</code></dt>
<dd>
<div class="desc"><p>Alias to <code><a title="laueimproc.geometry.link.Geometry.compute_uf" href="link.html#laueimproc.geometry.link.Geometry.compute_uf">Geometry.compute_uf()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def u_f(self) -&gt; None | torch.Tensor:
    &#34;&#34;&#34;Alias to ``laueimproc.geometry.link.Geometry.compute_uf``.&#34;&#34;&#34;
    try:
        return self.compute_uf()[0]
    except AttributeError:
        return None</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.Geometry.u_q"><code class="name">var <span class="ident">u_q</span> :Â NoneÂ |Â torch.Tensor</code></dt>
<dd>
<div class="desc"><p>Alias to <code><a title="laueimproc.geometry.link.Geometry.compute_uq" href="link.html#laueimproc.geometry.link.Geometry.compute_uq">Geometry.compute_uq()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def u_q(self) -&gt; None | torch.Tensor:
    &#34;&#34;&#34;Alias to ``laueimproc.geometry.link.Geometry.compute_uq``.&#34;&#34;&#34;
    try:
        return self.compute_uq()[0]
    except AttributeError:
        return None</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="laueimproc.geometry.Geometry.compute_cam"><code class="name flex">
<span>def <span class="ident">compute_cam</span></span>(<span>self, **kwargs) â€‘>Â tuple[torch.Tensor,Â torch.Tensor,Â torch.Tensor,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the position of the points on the camera.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The ravel points of shape (n, 2).</dd>
<dt><strong><code>energy</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The energy in J of each spot of shape (n,).</dd>
<dt><strong><code>hkl</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The full hkl list of shape (m, 3).</dd>
<dt><strong><code>unravel</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The int64 indice of each batch dimension of shape (n, o).
It means that the ith elements comme from the batch unravel[i].
The dimensions are the batch dimension of <code>self.reciprocal_bl + poni</code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import torch
&gt;&gt;&gt; from laueimproc.geometry.link import Geometry
&gt;&gt;&gt; e_max = 25e3 * 1.60e-19  # 25 keV
&gt;&gt;&gt; lattice = torch.tensor([3.6e-10, 3.6e-10, 3.6e-10, torch.pi/2, torch.pi/2, torch.pi/2])
&gt;&gt;&gt; poni = torch.tensor([0.07, 73.4e-3, 73.4e-3, 0.0, -torch.pi/2, 0.0])
&gt;&gt;&gt; phi = torch.zeros(3)
&gt;&gt;&gt; model = Geometry(e_max=e_max, lattice=lattice, phi=phi, poni=poni)
&gt;&gt;&gt; point, energy, hkl, _ = model.compute_cam()
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_cam(
    self, **kwargs
) -&gt; tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]:
    &#34;&#34;&#34;Get the position of the points on the camera.

    Returns
    -------
    point : torch.Tensor
        The ravel points of shape (n, 2).
    energy : torch.Tensor
        The energy in J of each spot of shape (n,).
    hkl : torch.Tensor
        The full hkl list of shape (m, 3).
    unravel : torch.Tensor
        The int64 indice of each batch dimension of shape (n, o).
        It means that the ith elements comme from the batch unravel[i].
        The dimensions are the batch dimension of ``self.reciprocal_bl + poni``.

    Examples
    --------
    &gt;&gt;&gt; import torch
    &gt;&gt;&gt; from laueimproc.geometry.link import Geometry
    &gt;&gt;&gt; e_max = 25e3 * 1.60e-19  # 25 keV
    &gt;&gt;&gt; lattice = torch.tensor([3.6e-10, 3.6e-10, 3.6e-10, torch.pi/2, torch.pi/2, torch.pi/2])
    &gt;&gt;&gt; poni = torch.tensor([0.07, 73.4e-3, 73.4e-3, 0.0, -torch.pi/2, 0.0])
    &gt;&gt;&gt; phi = torch.zeros(3)
    &gt;&gt;&gt; model = Geometry(e_max=e_max, lattice=lattice, phi=phi, poni=poni)
    &gt;&gt;&gt; point, energy, hkl, _ = model.compute_cam()
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    u_f, energy, hkl, unravel = self.compute_uf(**kwargs)  # (n,)
    if (poni := self._select_poni(kwargs)) is None:  # (...,)
        raise AttributeError(&#34;`poni` parameter has to be supplied&#34;)

    poni_b = poni.shape[:-1]
    point, dist = ray_to_detector(u_f, poni, cartesian_product=True)  # (n, ...)
    cond = dist &gt; 0  # (n, ...)
    if (cam_size := self._select_cam_size(kwargs)) is not None:
        cond &amp;= (
            (point[..., 0] &gt;= 0) &amp; (point[..., 1] &gt;= 0)
            &amp; (point[..., 0] &lt;= cam_size[0]) &amp; (point[..., 1] &lt;= cam_size[1])
        )
    energy = energy[:, *((None,)*len(poni_b))].expand(-1, *poni_b)  # (n, ...)
    hkl = hkl[:, *((None,)*len(poni_b)), :].expand(-1, *poni_b, -1)  # (n, ..., 3)

    point = point[cond]  # (n&#39;, 2)
    energy = energy[cond]  # (n&#39;,)
    hkl = hkl[cond]  # (n&#39;,)

    unravel = unravel[:, *((None,)*len(poni_b)), :].expand(-1, *poni_b, -1)  # (n, ..., o)
    unravel = unravel[cond]  # (n&#39;, o)
    if poni_b:
        indices = torch.meshgrid(  # (...,)
            *(torch.arange(b, device=unravel.device) for b in poni_b), indexing=&#34;ij&#34;
        )
        indices = [  # (n, ...)
            idx.unsqueeze(0).expand(len(u_f), *((-1,)*len(poni_b))) for idx in indices
        ]
        unravel_poni = torch.cat([idx[cond].unsqueeze(1) for idx in indices], dim=1)  # (n&#39;, p)
        unravel = torch.cat([unravel, unravel_poni], dim=1)  # (n&#39;, o+p)

    return point, energy, hkl, unravel</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.Geometry.compute_primitive_bc"><code class="name flex">
<span>def <span class="ident">compute_primitive_bc</span></span>(<span>self, **kwargs) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Get <span><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span> of shape (&hellip;, 3, 3) in the crystal base <span><span class="MathJax_Preview">\mathcal{B^c}</span><script type="math/tex">\mathcal{B^c}</script></span>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_primitive_bc(self, **kwargs) -&gt; torch.Tensor:
    r&#34;&#34;&#34;Get \(\mathbf{A}\) of shape (..., 3, 3) in the crystal base \(\mathcal{B^c}\).&#34;&#34;&#34;
    if (lattice := self._select_lattice(kwargs)) is None:
        raise AttributeError(&#34;`lattice` parameter has to be supplied&#34;)
    if lattice.requires_grad:
        return lattice_to_primitive(lattice)
    signature = (&#34;primitive_bc&#34;, lattice.data_ptr())
    if (primitive_bc := self._cache.get(signature, None)) is None:
        primitive_bc = self._cache[signature] = lattice_to_primitive(lattice)
    return primitive_bc</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.Geometry.compute_reciprocal_bc"><code class="name flex">
<span>def <span class="ident">compute_reciprocal_bc</span></span>(<span>self, **kwargs) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Get <span><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span> of shape (&hellip;, 3, 3) in the crystal base <span><span class="MathJax_Preview">\mathcal{B^c}</span><script type="math/tex">\mathcal{B^c}</script></span>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_reciprocal_bc(self, **kwargs) -&gt; torch.Tensor:
    r&#34;&#34;&#34;Get \(\mathbf{B}\) of shape (..., 3, 3) in the crystal base \(\mathcal{B^c}\).&#34;&#34;&#34;
    primitive_bc = self.compute_primitive_bc(**kwargs)
    if primitive_bc.requires_grad:
        return primitive_to_reciprocal(primitive_bc)
    signature = (&#34;reciprocal_bc&#34;, primitive_bc.data_ptr())
    if (reciprocal_bc := self._cache.get(signature, None)) is None:
        reciprocal_bc = self._cache[signature] = primitive_to_reciprocal(primitive_bc)
    return reciprocal_bc</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.Geometry.compute_reciprocal_bl"><code class="name flex">
<span>def <span class="ident">compute_reciprocal_bl</span></span>(<span>self, **kwargs) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Get <span><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span> of shape (&hellip;, 3, 3) in the lab base <span><span class="MathJax_Preview">\mathcal{B^l}</span><script type="math/tex">\mathcal{B^l}</script></span>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_reciprocal_bl(self, **kwargs) -&gt; torch.Tensor:
    r&#34;&#34;&#34;Get \(\mathbf{B}\) of shape (..., 3, 3) in the lab base \(\mathcal{B^l}\).&#34;&#34;&#34;
    reciprocal_bc = self.compute_reciprocal_bc(**kwargs)
    rot = self.compute_rot(**kwargs)
    if rot.requires_grad or reciprocal_bc.requires_grad:
        return rotate_crystal(reciprocal_bc, rot, cartesian_product=False)
    signature = (&#34;reciprocal_bl&#34;, reciprocal_bc.data_ptr(), rot.data_ptr())
    if (reciprocal_bl := self._cache.get(signature, None)) is None:
        reciprocal_bl = self._cache[signature] = (
            rotate_crystal(reciprocal_bc, rot, cartesian_product=False)
        )
    return reciprocal_bl</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.Geometry.compute_rot"><code class="name flex">
<span>def <span class="ident">compute_rot</span></span>(<span>self, **kwargs) â€‘>Â torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Get the rotation matrix of shape (&hellip;, 3, 3).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_rot(self, **kwargs) -&gt; torch.Tensor:
    &#34;&#34;&#34;Get the rotation matrix of shape (..., 3, 3).&#34;&#34;&#34;
    if (phi := self._select_phi(kwargs)) is None:
        raise AttributeError(&#34;`phi` parameter has to be supplied&#34;)
    if phi.requires_grad:
        return omega_to_rot(*phi.movedim(-1, 0), cartesian_product=False)
    signature = (&#34;rot&#34;, phi.data_ptr())
    if (rot := self._cache.get(signature, None)) is None:
        rot = self._cache[signature] = (
            omega_to_rot(*phi.movedim(-1, 0), cartesian_product=False)
        )
    return rot</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.Geometry.compute_uf"><code class="name flex">
<span>def <span class="ident">compute_uf</span></span>(<span>self, **kwargs) â€‘>Â tuple[torch.Tensor,Â torch.Tensor,Â torch.Tensor,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the <span><span class="MathJax_Preview">u_f</span><script type="math/tex">u_f</script></span> unitary vector in the lab base <span><span class="MathJax_Preview">\mathcal{B^l}</span><script type="math/tex">\mathcal{B^l}</script></span>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_uf(self, **kwargs) -&gt; tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]:
    r&#34;&#34;&#34;Get the \(u_f\) unitary vector in the lab base \(\mathcal{B^l}\).&#34;&#34;&#34;
    u_q, energy, hkl, unravel = self.compute_uq(**kwargs)
    if u_q.requires_grad:
        return uq_to_uf(u_q), energy, hkl, unravel
    signature = (&#34;uf&#34;, u_q.data_ptr())
    if (u_f := self._cache.get(signature, None)) is None:
        u_f = self._cache[signature] = uq_to_uf(u_q)
    return u_f, energy, hkl, unravel</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.Geometry.compute_uq"><code class="name flex">
<span>def <span class="ident">compute_uq</span></span>(<span>self, **kwargs) â€‘>Â tuple[torch.Tensor,Â torch.Tensor,Â torch.Tensor,Â torch.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the <span><span class="MathJax_Preview">u_q</span><script type="math/tex">u_q</script></span> unitary vector in the lab base <span><span class="MathJax_Preview">\mathcal{B^l}</span><script type="math/tex">\mathcal{B^l}</script></span>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>u_q</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The ravel <span><span class="MathJax_Preview">u_q</span><script type="math/tex">u_q</script></span> of shape (n, 3).</dd>
<dt><strong><code>energy</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The energy in J of each <span><span class="MathJax_Preview">u_q</span><script type="math/tex">u_q</script></span> of shape (n,).</dd>
<dt><strong><code>hkl</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The full hkl list of shape (n, 3).</dd>
<dt><strong><code>unravel</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The int64 indice of each batch dimension of shape (n, o).
It means that the ith elements comme from the batch unravel[i].
The dimensions are the batch dimension of <code>self.reciprocal_bl</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_uq(self, **kwargs) -&gt; tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]:
    r&#34;&#34;&#34;Get the \(u_q\) unitary vector in the lab base \(\mathcal{B^l}\).

    Returns
    -------
    u_q : torch.Tensor
        The ravel \(u_q\) of shape (n, 3).
    energy : torch.Tensor
        The energy in J of each \(u_q\) of shape (n,).
    hkl : torch.Tensor
        The full hkl list of shape (n, 3).
    unravel : torch.Tensor
        The int64 indice of each batch dimension of shape (n, o).
        It means that the ith elements comme from the batch unravel[i].
        The dimensions are the batch dimension of ``self.reciprocal_bl``.
    &#34;&#34;&#34;
    hkl = self._compute_candidate_hkl(**kwargs)  # (n, 3)
    reciprocal_bl = self.compute_reciprocal_bl(**kwargs)  # (..., 3, 3)
    e_min = self._select_hkl_args(kwargs).get(&#34;e_min&#34;, 0.0)

    def compute_uq_(hkl, reciprocal_bl, e_min):
        u_q, energy = hkl_reciprocal_to_uq_energy(hkl, reciprocal_bl, cartesian_product=True)
        cond = energy &gt;= e_min  # (m, ...)
        u_q, energy = u_q[cond], energy[cond]
        indices = torch.meshgrid(
            *(torch.arange(b, device=hkl.device) for b in cond.shape), indexing=&#34;ij&#34;
        )
        unravel = torch.cat([idx[cond].unsqueeze(1) for idx in indices], dim=1)
        hkl, unravel = hkl[unravel[:, 0]], unravel[:, 1:]
        return u_q, energy, hkl, unravel

    if reciprocal_bl.requires_grad:
        return compute_uq_(hkl, reciprocal_bl, e_min)
    signature = (&#34;uq&#34;, hkl.data_ptr(), reciprocal_bl.data_ptr(), e_min)
    if (res := self._cache.get(signature, None)) is None:
        res = self._cache[signature] = compute_uq_(hkl, reciprocal_bl, e_min)
    return res</code></pre>
</details>
</dd>
<dt id="laueimproc.geometry.Geometry.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self) â€‘>Â Callable[...,Â Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Fake method to solve abstract class initialisation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forward(self):
    &#34;&#34;&#34;Fake method to solve abstract class initialisation.&#34;&#34;&#34;
    raise NotImplementedError(&#34;the forward method has to be overwritten&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#bases">Bases</a></li>
<li><a href="#lattice-parameters">Lattice parameters</a></li>
<li><a href="#angles">Angles</a></li>
<li><a href="#diffraction">Diffraction</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="laueimproc" href="../index.html">laueimproc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="laueimproc.geometry.bragg" href="bragg.html">laueimproc.geometry.bragg</a></code></li>
<li><code><a title="laueimproc.geometry.hkl" href="hkl.html">laueimproc.geometry.hkl</a></code></li>
<li><code><a title="laueimproc.geometry.indexation" href="indexation/index.html">laueimproc.geometry.indexation</a></code></li>
<li><code><a title="laueimproc.geometry.lattice" href="lattice.html">laueimproc.geometry.lattice</a></code></li>
<li><code><a title="laueimproc.geometry.link" href="link.html">laueimproc.geometry.link</a></code></li>
<li><code><a title="laueimproc.geometry.metric" href="metric.html">laueimproc.geometry.metric</a></code></li>
<li><code><a title="laueimproc.geometry.projection" href="projection.html">laueimproc.geometry.projection</a></code></li>
<li><code><a title="laueimproc.geometry.reciprocal" href="reciprocal.html">laueimproc.geometry.reciprocal</a></code></li>
<li><code><a title="laueimproc.geometry.rotation" href="rotation.html">laueimproc.geometry.rotation</a></code></li>
<li><code><a title="laueimproc.geometry.symmetry" href="symmetry.html">laueimproc.geometry.symmetry</a></code></li>
<li><code><a title="laueimproc.geometry.thetachi" href="thetachi.html">laueimproc.geometry.thetachi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="laueimproc.geometry.compute_matching_rate" href="#laueimproc.geometry.compute_matching_rate">compute_matching_rate</a></code></li>
<li><code><a title="laueimproc.geometry.compute_matching_rate_continuous" href="#laueimproc.geometry.compute_matching_rate_continuous">compute_matching_rate_continuous</a></code></li>
<li><code><a title="laueimproc.geometry.detector_to_ray" href="#laueimproc.geometry.detector_to_ray">detector_to_ray</a></code></li>
<li><code><a title="laueimproc.geometry.hkl_reciprocal_to_energy" href="#laueimproc.geometry.hkl_reciprocal_to_energy">hkl_reciprocal_to_energy</a></code></li>
<li><code><a title="laueimproc.geometry.hkl_reciprocal_to_uq" href="#laueimproc.geometry.hkl_reciprocal_to_uq">hkl_reciprocal_to_uq</a></code></li>
<li><code><a title="laueimproc.geometry.hkl_reciprocal_to_uq_energy" href="#laueimproc.geometry.hkl_reciprocal_to_uq_energy">hkl_reciprocal_to_uq_energy</a></code></li>
<li><code><a title="laueimproc.geometry.lattice_to_primitive" href="#laueimproc.geometry.lattice_to_primitive">lattice_to_primitive</a></code></li>
<li><code><a title="laueimproc.geometry.omega_to_rot" href="#laueimproc.geometry.omega_to_rot">omega_to_rot</a></code></li>
<li><code><a title="laueimproc.geometry.primitive_to_lattice" href="#laueimproc.geometry.primitive_to_lattice">primitive_to_lattice</a></code></li>
<li><code><a title="laueimproc.geometry.primitive_to_reciprocal" href="#laueimproc.geometry.primitive_to_reciprocal">primitive_to_reciprocal</a></code></li>
<li><code><a title="laueimproc.geometry.ray_phi_dist" href="#laueimproc.geometry.ray_phi_dist">ray_phi_dist</a></code></li>
<li><code><a title="laueimproc.geometry.ray_to_detector" href="#laueimproc.geometry.ray_to_detector">ray_to_detector</a></code></li>
<li><code><a title="laueimproc.geometry.reciprocal_to_primitive" href="#laueimproc.geometry.reciprocal_to_primitive">reciprocal_to_primitive</a></code></li>
<li><code><a title="laueimproc.geometry.rot_to_omega" href="#laueimproc.geometry.rot_to_omega">rot_to_omega</a></code></li>
<li><code><a title="laueimproc.geometry.rotate_crystal" href="#laueimproc.geometry.rotate_crystal">rotate_crystal</a></code></li>
<li><code><a title="laueimproc.geometry.select_hkl" href="#laueimproc.geometry.select_hkl">select_hkl</a></code></li>
<li><code><a title="laueimproc.geometry.thetachi_to_uf" href="#laueimproc.geometry.thetachi_to_uf">thetachi_to_uf</a></code></li>
<li><code><a title="laueimproc.geometry.uf_to_thetachi" href="#laueimproc.geometry.uf_to_thetachi">uf_to_thetachi</a></code></li>
<li><code><a title="laueimproc.geometry.uf_to_uq" href="#laueimproc.geometry.uf_to_uq">uf_to_uq</a></code></li>
<li><code><a title="laueimproc.geometry.uq_to_uf" href="#laueimproc.geometry.uq_to_uf">uq_to_uf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="laueimproc.geometry.Geometry" href="#laueimproc.geometry.Geometry">Geometry</a></code></h4>
<ul class="">
<li><code><a title="laueimproc.geometry.Geometry.cam_size" href="#laueimproc.geometry.Geometry.cam_size">cam_size</a></code></li>
<li><code><a title="laueimproc.geometry.Geometry.compute_cam" href="#laueimproc.geometry.Geometry.compute_cam">compute_cam</a></code></li>
<li><code><a title="laueimproc.geometry.Geometry.compute_primitive_bc" href="#laueimproc.geometry.Geometry.compute_primitive_bc">compute_primitive_bc</a></code></li>
<li><code><a title="laueimproc.geometry.Geometry.compute_reciprocal_bc" href="#laueimproc.geometry.Geometry.compute_reciprocal_bc">compute_reciprocal_bc</a></code></li>
<li><code><a title="laueimproc.geometry.Geometry.compute_reciprocal_bl" href="#laueimproc.geometry.Geometry.compute_reciprocal_bl">compute_reciprocal_bl</a></code></li>
<li><code><a title="laueimproc.geometry.Geometry.compute_rot" href="#laueimproc.geometry.Geometry.compute_rot">compute_rot</a></code></li>
<li><code><a title="laueimproc.geometry.Geometry.compute_uf" href="#laueimproc.geometry.Geometry.compute_uf">compute_uf</a></code></li>
<li><code><a title="laueimproc.geometry.Geometry.compute_uq" href="#laueimproc.geometry.Geometry.compute_uq">compute_uq</a></code></li>
<li><code><a title="laueimproc.geometry.Geometry.e_max" href="#laueimproc.geometry.Geometry.e_max">e_max</a></code></li>
<li><code><a title="laueimproc.geometry.Geometry.e_min" href="#laueimproc.geometry.Geometry.e_min">e_min</a></code></li>
<li><code><a title="laueimproc.geometry.Geometry.forward" href="#laueimproc.geometry.Geometry.forward">forward</a></code></li>
<li><code><a title="laueimproc.geometry.Geometry.lattice" href="#laueimproc.geometry.Geometry.lattice">lattice</a></code></li>
<li><code><a title="laueimproc.geometry.Geometry.phi" href="#laueimproc.geometry.Geometry.phi">phi</a></code></li>
<li><code><a title="laueimproc.geometry.Geometry.poni" href="#laueimproc.geometry.Geometry.poni">poni</a></code></li>
<li><code><a title="laueimproc.geometry.Geometry.primitive_bc" href="#laueimproc.geometry.Geometry.primitive_bc">primitive_bc</a></code></li>
<li><code><a title="laueimproc.geometry.Geometry.reciprocal_bc" href="#laueimproc.geometry.Geometry.reciprocal_bc">reciprocal_bc</a></code></li>
<li><code><a title="laueimproc.geometry.Geometry.reciprocal_bl" href="#laueimproc.geometry.Geometry.reciprocal_bl">reciprocal_bl</a></code></li>
<li><code><a title="laueimproc.geometry.Geometry.rot" href="#laueimproc.geometry.Geometry.rot">rot</a></code></li>
<li><code><a title="laueimproc.geometry.Geometry.u_f" href="#laueimproc.geometry.Geometry.u_f">u_f</a></code></li>
<li><code><a title="laueimproc.geometry.Geometry.u_q" href="#laueimproc.geometry.Geometry.u_q">u_q</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>