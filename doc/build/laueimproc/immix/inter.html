<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>laueimproc.immix.inter API documentation</title>
<meta name="description" content="Compute an intermediate image of a batch of images." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>laueimproc.immix.inter</code></h1>
</header>
<section id="section-intro">
<p>Compute an intermediate image of a batch of images.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#34;&#34;&#34;Compute an intermediate image of a batch of images.&#34;&#34;&#34;

import math
import multiprocessing.pool
import numbers
import threading
import typing

from tqdm.autonotebook import tqdm
import torch

from laueimproc.classes.dataset import DiagramsDataset


class MomentumMixer:
    &#34;&#34;&#34;Compute an average momentum between the two closest candidates.

    Attributes
    ----------
    high : int
        The index max of the sorted stack.
    low : int
        The index min of the sorted stack.
    &#34;&#34;&#34;

    def __init__(self, nbr: int, level: float):
        &#34;&#34;&#34;Precompute the momentum.

        Parameters
        ----------
        nbr : int
            The number of items in the stack.
        level : float
            The relative position in the stack in [0, 1].

        Examples
        --------
        &gt;&gt;&gt; import torch
        &gt;&gt;&gt; from laueimproc.immix.inter import MomentumMixer
        &gt;&gt;&gt; mom = MomentumMixer(5, 0.5)
        &gt;&gt;&gt; mom(torch.arange(5)[mom.low], torch.arange(5)[mom.high])
        tensor(2.)
        &gt;&gt;&gt; mom = MomentumMixer(4, 0.5)
        &gt;&gt;&gt; mom(torch.arange(4)[mom.low], torch.arange(4)[mom.high])
        tensor(1.5000)
        &gt;&gt;&gt; mom = MomentumMixer(101, 0.1*torch.pi)
        &gt;&gt;&gt; mom(torch.arange(101)[mom.low], torch.arange(101)[mom.high])
        tensor(31.4159)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert isinstance(nbr, int), nbr.__class__.__name__
        assert nbr &gt;= 1, nbr
        assert isinstance(level, float), level.__class__.__name__
        assert 0.0 &lt;= level &lt;= 1.0, level

        if nbr == 1:
            self._low = self._high = 0
            self._momentum = 0.0

        interval = 1.0 / (nbr - 1)
        abs_level = level / interval
        self._low = math.floor(abs_level)
        self._low = max(0, min(nbr - 2, self._low))
        self._high = self._low + 1
        self._momentum = abs_level - self._low

    def __call__(self, val_min, val_max) -&gt; object:
        &#34;&#34;&#34;Combine the two elements.&#34;&#34;&#34;
        comb = val_min * (1.0 - self._momentum)
        comb += val_max * self._momentum
        return comb

    @property
    def high(self) -&gt; int:
        &#34;&#34;&#34;Return the index max of the sorted stack.&#34;&#34;&#34;
        return self._high

    @property
    def low(self) -&gt; int:
        &#34;&#34;&#34;Return the index min of the sorted stack.&#34;&#34;&#34;
        return self._low


def _best_idtype(nbr: int) -&gt; torch.dtype:
    if nbr &lt;= torch.iinfo(torch.int16).max:
        return torch.int16
    if nbr &lt;= torch.iinfo(torch.int32).max:
        return torch.int32
    return torch.int64


def _extrema_stack(dataset: DiagramsDataset, func: typing.Callable) -&gt; torch.Tensor:
    &#34;&#34;&#34;Find the min filter of a stack of images.&#34;&#34;&#34;
    indices = dataset.indices
    img = None
    with multiprocessing.pool.ThreadPool() as pool:
        for loc_img in tqdm(
            pool.imap_unordered(lambda i: dataset[i].image, indices),
            total=len(indices),
            unit=&#34;img&#34;,
            desc=&#34;mean image&#34;,
        ):
            if img is None:
                img = loc_img.clone()
            else:
                assert img.shape == loc_img.shape, \
                    f&#34;all images have be of same shape ({img.shape} vs {loc_img.shape})&#34;
            img = func(img, loc_img, out=img)
    return img


def _snowflake_stack(diagram, hist, b_min, res, lock):
    image = diagram.image.ravel()
    idx = 1 + ((image - b_min) / res).to(torch.int64)  # floor
    idx = torch.clamp(idx, 0, hist.shape[1] - 1, out=idx)
    with lock:
        hist[hist.range, idx] += 1


def snowflake_stack(
    dataset: DiagramsDataset, level: numbers.Real = 0.5, tol: numbers.Real = 1.526e-5
) -&gt; torch.Tensor:
    &#34;&#34;&#34;Compute the median, first quartile, third quartile or everything in between.

    This algorithm consists of computing the histogram of all the images into a heap of size n.
    Then compute the cumulative histogram to deduce in each slice the value is. To bound the result.
    Iterate the processus to refine the bounds until reaching the required accuracy.

    Parameters
    ----------
    dataset : laueimproc.classes.dataset.DiagramsDataset
        The dataset containing all images.
    level : float, default=0.5
        The level of the sorted stack.

        * 0 -&gt; min filter
        * 0.25 -&gt; first quartile
        * 0.5 (default) -&gt; median
        * 0.75 -&gt; third quartile
        * 1 -&gt; max filter
    tol : float, default=1/(2**16-1)
        Accuracy of the estimated returned image.

    Returns
    -------
    torch.Tensor
        The 2d float32 grayscale image.

    Notes
    -----
    Unlike the native algorithm, images are read a number of times proportional
    to the logarithm of the inverse of the precision.
    Independent of the number of images in the dataset.
    This algorithm is therefore better suited to large datasets.
    &#34;&#34;&#34;
    assert isinstance(dataset, DiagramsDataset), dataset.__class__.__name__
    assert len(dataset) &gt; 0, &#34;impossible to compute the inter image of an empty dataset&#34;
    assert isinstance(level, numbers.Real), level.__class__.__name__
    assert 0 &lt;= level &lt;= 1, level

    if float(level) in {0.0, 1.0}:
        return _extrema_stack(dataset, {0.0: torch.minimum, 1.0: torch.maximum}[float(level)])

    # initialization
    indices = dataset.indices
    height, width = dataset[indices[0]].image.shape
    hist = torch.empty(
        height * width,
        max(4, 100_000_000 // (_best_idtype(len(indices)).itemsize * height * width)),  # 100 Mo
        dtype=_best_idtype(len(indices)),
    )
    hist.range = torch.arange(len(hist), dtype=torch.int64, device=hist.device)
    b_min, b_max = torch.full((height * width,), 0.0), torch.full((height * width,), 1.0)
    res = 1.0 / (hist.shape[1] - 2)
    mux = MomentumMixer(len(indices), float(level))
    lock = threading.Lock()

    # main
    for _ in tqdm(
        range(max(0, math.ceil(-math.log(tol) / math.log(hist.shape[1] - 2)) - 1)),
        desc=&#34;inter image&#34;, unit=&#34;loop&#34;,
    ):
        hist[...] = 0
        res = (b_max - b_min) / (hist.shape[1] - 2)
        with multiprocessing.pool.ThreadPool() as pool:
            for _ in tqdm(
                pool.starmap(
                    _snowflake_stack,
                    ((dataset[i], hist, b_min, res, lock) for i in indices),
                ),
                total=len(indices),
                unit=&#34;img&#34;,
                leave=False,
                position=1,
            ):
                pass
        hist = torch.cumsum(hist, dim=1, out=hist)
        b_min_int = torch.argmax((hist &gt;= mux.low + 1).view(torch.uint8), dim=1)
        # b_max_int = torch.argmax((hist &gt;= mux.high + 1).view(torch.uint8), dim=1)
        b_max_int = b_min_int
        b_max = b_max_int.to(res.dtype) * res + b_min
        b_min += (b_min_int - 1).to(res.dtype) * res

    res *= 0.5
    return mux(b_min + res, b_max - res).reshape(height, width)


def sort_stack(dataset: DiagramsDataset, level: numbers.Real = 0.5) -&gt; torch.Tensor:
    &#34;&#34;&#34;Compute the median, first quartile, third quartile or everything in between.

    This algorithm consists of stacking all the images into a heap of size n.
    Then sort each column in the stack (as many columns as there are pixels in the image).
    Finally, we return the image in the new stack at height n * `level`.

    Parameters
    ----------
    dataset : laueimproc.classes.dataset.DiagramsDataset
        The dataset containing all images.
    level : float, default=0.5
        The level of the sorted stack.

        * 0 -&gt; min filter
        * 0.25 -&gt; first quartile
        * 0.5 (default) -&gt; median
        * 0.75 -&gt; third quartile
        * 1 -&gt; max filter

    Returns
    -------
    torch.Tensor
        The 2d float32 grayscale image.

    Notes
    -----
    For reasons of memory limitations, the final image is calculated in small chunks.
    As a result, each image on the hard disk is read n times,
    with n proportional to the number of diagrams in the dataset.
    &#34;&#34;&#34;
    assert isinstance(dataset, DiagramsDataset), dataset.__class__.__name__
    assert len(dataset) &gt; 0, &#34;impossible to compute the inter image of an empty dataset&#34;
    assert isinstance(level, numbers.Real), level.__class__.__name__
    assert 0 &lt;= level &lt;= 1, level

    if float(level) in {0.0, 1.0}:
        return _extrema_stack(dataset, {0.0: torch.minimum, 1.0: torch.maximum}[float(level)])

    # initialization
    indices = dataset.indices
    height, width = dataset[indices[0]].image.shape
    buff_size = max(1, 100_000_000 // (torch.float32.itemsize * len(dataset)))  # 100 Mo
    out = torch.empty(height * width, dtype=torch.float32)
    mux = MomentumMixer(len(indices), float(level))

    def _select(diagram_start_end):
        diagram, start, end = diagram_start_end
        # .clone() allows gc to collect source image
        return diagram.image.ravel()[None, start:end].clone()

    # main
    for start in tqdm(range(0, height * width, buff_size), desc=&#34;inter image&#34;, unit=&#34;batch&#34;):
        end = min(height * width, start + buff_size)
        with multiprocessing.pool.ThreadPool() as pool:
            batch = torch.cat(
                list(
                    tqdm(
                        pool.imap_unordered(
                            _select, ((dataset[i], start, end) for i in indices)
                        ),
                        total=len(indices),
                        unit=&#34;img&#34;,
                        leave=False,
                        position=1,
                    )
                )
            )
        batch = torch.sort(batch, dim=0).values
        out[start:end] = mux(batch[mux.low, :], batch[mux.high, :])
    return out.reshape(height, width)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="laueimproc.immix.inter.snowflake_stack"><code class="name flex">
<span>def <span class="ident">snowflake_stack</span></span>(<span>dataset: <a title="laueimproc.classes.dataset.DiagramsDataset" href="../classes/dataset.html#laueimproc.classes.dataset.DiagramsDataset">DiagramsDataset</a>, level: numbers.Real = 0.5, tol: numbers.Real = 1.526e-05) ‑> torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the median, first quartile, third quartile or everything in between.</p>
<p>This algorithm consists of computing the histogram of all the images into a heap of size n.
Then compute the cumulative histogram to deduce in each slice the value is. To bound the result.
Iterate the processus to refine the bounds until reaching the required accuracy.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dataset</code></strong> :&ensp;<code><a title="laueimproc.classes.dataset.DiagramsDataset" href="../classes/dataset.html#laueimproc.classes.dataset.DiagramsDataset">DiagramsDataset</a></code></dt>
<dd>The dataset containing all images.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>float</code>, default=<code>0.5</code></dt>
<dd>
<p>The level of the sorted stack.</p>
<ul>
<li>0 -&gt; min filter</li>
<li>0.25 -&gt; first quartile</li>
<li>0.5 (default) -&gt; median</li>
<li>0.75 -&gt; third quartile</li>
<li>1 -&gt; max filter</li>
</ul>
</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code>, default=<code>1/(2**16-1)</code></dt>
<dd>Accuracy of the estimated returned image.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>torch.Tensor</code></dt>
<dd>The 2d float32 grayscale image.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Unlike the native algorithm, images are read a number of times proportional
to the logarithm of the inverse of the precision.
Independent of the number of images in the dataset.
This algorithm is therefore better suited to large datasets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def snowflake_stack(
    dataset: DiagramsDataset, level: numbers.Real = 0.5, tol: numbers.Real = 1.526e-5
) -&gt; torch.Tensor:
    &#34;&#34;&#34;Compute the median, first quartile, third quartile or everything in between.

    This algorithm consists of computing the histogram of all the images into a heap of size n.
    Then compute the cumulative histogram to deduce in each slice the value is. To bound the result.
    Iterate the processus to refine the bounds until reaching the required accuracy.

    Parameters
    ----------
    dataset : laueimproc.classes.dataset.DiagramsDataset
        The dataset containing all images.
    level : float, default=0.5
        The level of the sorted stack.

        * 0 -&gt; min filter
        * 0.25 -&gt; first quartile
        * 0.5 (default) -&gt; median
        * 0.75 -&gt; third quartile
        * 1 -&gt; max filter
    tol : float, default=1/(2**16-1)
        Accuracy of the estimated returned image.

    Returns
    -------
    torch.Tensor
        The 2d float32 grayscale image.

    Notes
    -----
    Unlike the native algorithm, images are read a number of times proportional
    to the logarithm of the inverse of the precision.
    Independent of the number of images in the dataset.
    This algorithm is therefore better suited to large datasets.
    &#34;&#34;&#34;
    assert isinstance(dataset, DiagramsDataset), dataset.__class__.__name__
    assert len(dataset) &gt; 0, &#34;impossible to compute the inter image of an empty dataset&#34;
    assert isinstance(level, numbers.Real), level.__class__.__name__
    assert 0 &lt;= level &lt;= 1, level

    if float(level) in {0.0, 1.0}:
        return _extrema_stack(dataset, {0.0: torch.minimum, 1.0: torch.maximum}[float(level)])

    # initialization
    indices = dataset.indices
    height, width = dataset[indices[0]].image.shape
    hist = torch.empty(
        height * width,
        max(4, 100_000_000 // (_best_idtype(len(indices)).itemsize * height * width)),  # 100 Mo
        dtype=_best_idtype(len(indices)),
    )
    hist.range = torch.arange(len(hist), dtype=torch.int64, device=hist.device)
    b_min, b_max = torch.full((height * width,), 0.0), torch.full((height * width,), 1.0)
    res = 1.0 / (hist.shape[1] - 2)
    mux = MomentumMixer(len(indices), float(level))
    lock = threading.Lock()

    # main
    for _ in tqdm(
        range(max(0, math.ceil(-math.log(tol) / math.log(hist.shape[1] - 2)) - 1)),
        desc=&#34;inter image&#34;, unit=&#34;loop&#34;,
    ):
        hist[...] = 0
        res = (b_max - b_min) / (hist.shape[1] - 2)
        with multiprocessing.pool.ThreadPool() as pool:
            for _ in tqdm(
                pool.starmap(
                    _snowflake_stack,
                    ((dataset[i], hist, b_min, res, lock) for i in indices),
                ),
                total=len(indices),
                unit=&#34;img&#34;,
                leave=False,
                position=1,
            ):
                pass
        hist = torch.cumsum(hist, dim=1, out=hist)
        b_min_int = torch.argmax((hist &gt;= mux.low + 1).view(torch.uint8), dim=1)
        # b_max_int = torch.argmax((hist &gt;= mux.high + 1).view(torch.uint8), dim=1)
        b_max_int = b_min_int
        b_max = b_max_int.to(res.dtype) * res + b_min
        b_min += (b_min_int - 1).to(res.dtype) * res

    res *= 0.5
    return mux(b_min + res, b_max - res).reshape(height, width)</code></pre>
</details>
</dd>
<dt id="laueimproc.immix.inter.sort_stack"><code class="name flex">
<span>def <span class="ident">sort_stack</span></span>(<span>dataset: <a title="laueimproc.classes.dataset.DiagramsDataset" href="../classes/dataset.html#laueimproc.classes.dataset.DiagramsDataset">DiagramsDataset</a>, level: numbers.Real = 0.5) ‑> torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the median, first quartile, third quartile or everything in between.</p>
<p>This algorithm consists of stacking all the images into a heap of size n.
Then sort each column in the stack (as many columns as there are pixels in the image).
Finally, we return the image in the new stack at height n * <code>level</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dataset</code></strong> :&ensp;<code><a title="laueimproc.classes.dataset.DiagramsDataset" href="../classes/dataset.html#laueimproc.classes.dataset.DiagramsDataset">DiagramsDataset</a></code></dt>
<dd>The dataset containing all images.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>float</code>, default=<code>0.5</code></dt>
<dd>
<p>The level of the sorted stack.</p>
<ul>
<li>0 -&gt; min filter</li>
<li>0.25 -&gt; first quartile</li>
<li>0.5 (default) -&gt; median</li>
<li>0.75 -&gt; third quartile</li>
<li>1 -&gt; max filter</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>torch.Tensor</code></dt>
<dd>The 2d float32 grayscale image.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>For reasons of memory limitations, the final image is calculated in small chunks.
As a result, each image on the hard disk is read n times,
with n proportional to the number of diagrams in the dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_stack(dataset: DiagramsDataset, level: numbers.Real = 0.5) -&gt; torch.Tensor:
    &#34;&#34;&#34;Compute the median, first quartile, third quartile or everything in between.

    This algorithm consists of stacking all the images into a heap of size n.
    Then sort each column in the stack (as many columns as there are pixels in the image).
    Finally, we return the image in the new stack at height n * `level`.

    Parameters
    ----------
    dataset : laueimproc.classes.dataset.DiagramsDataset
        The dataset containing all images.
    level : float, default=0.5
        The level of the sorted stack.

        * 0 -&gt; min filter
        * 0.25 -&gt; first quartile
        * 0.5 (default) -&gt; median
        * 0.75 -&gt; third quartile
        * 1 -&gt; max filter

    Returns
    -------
    torch.Tensor
        The 2d float32 grayscale image.

    Notes
    -----
    For reasons of memory limitations, the final image is calculated in small chunks.
    As a result, each image on the hard disk is read n times,
    with n proportional to the number of diagrams in the dataset.
    &#34;&#34;&#34;
    assert isinstance(dataset, DiagramsDataset), dataset.__class__.__name__
    assert len(dataset) &gt; 0, &#34;impossible to compute the inter image of an empty dataset&#34;
    assert isinstance(level, numbers.Real), level.__class__.__name__
    assert 0 &lt;= level &lt;= 1, level

    if float(level) in {0.0, 1.0}:
        return _extrema_stack(dataset, {0.0: torch.minimum, 1.0: torch.maximum}[float(level)])

    # initialization
    indices = dataset.indices
    height, width = dataset[indices[0]].image.shape
    buff_size = max(1, 100_000_000 // (torch.float32.itemsize * len(dataset)))  # 100 Mo
    out = torch.empty(height * width, dtype=torch.float32)
    mux = MomentumMixer(len(indices), float(level))

    def _select(diagram_start_end):
        diagram, start, end = diagram_start_end
        # .clone() allows gc to collect source image
        return diagram.image.ravel()[None, start:end].clone()

    # main
    for start in tqdm(range(0, height * width, buff_size), desc=&#34;inter image&#34;, unit=&#34;batch&#34;):
        end = min(height * width, start + buff_size)
        with multiprocessing.pool.ThreadPool() as pool:
            batch = torch.cat(
                list(
                    tqdm(
                        pool.imap_unordered(
                            _select, ((dataset[i], start, end) for i in indices)
                        ),
                        total=len(indices),
                        unit=&#34;img&#34;,
                        leave=False,
                        position=1,
                    )
                )
            )
        batch = torch.sort(batch, dim=0).values
        out[start:end] = mux(batch[mux.low, :], batch[mux.high, :])
    return out.reshape(height, width)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="laueimproc.immix.inter.MomentumMixer"><code class="flex name class">
<span>class <span class="ident">MomentumMixer</span></span>
<span>(</span><span>nbr: int, level: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute an average momentum between the two closest candidates.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>high</code></strong> :&ensp;<code>int</code></dt>
<dd>The index max of the sorted stack.</dd>
<dt><strong><code>low</code></strong> :&ensp;<code>int</code></dt>
<dd>The index min of the sorted stack.</dd>
</dl>
<p>Precompute the momentum.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nbr</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of items in the stack.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>float</code></dt>
<dd>The relative position in the stack in [0, 1].</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import torch
&gt;&gt;&gt; from laueimproc.immix.inter import MomentumMixer
&gt;&gt;&gt; mom = MomentumMixer(5, 0.5)
&gt;&gt;&gt; mom(torch.arange(5)[mom.low], torch.arange(5)[mom.high])
tensor(2.)
&gt;&gt;&gt; mom = MomentumMixer(4, 0.5)
&gt;&gt;&gt; mom(torch.arange(4)[mom.low], torch.arange(4)[mom.high])
tensor(1.5000)
&gt;&gt;&gt; mom = MomentumMixer(101, 0.1*torch.pi)
&gt;&gt;&gt; mom(torch.arange(101)[mom.low], torch.arange(101)[mom.high])
tensor(31.4159)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MomentumMixer:
    &#34;&#34;&#34;Compute an average momentum between the two closest candidates.

    Attributes
    ----------
    high : int
        The index max of the sorted stack.
    low : int
        The index min of the sorted stack.
    &#34;&#34;&#34;

    def __init__(self, nbr: int, level: float):
        &#34;&#34;&#34;Precompute the momentum.

        Parameters
        ----------
        nbr : int
            The number of items in the stack.
        level : float
            The relative position in the stack in [0, 1].

        Examples
        --------
        &gt;&gt;&gt; import torch
        &gt;&gt;&gt; from laueimproc.immix.inter import MomentumMixer
        &gt;&gt;&gt; mom = MomentumMixer(5, 0.5)
        &gt;&gt;&gt; mom(torch.arange(5)[mom.low], torch.arange(5)[mom.high])
        tensor(2.)
        &gt;&gt;&gt; mom = MomentumMixer(4, 0.5)
        &gt;&gt;&gt; mom(torch.arange(4)[mom.low], torch.arange(4)[mom.high])
        tensor(1.5000)
        &gt;&gt;&gt; mom = MomentumMixer(101, 0.1*torch.pi)
        &gt;&gt;&gt; mom(torch.arange(101)[mom.low], torch.arange(101)[mom.high])
        tensor(31.4159)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert isinstance(nbr, int), nbr.__class__.__name__
        assert nbr &gt;= 1, nbr
        assert isinstance(level, float), level.__class__.__name__
        assert 0.0 &lt;= level &lt;= 1.0, level

        if nbr == 1:
            self._low = self._high = 0
            self._momentum = 0.0

        interval = 1.0 / (nbr - 1)
        abs_level = level / interval
        self._low = math.floor(abs_level)
        self._low = max(0, min(nbr - 2, self._low))
        self._high = self._low + 1
        self._momentum = abs_level - self._low

    def __call__(self, val_min, val_max) -&gt; object:
        &#34;&#34;&#34;Combine the two elements.&#34;&#34;&#34;
        comb = val_min * (1.0 - self._momentum)
        comb += val_max * self._momentum
        return comb

    @property
    def high(self) -&gt; int:
        &#34;&#34;&#34;Return the index max of the sorted stack.&#34;&#34;&#34;
        return self._high

    @property
    def low(self) -&gt; int:
        &#34;&#34;&#34;Return the index min of the sorted stack.&#34;&#34;&#34;
        return self._low</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="laueimproc.immix.inter.MomentumMixer.high"><code class="name">var <span class="ident">high</span> : int</code></dt>
<dd>
<div class="desc"><p>Return the index max of the sorted stack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def high(self) -&gt; int:
    &#34;&#34;&#34;Return the index max of the sorted stack.&#34;&#34;&#34;
    return self._high</code></pre>
</details>
</dd>
<dt id="laueimproc.immix.inter.MomentumMixer.low"><code class="name">var <span class="ident">low</span> : int</code></dt>
<dd>
<div class="desc"><p>Return the index min of the sorted stack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def low(self) -&gt; int:
    &#34;&#34;&#34;Return the index min of the sorted stack.&#34;&#34;&#34;
    return self._low</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="laueimproc.immix" href="index.html">laueimproc.immix</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="laueimproc.immix.inter.snowflake_stack" href="#laueimproc.immix.inter.snowflake_stack">snowflake_stack</a></code></li>
<li><code><a title="laueimproc.immix.inter.sort_stack" href="#laueimproc.immix.inter.sort_stack">sort_stack</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="laueimproc.immix.inter.MomentumMixer" href="#laueimproc.immix.inter.MomentumMixer">MomentumMixer</a></code></h4>
<ul class="">
<li><code><a title="laueimproc.immix.inter.MomentumMixer.high" href="#laueimproc.immix.inter.MomentumMixer.high">high</a></code></li>
<li><code><a title="laueimproc.immix.inter.MomentumMixer.low" href="#laueimproc.immix.inter.MomentumMixer.low">low</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>