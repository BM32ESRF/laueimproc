<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>laueimproc.classes API documentation</title>
<meta name="description" content="Defines the data structure used throughout the rest of the module." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>laueimproc.classes</code></h1>
</header>
<section id="section-intro">
<p>Defines the data structure used throughout the rest of the module.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#34;&#34;&#34;Defines the data structure used throughout the rest of the module.&#34;&#34;&#34;

from .dataset import DiagramsDataset
from .diagram import Diagram

__all__ = [&#34;Diagram&#34;, &#34;DiagramsDataset&#34;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="laueimproc.classes.base_diagram" href="base_diagram.html">laueimproc.classes.base_diagram</a></code></dt>
<dd>
<div class="desc"><p>Define the pytonic structure of a basic Diagram.</p></div>
</dd>
<dt><code class="name"><a title="laueimproc.classes.dataset" href="dataset.html">laueimproc.classes.dataset</a></code></dt>
<dd>
<div class="desc"><p>Link serveral diagrams together.</p></div>
</dd>
<dt><code class="name"><a title="laueimproc.classes.diagram" href="diagram.html">laueimproc.classes.diagram</a></code></dt>
<dd>
<div class="desc"><p>Define the data sructure of a single Laue diagram image.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="laueimproc.classes.Diagram"><code class="flex name class">
<span>class <span class="ident">Diagram</span></span>
<span>(</span><span>data: Union[numpy.ndarray, torch.Tensor, str, pathlib.Path])</span>
</code></dt>
<dd>
<div class="desc"><p>A Laue diagram image.</p>
<p>Create a new diagram with appropriated metadata.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pathlike</code> or <code>arraylike</code></dt>
<dd>The filename or the array/tensor use as a diagram.
For memory management, it is better to provide a pathlike rather than an array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Diagram(BaseDiagram):
    &#34;&#34;&#34;A Laue diagram image.&#34;&#34;&#34;

    @auto_cache  # put the result in thread safe cache (no multiprocessing)
    @check_init  # throws an exception if the diagram is not initialized
    @ij_to_xy_decorator(i=(slice(None), 0), j=(slice(None), 1))
    def compute_rois_centroid(self, **_kwargs) -&gt; torch.Tensor:
        &#34;&#34;&#34;Compute the barycenter of each spots.

        Returns
        -------
        positions : torch.Tensor
            The 2 barycenter position for each roi.
            Each line corresponds to a spot and each column to an axis (shape (n, 2)).
            See ``laueimproc.improc.spot.basic.compute_rois_centroid`` for more details.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = Diagram(get_sample())
        &gt;&gt;&gt; diagram.find_spots()
        &gt;&gt;&gt; print(diagram.compute_rois_centroid())  # doctset: +ELLIPSIS
        tensor([[4.2637e+00, 5.0494e+00],
                [7.2805e-01, 2.6091e+01],
                [5.1465e-01, 1.9546e+03],
                ...,
                [1.9119e+03, 1.8759e+02],
                [1.9376e+03, 1.9745e+03],
                [1.9756e+03, 1.1794e+03]])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        from laueimproc.improc.spot.basic import compute_rois_centroid
        with self._rois_lock:
            data, bboxes = self._rois
        return compute_rois_centroid(data, bboxes, **_kwargs)

    @auto_cache
    @check_init
    @ij_to_xy_decorator(i=(slice(None), 1), j=(slice(None), 2))
    def compute_rois_max(self, **_kwargs) -&gt; torch.Tensor:
        &#34;&#34;&#34;Get the intensity and the position of the hottest pixel for each roi.

        Returns
        -------
        imax_pos1_pos2 : torch.Tensor
            The concatenation of the colum vectors of the argmax and the intensity (shape (n, 3)).
            See ``laueimproc.improc.spot.basic.compute_rois_max`` for more details.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = Diagram(get_sample())
        &gt;&gt;&gt; diagram.find_spots()
        &gt;&gt;&gt; print(diagram.compute_rois_max())  # doctset: +ELLIPSIS
        tensor([[2.5000e+00, 5.5000e+00, 9.2165e-03],
                [5.0000e-01, 2.2500e+01, 1.3581e-03],
                [5.0000e-01, 1.9545e+03, 1.3123e-02],
                ...,
                [1.9125e+03, 1.8750e+02, 1.1250e-01],
                [1.9375e+03, 1.9745e+03, 6.0273e-02],
                [1.9755e+03, 1.1795e+03, 2.9212e-01]])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        from laueimproc.improc.spot.basic import compute_rois_max
        with self._rois_lock:
            data, bboxes = self._rois
        return compute_rois_max(data, bboxes, **_kwargs)

    @auto_cache
    @check_init
    def compute_rois_nb_peaks(self, **_kwargs) -&gt; torch.Tensor:
        &#34;&#34;&#34;Find the number of extremums in each roi.

        Returns
        -------
        nbr_of_peaks : torch.Tensor
            The number of extremums (shape (n,)).
            See ``laueimproc.improc.spot.extrema.compute_rois_nb_peaks`` for more details.

        Notes
        -----
        No noise filtering. Doesn&#39;t detect shoulders.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = Diagram(get_sample())
        &gt;&gt;&gt; diagram.find_spots()
        &gt;&gt;&gt; print(diagram.compute_rois_nb_peaks())
        tensor([23,  4,  3,  2,  6,  3,  1,  3,  1,  4,  1,  2,  3,  1,  1,  3,  3,  3,
                 2,  7,  4,  1,  1,  3,  3,  2,  4,  2,  1,  2,  1,  2,  2,  2,  2,  2,
                 6,  2,  1,  2,  4,  2,  3,  4,  1,  1,  4,  3,  1,  4,  4,  5,  3,  3,
                 1,  5,  3,  2,  6,  1,  2,  3,  1,  4,  6,  3,  6,  2,  2,  5,  7,  5,
                 3,  2,  3,  1,  2,  6,  8,  2,  3,  3,  3,  3,  2,  4,  2,  1,  1,  4,
                 4,  1,  4,  2,  5,  4,  3,  3,  1,  2,  1,  3,  4,  2,  5,  5,  7,  2,
                 6,  3,  5,  2,  2,  2,  7,  2,  3,  5,  3,  1,  4,  8,  3,  3,  4,  3,
                 4,  2,  5,  1,  7,  3,  5,  4, 10,  2,  3,  3,  4,  3,  5,  8,  2,  5,
                 8,  3,  2,  3,  5,  5,  5,  3,  4,  6,  2,  4,  1,  3,  4,  2,  3,  4,
                 5,  5,  2,  4,  6,  4,  4,  1,  2,  4,  4,  3, 13, 13,  3,  6,  3,  2,
                 1,  4,  6,  3,  2,  2, 16,  3,  1,  2,  2,  4,  1,  3,  7,  4,  1,  5,
                 4,  7,  5,  1,  6,  6,  2,  4,  3,  9,  3,  2,  3,  2,  8,  5,  3,  3,
                 3,  3, 10,  9,  2,  2,  5,  4,  3,  3,  2,  1,  3,  6, 11,  2,  4,  4,
                 6,  2,  7,  5,  2, 10], dtype=torch.int16)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        from laueimproc.improc.spot.extrema import compute_rois_nb_peaks
        with self._rois_lock:
            data, bboxes = self._rois
        return compute_rois_nb_peaks(data, bboxes, **_kwargs)

    @auto_cache
    @check_init
    def compute_rois_pca(self, **_kwargs) -&gt; torch.Tensor:
        &#34;&#34;&#34;Compute the pca on each spot.

        Returns
        -------
        std1_std2_theta : torch.Tensor
            The concatenation of the colum vectors of the two std and the angle (shape (n, 3)).
            See ``laueimproc.improc.spot.pca.compute_rois_pca`` for more details.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = Diagram(get_sample())
        &gt;&gt;&gt; diagram.find_spots()
        &gt;&gt;&gt; print(diagram.compute_rois_pca())  # doctset: +ELLIPSIS
        tensor([[ 0.4340,  0.2615, -0.8608],
                [ 0.7120,  0.0774, -1.5626],
                [ 0.4909,  0.0085, -1.5700],
                ...,
                [ 0.1986,  0.1379, -0.6384],
                [ 0.1980,  0.1390,  0.6738],
                [ 0.1658,  0.1444,  0.5321]])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        from laueimproc.improc.spot.pca import compute_rois_pca
        with self._rois_lock:
            data, bboxes = self._rois
        return compute_rois_pca(data, bboxes, **_kwargs)

    @auto_cache
    @check_init
    def compute_rois_sum(self, **_kwargs) -&gt; torch.Tensor:
        &#34;&#34;&#34;Sum the intensities of the pixels for each roi.

        Returns
        -------
        total_intensity : torch.Tensor
            The intensity of each roi, sum of the pixels (shape (n,)).
            See ``laueimproc.improc.spot.basic.compute_rois_sum`` for more details.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = Diagram(get_sample())
        &gt;&gt;&gt; diagram.find_spots()
        &gt;&gt;&gt; print(diagram.compute_rois_sum())  # doctset: +ELLIPSIS
        tensor([2.1886e-01, 1.1643e-02, 5.6260e-02, 1.6938e-03, 9.8726e-03, 6.1647e-02,
                3.5279e-02, 3.1891e-03, 1.0071e-02, 2.2889e-03, 1.0285e-02, 1.9760e-01,
                1.7258e-02, 3.3402e-02, 9.1829e-02, 3.1510e-02, 8.4550e-02, 4.0864e-02,
                ...,
                9.2822e-01, 9.7104e-01, 4.1733e-02, 9.4377e-02, 5.2491e-03, 4.2115e-03,
                3.9217e-01, 1.5907e+00, 1.1802e+00, 1.4968e-01, 4.0696e-01, 6.3442e-01,
                1.3559e+00, 6.0548e-01, 1.7116e+00, 9.2990e-01, 4.9596e-01, 2.0383e+00])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        from laueimproc.improc.spot.basic import compute_rois_sum
        with self._rois_lock:
            data, bboxes = self._rois
        return compute_rois_sum(data, bboxes, **_kwargs)

    def fit_gaussian_em(self, *args, **kwargs) -&gt; tuple[torch.Tensor, torch.Tensor, dict]:
        r&#34;&#34;&#34;Fit each roi by one gaussian using the EM algorithm in one shot, very fast.

        Same as ``flaueimproc.classes.diagram.fit_gaussians_em`` but squeeze the \(K = 1\) dim.

        Parameters
        ----------
        *args : tuple
            Transmitted to ``laueimproc.classes.diagram.fit_gaussians_em``.
        **kwargs : dict
            Transmitted to ``laueimproc.classes.diagram.fit_gaussians_em``.

        Returns
        -------
        mean : torch.Tensor
            The vectors \(\mathbf{\mu}\). Shape (n, 2). In the absolute diagram base.
        cov : torch.Tensor
            The matrices \(\mathbf{\Sigma}\). Shape (n, 2, 2).
        infodict : dict[str]
            Comes from ``laueimproc.improc.spot.fit.fit_gaussian_em``.
        &#34;&#34;&#34;
        assert &#34;nbr_clusters&#34; not in kwargs, &#34;use fit_gaussianSSS_em instead&#34;
        mean, cov, _, infodict = self.fit_gaussians_em(*args, **kwargs, nbr_clusters=1)
        mean, cov = mean.squeeze(1), cov.squeeze(1)
        if &#34;eigtheta&#34; in infodict:
            infodict[&#34;eigtheta&#34;] = infodict[&#34;eigtheta&#34;].squeeze(1)
        return mean, cov, infodict

    @auto_cache
    @check_init
    def fit_gaussians_em(
        self,
        photon_density: typing.Union[torch.Tensor, np.ndarray, numbers.Real] = 1.0,
        indexing: str = &#34;ij&#34;,
        **kwargs,
    ) -&gt; tuple[torch.Tensor, torch.Tensor, dict]:
        r&#34;&#34;&#34;Fit each roi by \(K\) gaussians using the EM algorithm.

        See ``laueimproc.gmm`` for terminology and ``laueimproc.gmm.em`` for the algo description.

        Parameters
        ----------
        photon_density : arraylike, optional
            Transmitted to ``laueimproc.improc.spot.fit.fit_gaussians_em``.
        indexing : str, default=&#34;ij&#34;
            The convention used for the returned positions values. Can be &#34;ij&#34; or &#34;xy&#34;.
        **kwargs : dict
            Transmitted to ``laueimproc.improc.spot.fit.fit_gaussians_em``.

        Returns
        -------
        mean : torch.Tensor
            The vectors \(\mathbf{\mu}\). Shape (n, \(K\), 2). In the absolute diagram base.
        cov : torch.Tensor
            The matrices \(\mathbf{\Sigma}\). Shape (n, \(K\), 2, 2).
        eta : torch.Tensor
            The relative mass \(\eta\). Shape (n, \(K\)).
        infodict : dict[str]
            Comes from ``laueimproc.improc.spot.fit.fit_gaussians_em``.
        &#34;&#34;&#34;
        # preparation
        if not self.is_init():
            raise RuntimeWarning(
                &#34;you must to initialize the spots (`self.find_spots()`)&#34;
            )
        photon_density = (
            float(photon_density)
            if isinstance(photon_density, numbers.Real)
            else torch.asarray(photon_density, dtype=torch.float32)
        )
        rois = self.rois
        shift = self.bboxes[:, :2]

        # main fit
        mean, cov, eta, infodict = fit_gaussians_em(rois, photon_density, **kwargs)

        # spot base to diagram base
        if mean.requires_grad:
            mean = mean + shift.unsqueeze(1)
        else:
            mean += shift.unsqueeze(1)

        assert isinstance(indexing, str), indexing.__class__.__name__
        assert indexing in {&#34;ij&#34;, &#34;xy&#34;}, indexing
        if indexing == &#34;xy&#34;:
            mean = torch.flip(mean, 2)
            mean += 0.5

        # cast
        return mean, cov, eta, infodict

    def fit_gaussian(
        self, *args, **kwargs
    ) -&gt; tuple[torch.Tensor, torch.Tensor, torch.Tensor, dict]:
        r&#34;&#34;&#34;Fit each roi by one gaussian.

        Same as ``fit_gaussians`` but squeeze the \(K = 1\) dimension.
        &#34;&#34;&#34;
        mean, cov, magnitude, infodict = self.fit_gaussians(*args, **kwargs, nbr_clusters=1)
        mean, cov, magnitude = mean.squeeze(1), cov.squeeze(1), magnitude.squeeze(1)
        if &#34;eigtheta&#34; in infodict:
            infodict = infodict.copy()  # to avoid insane cache reference error
            infodict[&#34;eigtheta&#34;] = infodict[&#34;eigtheta&#34;].squeeze(1)
        return mean, cov, magnitude, infodict

    @auto_cache
    @check_init
    def fit_gaussians(
        self, loss: str = &#34;mse&#34;, indexing: str = &#34;ij&#34;, **kwargs
    ) -&gt; tuple[torch.Tensor, torch.Tensor, torch.Tensor, dict]:
        r&#34;&#34;&#34;Fit each roi by \(K\) gaussians.

        See ``laueimproc.improc.gmm`` for terminology.

        Parameters
        ----------
        loss : str, default=&#34;mse&#34;
            Quantify the difference between ``self.rois`` and estimated rois from the gmm.
            The possible values are:

            * &#34;l1&#34; (absolute difference): \(
                \frac{1}{H.W}
                \sum\limits_{i=0}^{H-1} \sum\limits_{j=0}^{W-1}
                | rois_{k,i,j} - rois\_pred_{k,i,j} |
            \)

            * &#34;mse&#34; (mean square error): \(
                \frac{1}{H.W}
                \sum\limits_{i=0}^{H-1} \sum\limits_{j=0}^{W-1}
                \left( rois_{k,i,j} - rois\_pred_{k,i,j} \right)^2
            \)
        indexing : str, default=&#34;ij&#34;
            The convention used for the returned positions values. Can be &#34;ij&#34; or &#34;xy&#34;.
        **kwargs : dict
            Transmitted to ``laueimproc.improc.spot.fit.fit_gaussians``.

        Returns
        -------
        mean : torch.Tensor
            The vectors \(\mathbf{\mu}\). Shape (n, \(K\), 2, 1). In the absolute diagram base.
        cov : torch.Tensor
            The matrices \(\mathbf{\Sigma}\). Shape (n, \(K\), 2, 2).
        magnitude : torch.Tensor
            The absolute magnitude \(\theta.\eta\). Shape (n, \(K\)).
        infodict : dict[str]
            See ``laueimproc.improc.spot.fit.fit_gaussians``.
        &#34;&#34;&#34;
        assert loss == &#34;mse&#34;, &#34;only mse is implemented&#34;

        # preparation
        with self._rois_lock:
            data = self._rois[0]
            shapes = self._rois[1][:, 2:]
            shift = self._rois[1][:, :2]

        # main fit
        mean, cov, magnitude, infodict = fit_gaussians(data, shapes, **kwargs)

        # spot base to diagram base
        if mean.requires_grad:
            mean = mean + shift.reshape(-1, 1, 2, 1)
        else:
            mean += shift.reshape(-1, 1, 2, 1)

        assert isinstance(indexing, str), indexing.__class__.__name__
        assert indexing in {&#34;ij&#34;, &#34;xy&#34;}, indexing
        if indexing == &#34;xy&#34;:
            mean = torch.flip(mean, 2)
            mean += 0.5

        return mean, cov, magnitude, infodict</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="laueimproc.classes.base_diagram.BaseDiagram" href="base_diagram.html#laueimproc.classes.base_diagram.BaseDiagram">BaseDiagram</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="laueimproc.classes.Diagram.compute_rois_centroid"><code class="name flex">
<span>def <span class="ident">compute_rois_centroid</span></span>(<span>self, **_kwargs) ‑> torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the barycenter of each spots.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>positions</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The 2 barycenter position for each roi.
Each line corresponds to a spot and each column to an axis (shape (n, 2)).
See <code><a title="laueimproc.improc.spot.basic.compute_rois_centroid" href="../improc/spot/basic.html#laueimproc.improc.spot.basic.compute_rois_centroid">compute_rois_centroid()</a></code> for more details.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
&gt;&gt;&gt; from laueimproc.io import get_sample
&gt;&gt;&gt; diagram = Diagram(get_sample())
&gt;&gt;&gt; diagram.find_spots()
&gt;&gt;&gt; print(diagram.compute_rois_centroid())  # doctset: +ELLIPSIS
tensor([[4.2637e+00, 5.0494e+00],
        [7.2805e-01, 2.6091e+01],
        [5.1465e-01, 1.9546e+03],
        ...,
        [1.9119e+03, 1.8759e+02],
        [1.9376e+03, 1.9745e+03],
        [1.9756e+03, 1.1794e+03]])
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@auto_cache  # put the result in thread safe cache (no multiprocessing)
@check_init  # throws an exception if the diagram is not initialized
@ij_to_xy_decorator(i=(slice(None), 0), j=(slice(None), 1))
def compute_rois_centroid(self, **_kwargs) -&gt; torch.Tensor:
    &#34;&#34;&#34;Compute the barycenter of each spots.

    Returns
    -------
    positions : torch.Tensor
        The 2 barycenter position for each roi.
        Each line corresponds to a spot and each column to an axis (shape (n, 2)).
        See ``laueimproc.improc.spot.basic.compute_rois_centroid`` for more details.

    Examples
    --------
    &gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
    &gt;&gt;&gt; from laueimproc.io import get_sample
    &gt;&gt;&gt; diagram = Diagram(get_sample())
    &gt;&gt;&gt; diagram.find_spots()
    &gt;&gt;&gt; print(diagram.compute_rois_centroid())  # doctset: +ELLIPSIS
    tensor([[4.2637e+00, 5.0494e+00],
            [7.2805e-01, 2.6091e+01],
            [5.1465e-01, 1.9546e+03],
            ...,
            [1.9119e+03, 1.8759e+02],
            [1.9376e+03, 1.9745e+03],
            [1.9756e+03, 1.1794e+03]])
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    from laueimproc.improc.spot.basic import compute_rois_centroid
    with self._rois_lock:
        data, bboxes = self._rois
    return compute_rois_centroid(data, bboxes, **_kwargs)</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.Diagram.compute_rois_max"><code class="name flex">
<span>def <span class="ident">compute_rois_max</span></span>(<span>self, **_kwargs) ‑> torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Get the intensity and the position of the hottest pixel for each roi.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>imax_pos1_pos2</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The concatenation of the colum vectors of the argmax and the intensity (shape (n, 3)).
See <code><a title="laueimproc.improc.spot.basic.compute_rois_max" href="../improc/spot/basic.html#laueimproc.improc.spot.basic.compute_rois_max">compute_rois_max()</a></code> for more details.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
&gt;&gt;&gt; from laueimproc.io import get_sample
&gt;&gt;&gt; diagram = Diagram(get_sample())
&gt;&gt;&gt; diagram.find_spots()
&gt;&gt;&gt; print(diagram.compute_rois_max())  # doctset: +ELLIPSIS
tensor([[2.5000e+00, 5.5000e+00, 9.2165e-03],
        [5.0000e-01, 2.2500e+01, 1.3581e-03],
        [5.0000e-01, 1.9545e+03, 1.3123e-02],
        ...,
        [1.9125e+03, 1.8750e+02, 1.1250e-01],
        [1.9375e+03, 1.9745e+03, 6.0273e-02],
        [1.9755e+03, 1.1795e+03, 2.9212e-01]])
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@auto_cache
@check_init
@ij_to_xy_decorator(i=(slice(None), 1), j=(slice(None), 2))
def compute_rois_max(self, **_kwargs) -&gt; torch.Tensor:
    &#34;&#34;&#34;Get the intensity and the position of the hottest pixel for each roi.

    Returns
    -------
    imax_pos1_pos2 : torch.Tensor
        The concatenation of the colum vectors of the argmax and the intensity (shape (n, 3)).
        See ``laueimproc.improc.spot.basic.compute_rois_max`` for more details.

    Examples
    --------
    &gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
    &gt;&gt;&gt; from laueimproc.io import get_sample
    &gt;&gt;&gt; diagram = Diagram(get_sample())
    &gt;&gt;&gt; diagram.find_spots()
    &gt;&gt;&gt; print(diagram.compute_rois_max())  # doctset: +ELLIPSIS
    tensor([[2.5000e+00, 5.5000e+00, 9.2165e-03],
            [5.0000e-01, 2.2500e+01, 1.3581e-03],
            [5.0000e-01, 1.9545e+03, 1.3123e-02],
            ...,
            [1.9125e+03, 1.8750e+02, 1.1250e-01],
            [1.9375e+03, 1.9745e+03, 6.0273e-02],
            [1.9755e+03, 1.1795e+03, 2.9212e-01]])
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    from laueimproc.improc.spot.basic import compute_rois_max
    with self._rois_lock:
        data, bboxes = self._rois
    return compute_rois_max(data, bboxes, **_kwargs)</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.Diagram.compute_rois_nb_peaks"><code class="name flex">
<span>def <span class="ident">compute_rois_nb_peaks</span></span>(<span>self, **_kwargs) ‑> torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Find the number of extremums in each roi.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>nbr_of_peaks</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The number of extremums (shape (n,)).
See <code><a title="laueimproc.improc.spot.extrema.compute_rois_nb_peaks" href="../improc/spot/extrema.html#laueimproc.improc.spot.extrema.compute_rois_nb_peaks">compute_rois_nb_peaks()</a></code> for more details.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>No noise filtering. Doesn't detect shoulders.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
&gt;&gt;&gt; from laueimproc.io import get_sample
&gt;&gt;&gt; diagram = Diagram(get_sample())
&gt;&gt;&gt; diagram.find_spots()
&gt;&gt;&gt; print(diagram.compute_rois_nb_peaks())
tensor([23,  4,  3,  2,  6,  3,  1,  3,  1,  4,  1,  2,  3,  1,  1,  3,  3,  3,
         2,  7,  4,  1,  1,  3,  3,  2,  4,  2,  1,  2,  1,  2,  2,  2,  2,  2,
         6,  2,  1,  2,  4,  2,  3,  4,  1,  1,  4,  3,  1,  4,  4,  5,  3,  3,
         1,  5,  3,  2,  6,  1,  2,  3,  1,  4,  6,  3,  6,  2,  2,  5,  7,  5,
         3,  2,  3,  1,  2,  6,  8,  2,  3,  3,  3,  3,  2,  4,  2,  1,  1,  4,
         4,  1,  4,  2,  5,  4,  3,  3,  1,  2,  1,  3,  4,  2,  5,  5,  7,  2,
         6,  3,  5,  2,  2,  2,  7,  2,  3,  5,  3,  1,  4,  8,  3,  3,  4,  3,
         4,  2,  5,  1,  7,  3,  5,  4, 10,  2,  3,  3,  4,  3,  5,  8,  2,  5,
         8,  3,  2,  3,  5,  5,  5,  3,  4,  6,  2,  4,  1,  3,  4,  2,  3,  4,
         5,  5,  2,  4,  6,  4,  4,  1,  2,  4,  4,  3, 13, 13,  3,  6,  3,  2,
         1,  4,  6,  3,  2,  2, 16,  3,  1,  2,  2,  4,  1,  3,  7,  4,  1,  5,
         4,  7,  5,  1,  6,  6,  2,  4,  3,  9,  3,  2,  3,  2,  8,  5,  3,  3,
         3,  3, 10,  9,  2,  2,  5,  4,  3,  3,  2,  1,  3,  6, 11,  2,  4,  4,
         6,  2,  7,  5,  2, 10], dtype=torch.int16)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@auto_cache
@check_init
def compute_rois_nb_peaks(self, **_kwargs) -&gt; torch.Tensor:
    &#34;&#34;&#34;Find the number of extremums in each roi.

    Returns
    -------
    nbr_of_peaks : torch.Tensor
        The number of extremums (shape (n,)).
        See ``laueimproc.improc.spot.extrema.compute_rois_nb_peaks`` for more details.

    Notes
    -----
    No noise filtering. Doesn&#39;t detect shoulders.

    Examples
    --------
    &gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
    &gt;&gt;&gt; from laueimproc.io import get_sample
    &gt;&gt;&gt; diagram = Diagram(get_sample())
    &gt;&gt;&gt; diagram.find_spots()
    &gt;&gt;&gt; print(diagram.compute_rois_nb_peaks())
    tensor([23,  4,  3,  2,  6,  3,  1,  3,  1,  4,  1,  2,  3,  1,  1,  3,  3,  3,
             2,  7,  4,  1,  1,  3,  3,  2,  4,  2,  1,  2,  1,  2,  2,  2,  2,  2,
             6,  2,  1,  2,  4,  2,  3,  4,  1,  1,  4,  3,  1,  4,  4,  5,  3,  3,
             1,  5,  3,  2,  6,  1,  2,  3,  1,  4,  6,  3,  6,  2,  2,  5,  7,  5,
             3,  2,  3,  1,  2,  6,  8,  2,  3,  3,  3,  3,  2,  4,  2,  1,  1,  4,
             4,  1,  4,  2,  5,  4,  3,  3,  1,  2,  1,  3,  4,  2,  5,  5,  7,  2,
             6,  3,  5,  2,  2,  2,  7,  2,  3,  5,  3,  1,  4,  8,  3,  3,  4,  3,
             4,  2,  5,  1,  7,  3,  5,  4, 10,  2,  3,  3,  4,  3,  5,  8,  2,  5,
             8,  3,  2,  3,  5,  5,  5,  3,  4,  6,  2,  4,  1,  3,  4,  2,  3,  4,
             5,  5,  2,  4,  6,  4,  4,  1,  2,  4,  4,  3, 13, 13,  3,  6,  3,  2,
             1,  4,  6,  3,  2,  2, 16,  3,  1,  2,  2,  4,  1,  3,  7,  4,  1,  5,
             4,  7,  5,  1,  6,  6,  2,  4,  3,  9,  3,  2,  3,  2,  8,  5,  3,  3,
             3,  3, 10,  9,  2,  2,  5,  4,  3,  3,  2,  1,  3,  6, 11,  2,  4,  4,
             6,  2,  7,  5,  2, 10], dtype=torch.int16)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    from laueimproc.improc.spot.extrema import compute_rois_nb_peaks
    with self._rois_lock:
        data, bboxes = self._rois
    return compute_rois_nb_peaks(data, bboxes, **_kwargs)</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.Diagram.compute_rois_pca"><code class="name flex">
<span>def <span class="ident">compute_rois_pca</span></span>(<span>self, **_kwargs) ‑> torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the pca on each spot.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>std1_std2_theta</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The concatenation of the colum vectors of the two std and the angle (shape (n, 3)).
See <code><a title="laueimproc.improc.spot.pca.compute_rois_pca" href="../improc/spot/pca.html#laueimproc.improc.spot.pca.compute_rois_pca">compute_rois_pca()</a></code> for more details.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
&gt;&gt;&gt; from laueimproc.io import get_sample
&gt;&gt;&gt; diagram = Diagram(get_sample())
&gt;&gt;&gt; diagram.find_spots()
&gt;&gt;&gt; print(diagram.compute_rois_pca())  # doctset: +ELLIPSIS
tensor([[ 0.4340,  0.2615, -0.8608],
        [ 0.7120,  0.0774, -1.5626],
        [ 0.4909,  0.0085, -1.5700],
        ...,
        [ 0.1986,  0.1379, -0.6384],
        [ 0.1980,  0.1390,  0.6738],
        [ 0.1658,  0.1444,  0.5321]])
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@auto_cache
@check_init
def compute_rois_pca(self, **_kwargs) -&gt; torch.Tensor:
    &#34;&#34;&#34;Compute the pca on each spot.

    Returns
    -------
    std1_std2_theta : torch.Tensor
        The concatenation of the colum vectors of the two std and the angle (shape (n, 3)).
        See ``laueimproc.improc.spot.pca.compute_rois_pca`` for more details.

    Examples
    --------
    &gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
    &gt;&gt;&gt; from laueimproc.io import get_sample
    &gt;&gt;&gt; diagram = Diagram(get_sample())
    &gt;&gt;&gt; diagram.find_spots()
    &gt;&gt;&gt; print(diagram.compute_rois_pca())  # doctset: +ELLIPSIS
    tensor([[ 0.4340,  0.2615, -0.8608],
            [ 0.7120,  0.0774, -1.5626],
            [ 0.4909,  0.0085, -1.5700],
            ...,
            [ 0.1986,  0.1379, -0.6384],
            [ 0.1980,  0.1390,  0.6738],
            [ 0.1658,  0.1444,  0.5321]])
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    from laueimproc.improc.spot.pca import compute_rois_pca
    with self._rois_lock:
        data, bboxes = self._rois
    return compute_rois_pca(data, bboxes, **_kwargs)</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.Diagram.compute_rois_sum"><code class="name flex">
<span>def <span class="ident">compute_rois_sum</span></span>(<span>self, **_kwargs) ‑> torch.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Sum the intensities of the pixels for each roi.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>total_intensity</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The intensity of each roi, sum of the pixels (shape (n,)).
See <code><a title="laueimproc.improc.spot.basic.compute_rois_sum" href="../improc/spot/basic.html#laueimproc.improc.spot.basic.compute_rois_sum">compute_rois_sum()</a></code> for more details.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
&gt;&gt;&gt; from laueimproc.io import get_sample
&gt;&gt;&gt; diagram = Diagram(get_sample())
&gt;&gt;&gt; diagram.find_spots()
&gt;&gt;&gt; print(diagram.compute_rois_sum())  # doctset: +ELLIPSIS
tensor([2.1886e-01, 1.1643e-02, 5.6260e-02, 1.6938e-03, 9.8726e-03, 6.1647e-02,
        3.5279e-02, 3.1891e-03, 1.0071e-02, 2.2889e-03, 1.0285e-02, 1.9760e-01,
        1.7258e-02, 3.3402e-02, 9.1829e-02, 3.1510e-02, 8.4550e-02, 4.0864e-02,
        ...,
        9.2822e-01, 9.7104e-01, 4.1733e-02, 9.4377e-02, 5.2491e-03, 4.2115e-03,
        3.9217e-01, 1.5907e+00, 1.1802e+00, 1.4968e-01, 4.0696e-01, 6.3442e-01,
        1.3559e+00, 6.0548e-01, 1.7116e+00, 9.2990e-01, 4.9596e-01, 2.0383e+00])
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@auto_cache
@check_init
def compute_rois_sum(self, **_kwargs) -&gt; torch.Tensor:
    &#34;&#34;&#34;Sum the intensities of the pixels for each roi.

    Returns
    -------
    total_intensity : torch.Tensor
        The intensity of each roi, sum of the pixels (shape (n,)).
        See ``laueimproc.improc.spot.basic.compute_rois_sum`` for more details.

    Examples
    --------
    &gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
    &gt;&gt;&gt; from laueimproc.io import get_sample
    &gt;&gt;&gt; diagram = Diagram(get_sample())
    &gt;&gt;&gt; diagram.find_spots()
    &gt;&gt;&gt; print(diagram.compute_rois_sum())  # doctset: +ELLIPSIS
    tensor([2.1886e-01, 1.1643e-02, 5.6260e-02, 1.6938e-03, 9.8726e-03, 6.1647e-02,
            3.5279e-02, 3.1891e-03, 1.0071e-02, 2.2889e-03, 1.0285e-02, 1.9760e-01,
            1.7258e-02, 3.3402e-02, 9.1829e-02, 3.1510e-02, 8.4550e-02, 4.0864e-02,
            ...,
            9.2822e-01, 9.7104e-01, 4.1733e-02, 9.4377e-02, 5.2491e-03, 4.2115e-03,
            3.9217e-01, 1.5907e+00, 1.1802e+00, 1.4968e-01, 4.0696e-01, 6.3442e-01,
            1.3559e+00, 6.0548e-01, 1.7116e+00, 9.2990e-01, 4.9596e-01, 2.0383e+00])
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    from laueimproc.improc.spot.basic import compute_rois_sum
    with self._rois_lock:
        data, bboxes = self._rois
    return compute_rois_sum(data, bboxes, **_kwargs)</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.Diagram.fit_gaussian"><code class="name flex">
<span>def <span class="ident">fit_gaussian</span></span>(<span>self, *args, **kwargs) ‑> tuple[torch.Tensor, torch.Tensor, torch.Tensor, dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Fit each roi by one gaussian.</p>
<p>Same as <code>fit_gaussians</code> but squeeze the <span><span class="MathJax_Preview">K = 1</span><script type="math/tex">K = 1</script></span> dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_gaussian(
    self, *args, **kwargs
) -&gt; tuple[torch.Tensor, torch.Tensor, torch.Tensor, dict]:
    r&#34;&#34;&#34;Fit each roi by one gaussian.

    Same as ``fit_gaussians`` but squeeze the \(K = 1\) dimension.
    &#34;&#34;&#34;
    mean, cov, magnitude, infodict = self.fit_gaussians(*args, **kwargs, nbr_clusters=1)
    mean, cov, magnitude = mean.squeeze(1), cov.squeeze(1), magnitude.squeeze(1)
    if &#34;eigtheta&#34; in infodict:
        infodict = infodict.copy()  # to avoid insane cache reference error
        infodict[&#34;eigtheta&#34;] = infodict[&#34;eigtheta&#34;].squeeze(1)
    return mean, cov, magnitude, infodict</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.Diagram.fit_gaussian_em"><code class="name flex">
<span>def <span class="ident">fit_gaussian_em</span></span>(<span>self, *args, **kwargs) ‑> tuple[torch.Tensor, torch.Tensor, dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Fit each roi by one gaussian using the EM algorithm in one shot, very fast.</p>
<p>Same as <code>flaueimproc.classes.diagram.fit_gaussians_em</code> but squeeze the <span><span class="MathJax_Preview">K = 1</span><script type="math/tex">K = 1</script></span> dim.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Transmitted to <code>laueimproc.classes.diagram.fit_gaussians_em</code>.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Transmitted to <code>laueimproc.classes.diagram.fit_gaussians_em</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mean</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The vectors <span><span class="MathJax_Preview">\mathbf{\mu}</span><script type="math/tex">\mathbf{\mu}</script></span>. Shape (n, 2). In the absolute diagram base.</dd>
<dt><strong><code>cov</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The matrices <span><span class="MathJax_Preview">\mathbf{\Sigma}</span><script type="math/tex">\mathbf{\Sigma}</script></span>. Shape (n, 2, 2).</dd>
<dt><strong><code>infodict</code></strong> :&ensp;<code>dict[str]</code></dt>
<dd>Comes from <code>laueimproc.improc.spot.fit.fit_gaussian_em</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_gaussian_em(self, *args, **kwargs) -&gt; tuple[torch.Tensor, torch.Tensor, dict]:
    r&#34;&#34;&#34;Fit each roi by one gaussian using the EM algorithm in one shot, very fast.

    Same as ``flaueimproc.classes.diagram.fit_gaussians_em`` but squeeze the \(K = 1\) dim.

    Parameters
    ----------
    *args : tuple
        Transmitted to ``laueimproc.classes.diagram.fit_gaussians_em``.
    **kwargs : dict
        Transmitted to ``laueimproc.classes.diagram.fit_gaussians_em``.

    Returns
    -------
    mean : torch.Tensor
        The vectors \(\mathbf{\mu}\). Shape (n, 2). In the absolute diagram base.
    cov : torch.Tensor
        The matrices \(\mathbf{\Sigma}\). Shape (n, 2, 2).
    infodict : dict[str]
        Comes from ``laueimproc.improc.spot.fit.fit_gaussian_em``.
    &#34;&#34;&#34;
    assert &#34;nbr_clusters&#34; not in kwargs, &#34;use fit_gaussianSSS_em instead&#34;
    mean, cov, _, infodict = self.fit_gaussians_em(*args, **kwargs, nbr_clusters=1)
    mean, cov = mean.squeeze(1), cov.squeeze(1)
    if &#34;eigtheta&#34; in infodict:
        infodict[&#34;eigtheta&#34;] = infodict[&#34;eigtheta&#34;].squeeze(1)
    return mean, cov, infodict</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.Diagram.fit_gaussians"><code class="name flex">
<span>def <span class="ident">fit_gaussians</span></span>(<span>self, loss: str = 'mse', indexing: str = 'ij', **kwargs) ‑> tuple[torch.Tensor, torch.Tensor, torch.Tensor, dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Fit each roi by <span><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span> gaussians.</p>
<p>See <code>laueimproc.improc.gmm</code> for terminology.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>loss</code></strong> :&ensp;<code>str</code>, default=<code>"mse"</code></dt>
<dd>
<p>Quantify the difference between <code>self.rois</code> and estimated rois from the gmm.
The possible values are:</p>
<ul>
<li>
<p>"l1" (absolute difference): <span><span class="MathJax_Preview">
\frac{1}{H.W}
\sum\limits_{i=0}^{H-1} \sum\limits_{j=0}^{W-1}
| rois_{k,i,j} - rois\_pred_{k,i,j} |
</span><script type="math/tex">
\frac{1}{H.W}
\sum\limits_{i=0}^{H-1} \sum\limits_{j=0}^{W-1}
| rois_{k,i,j} - rois\_pred_{k,i,j} |
</script></span></p>
</li>
<li>
<p>"mse" (mean square error): <span><span class="MathJax_Preview">
\frac{1}{H.W}
\sum\limits_{i=0}^{H-1} \sum\limits_{j=0}^{W-1}
\left( rois_{k,i,j} - rois\_pred_{k,i,j} \right)^2
</span><script type="math/tex">
\frac{1}{H.W}
\sum\limits_{i=0}^{H-1} \sum\limits_{j=0}^{W-1}
\left( rois_{k,i,j} - rois\_pred_{k,i,j} \right)^2
</script></span></p>
</li>
</ul>
</dd>
<dt><strong><code>indexing</code></strong> :&ensp;<code>str</code>, default=<code>"ij"</code></dt>
<dd>The convention used for the returned positions values. Can be "ij" or "xy".</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Transmitted to <code><a title="laueimproc.improc.spot.fit.fit_gaussians" href="../improc/spot/fit.html#laueimproc.improc.spot.fit.fit_gaussians">fit_gaussians()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mean</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The vectors <span><span class="MathJax_Preview">\mathbf{\mu}</span><script type="math/tex">\mathbf{\mu}</script></span>. Shape (n, <span><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span>, 2, 1). In the absolute diagram base.</dd>
<dt><strong><code>cov</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The matrices <span><span class="MathJax_Preview">\mathbf{\Sigma}</span><script type="math/tex">\mathbf{\Sigma}</script></span>. Shape (n, <span><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span>, 2, 2).</dd>
<dt><strong><code>magnitude</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The absolute magnitude <span><span class="MathJax_Preview">\theta.\eta</span><script type="math/tex">\theta.\eta</script></span>. Shape (n, <span><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span>).</dd>
<dt><strong><code>infodict</code></strong> :&ensp;<code>dict[str]</code></dt>
<dd>See <code><a title="laueimproc.improc.spot.fit.fit_gaussians" href="../improc/spot/fit.html#laueimproc.improc.spot.fit.fit_gaussians">fit_gaussians()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@auto_cache
@check_init
def fit_gaussians(
    self, loss: str = &#34;mse&#34;, indexing: str = &#34;ij&#34;, **kwargs
) -&gt; tuple[torch.Tensor, torch.Tensor, torch.Tensor, dict]:
    r&#34;&#34;&#34;Fit each roi by \(K\) gaussians.

    See ``laueimproc.improc.gmm`` for terminology.

    Parameters
    ----------
    loss : str, default=&#34;mse&#34;
        Quantify the difference between ``self.rois`` and estimated rois from the gmm.
        The possible values are:

        * &#34;l1&#34; (absolute difference): \(
            \frac{1}{H.W}
            \sum\limits_{i=0}^{H-1} \sum\limits_{j=0}^{W-1}
            | rois_{k,i,j} - rois\_pred_{k,i,j} |
        \)

        * &#34;mse&#34; (mean square error): \(
            \frac{1}{H.W}
            \sum\limits_{i=0}^{H-1} \sum\limits_{j=0}^{W-1}
            \left( rois_{k,i,j} - rois\_pred_{k,i,j} \right)^2
        \)
    indexing : str, default=&#34;ij&#34;
        The convention used for the returned positions values. Can be &#34;ij&#34; or &#34;xy&#34;.
    **kwargs : dict
        Transmitted to ``laueimproc.improc.spot.fit.fit_gaussians``.

    Returns
    -------
    mean : torch.Tensor
        The vectors \(\mathbf{\mu}\). Shape (n, \(K\), 2, 1). In the absolute diagram base.
    cov : torch.Tensor
        The matrices \(\mathbf{\Sigma}\). Shape (n, \(K\), 2, 2).
    magnitude : torch.Tensor
        The absolute magnitude \(\theta.\eta\). Shape (n, \(K\)).
    infodict : dict[str]
        See ``laueimproc.improc.spot.fit.fit_gaussians``.
    &#34;&#34;&#34;
    assert loss == &#34;mse&#34;, &#34;only mse is implemented&#34;

    # preparation
    with self._rois_lock:
        data = self._rois[0]
        shapes = self._rois[1][:, 2:]
        shift = self._rois[1][:, :2]

    # main fit
    mean, cov, magnitude, infodict = fit_gaussians(data, shapes, **kwargs)

    # spot base to diagram base
    if mean.requires_grad:
        mean = mean + shift.reshape(-1, 1, 2, 1)
    else:
        mean += shift.reshape(-1, 1, 2, 1)

    assert isinstance(indexing, str), indexing.__class__.__name__
    assert indexing in {&#34;ij&#34;, &#34;xy&#34;}, indexing
    if indexing == &#34;xy&#34;:
        mean = torch.flip(mean, 2)
        mean += 0.5

    return mean, cov, magnitude, infodict</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.Diagram.fit_gaussians_em"><code class="name flex">
<span>def <span class="ident">fit_gaussians_em</span></span>(<span>self, photon_density: Union[torch.Tensor, numpy.ndarray, numbers.Real] = 1.0, indexing: str = 'ij', **kwargs) ‑> tuple[torch.Tensor, torch.Tensor, dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Fit each roi by <span><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span> gaussians using the EM algorithm.</p>
<p>See <code><a title="laueimproc.gmm" href="../gmm/index.html">laueimproc.gmm</a></code> for terminology and <code><a title="laueimproc.gmm.em" href="../gmm/em.html">laueimproc.gmm.em</a></code> for the algo description.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>photon_density</code></strong> :&ensp;<code>arraylike</code>, optional</dt>
<dd>Transmitted to <code><a title="laueimproc.improc.spot.fit.fit_gaussians_em" href="../improc/spot/fit.html#laueimproc.improc.spot.fit.fit_gaussians_em">fit_gaussians_em()</a></code>.</dd>
<dt><strong><code>indexing</code></strong> :&ensp;<code>str</code>, default=<code>"ij"</code></dt>
<dd>The convention used for the returned positions values. Can be "ij" or "xy".</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Transmitted to <code><a title="laueimproc.improc.spot.fit.fit_gaussians_em" href="../improc/spot/fit.html#laueimproc.improc.spot.fit.fit_gaussians_em">fit_gaussians_em()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mean</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The vectors <span><span class="MathJax_Preview">\mathbf{\mu}</span><script type="math/tex">\mathbf{\mu}</script></span>. Shape (n, <span><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span>, 2). In the absolute diagram base.</dd>
<dt><strong><code>cov</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The matrices <span><span class="MathJax_Preview">\mathbf{\Sigma}</span><script type="math/tex">\mathbf{\Sigma}</script></span>. Shape (n, <span><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span>, 2, 2).</dd>
<dt><strong><code>eta</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The relative mass <span><span class="MathJax_Preview">\eta</span><script type="math/tex">\eta</script></span>. Shape (n, <span><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span>).</dd>
<dt><strong><code>infodict</code></strong> :&ensp;<code>dict[str]</code></dt>
<dd>Comes from <code><a title="laueimproc.improc.spot.fit.fit_gaussians_em" href="../improc/spot/fit.html#laueimproc.improc.spot.fit.fit_gaussians_em">fit_gaussians_em()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@auto_cache
@check_init
def fit_gaussians_em(
    self,
    photon_density: typing.Union[torch.Tensor, np.ndarray, numbers.Real] = 1.0,
    indexing: str = &#34;ij&#34;,
    **kwargs,
) -&gt; tuple[torch.Tensor, torch.Tensor, dict]:
    r&#34;&#34;&#34;Fit each roi by \(K\) gaussians using the EM algorithm.

    See ``laueimproc.gmm`` for terminology and ``laueimproc.gmm.em`` for the algo description.

    Parameters
    ----------
    photon_density : arraylike, optional
        Transmitted to ``laueimproc.improc.spot.fit.fit_gaussians_em``.
    indexing : str, default=&#34;ij&#34;
        The convention used for the returned positions values. Can be &#34;ij&#34; or &#34;xy&#34;.
    **kwargs : dict
        Transmitted to ``laueimproc.improc.spot.fit.fit_gaussians_em``.

    Returns
    -------
    mean : torch.Tensor
        The vectors \(\mathbf{\mu}\). Shape (n, \(K\), 2). In the absolute diagram base.
    cov : torch.Tensor
        The matrices \(\mathbf{\Sigma}\). Shape (n, \(K\), 2, 2).
    eta : torch.Tensor
        The relative mass \(\eta\). Shape (n, \(K\)).
    infodict : dict[str]
        Comes from ``laueimproc.improc.spot.fit.fit_gaussians_em``.
    &#34;&#34;&#34;
    # preparation
    if not self.is_init():
        raise RuntimeWarning(
            &#34;you must to initialize the spots (`self.find_spots()`)&#34;
        )
    photon_density = (
        float(photon_density)
        if isinstance(photon_density, numbers.Real)
        else torch.asarray(photon_density, dtype=torch.float32)
    )
    rois = self.rois
    shift = self.bboxes[:, :2]

    # main fit
    mean, cov, eta, infodict = fit_gaussians_em(rois, photon_density, **kwargs)

    # spot base to diagram base
    if mean.requires_grad:
        mean = mean + shift.unsqueeze(1)
    else:
        mean += shift.unsqueeze(1)

    assert isinstance(indexing, str), indexing.__class__.__name__
    assert indexing in {&#34;ij&#34;, &#34;xy&#34;}, indexing
    if indexing == &#34;xy&#34;:
        mean = torch.flip(mean, 2)
        mean += 0.5

    # cast
    return mean, cov, eta, infodict</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="laueimproc.classes.base_diagram.BaseDiagram" href="base_diagram.html#laueimproc.classes.base_diagram.BaseDiagram">BaseDiagram</a></b></code>:
<ul class="hlist">
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.add_property" href="base_diagram.html#laueimproc.classes.base_diagram.BaseDiagram.add_property">add_property</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.bboxes" href="base_diagram.html#laueimproc.classes.base_diagram.BaseDiagram.bboxes">bboxes</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.clone" href="base_diagram.html#laueimproc.classes.base_diagram.BaseDiagram.clone">clone</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.compress" href="base_diagram.html#laueimproc.classes.base_diagram.BaseDiagram.compress">compress</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.file" href="base_diagram.html#laueimproc.classes.base_diagram.BaseDiagram.file">file</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.filter_spots" href="base_diagram.html#laueimproc.classes.base_diagram.BaseDiagram.filter_spots">filter_spots</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.find_spots" href="base_diagram.html#laueimproc.classes.base_diagram.BaseDiagram.find_spots">find_spots</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.get_property" href="base_diagram.html#laueimproc.classes.base_diagram.BaseDiagram.get_property">get_property</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.history" href="base_diagram.html#laueimproc.classes.base_diagram.BaseDiagram.history">history</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.image" href="base_diagram.html#laueimproc.classes.base_diagram.BaseDiagram.image">image</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.is_init" href="base_diagram.html#laueimproc.classes.base_diagram.BaseDiagram.is_init">is_init</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.plot" href="base_diagram.html#laueimproc.classes.base_diagram.BaseDiagram.plot">plot</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.rawrois" href="base_diagram.html#laueimproc.classes.base_diagram.BaseDiagram.rawrois">rawrois</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.rois" href="base_diagram.html#laueimproc.classes.base_diagram.BaseDiagram.rois">rois</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.set_spots" href="base_diagram.html#laueimproc.classes.base_diagram.BaseDiagram.set_spots">set_spots</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.state" href="base_diagram.html#laueimproc.classes.base_diagram.BaseDiagram.state">state</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="laueimproc.classes.DiagramsDataset"><code class="flex name class">
<span>class <span class="ident">DiagramsDataset</span></span>
<span>(</span><span>*diagram_refs, diag2ind: Optional[Callable[[<a title="laueimproc.classes.diagram.Diagram" href="diagram.html#laueimproc.classes.diagram.Diagram">Diagram</a>], numbers.Integral]] = None, position: Optional[Callable[[int], tuple[numbers.Real, numbers.Real]]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Link Diagrams together.</p>
<p>Initialise the dataset.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*diagram_refs</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The diagram references, transmitted to <code>add_diagrams</code>.</dd>
<dt><strong><code>diag2ind</code></strong> :&ensp;<code>callable</code>, default=<code>laueimproc.classses.dataset.default_diag2ind</code></dt>
<dd>The function to associate an index to a diagram.
If provided, this function has to be pickleable.
It has to take only one positional argument (a simple Diagram instance)
and to return a positive integer.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>Provides information on the phisical position of the images on the sample.
This function takes as input the index of the diagram,
and returns the 2 coordinates in the sample plane.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DiagramsDataset(threading.Thread):
    &#34;&#34;&#34;Link Diagrams together.&#34;&#34;&#34;

    def __init__(
        self,
        *diagram_refs,
        diag2ind: typing.Optional[typing.Callable[[Diagram], numbers.Integral]] = None,
        position: typing.Optional[typing.Callable[[int], tuple[numbers.Real, numbers.Real]]] = None,
    ):
        &#34;&#34;&#34;Initialise the dataset.

        Parameters
        ----------
        *diagram_refs : tuple
            The diagram references, transmitted to ``add_diagrams``.
        diag2ind : callable, default=laueimproc.classses.dataset.default_diag2ind
            The function to associate an index to a diagram.
            If provided, this function has to be pickleable.
            It has to take only one positional argument (a simple Diagram instance)
            and to return a positive integer.
        position : callable, optional
            Provides information on the phisical position of the images on the sample.
            This function takes as input the index of the diagram,
            and returns the 2 coordinates in the sample plane.
        &#34;&#34;&#34;
        if diag2ind is None:
            self._diag2ind = default_diag2ind
        else:
            self._diag2ind = cloudpickle.loads(self._check_diag2ind(diag2ind))
        if position is not None:
            position = cloudpickle.loads(self._check_position(position))
        self._position = [position, {}]  # the dict associate (x, y) to index
        self._diagrams: dict[int, typing.Union[Diagram, queue.Queue]] = {}  # index to diagram
        self._lock = threading.Lock()
        self._to_sniff: dict = {&#34;dirs&#34;: [], &#34;readed&#34;: set()}  # for the async run method
        self._operations_chain: list[tuple[typing.Callable[[Diagram], object], tuple]] = []
        self._properties: dict[str, tuple[typing.Union[None, str], object]] = {}  # the properties
        super().__init__(daemon=True)
        self.add_diagrams(diagram_refs)

    def __getstate__(self):
        &#34;&#34;&#34;Make the dataset pickleable.&#34;&#34;&#34;
        with self._lock:
            pos_data = self._position[1]
            return (
                cloudpickle.dumps(self._diag2ind),
                [
                    cloudpickle.dumps(self._position[0]),
                    (pos_data.copy() if isinstance(pos_data, dict) else pos_data),
                ],
                self._diagrams.copy(),
                cloudpickle.dumps(self._operations_chain),
                self._properties.copy(),
            )

    def __getitem__(self, item: numbers.Integral):
        &#34;&#34;&#34;Get a diagram or a subset of the set.

        Parameters
        ----------
        item : int or slice
            The item of the diagram you want to reach.

        Returns
        -------
        Diagram or Dataset
            If the item is integer, return the corresponding diagram,
            return a frozen sub dataset view if it is a slice.

        Raises
        ------
        IndexError
            If the diagram of index `item` is not founded yet.

        Examples
        --------
        &gt;&gt;&gt; import torch
        &gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
        &gt;&gt;&gt; from laueimproc.io import get_samples
        &gt;&gt;&gt; dataset = DiagramsDataset(get_samples())
        &gt;&gt;&gt;
        &gt;&gt;&gt; # from integer
        &gt;&gt;&gt; dataset[0]
        Diagram(img_00.jp2)
        &gt;&gt;&gt; dataset[10]
        Diagram(img_10.jp2)
        &gt;&gt;&gt; dataset[-10]
        Diagram(img_90.jp2)
        &gt;&gt;&gt;
        &gt;&gt;&gt; # from slice
        &gt;&gt;&gt; subdataset = dataset[:30:10]
        &gt;&gt;&gt; sorted(subdataset, key=str)
        [Diagram(img_00.jp2), Diagram(img_10.jp2), Diagram(img_20.jp2)]
        &gt;&gt;&gt;
        &gt;&gt;&gt; # from indices
        &gt;&gt;&gt; subdataset = dataset[[0, 10, -10]]
        &gt;&gt;&gt; sorted(subdataset, key=str)
        [Diagram(img_00.jp2), Diagram(img_10.jp2), Diagram(img_90.jp2)]
        &gt;&gt;&gt;
        &gt;&gt;&gt; # from condition
        &gt;&gt;&gt; prop = torch.full((100,), False, dtype=bool)
        &gt;&gt;&gt; prop[[0, 10, -10]] = True
        &gt;&gt;&gt; subdataset = dataset[prop]
        &gt;&gt;&gt; sorted(subdataset, key=str)
        [Diagram(img_00.jp2), Diagram(img_10.jp2), Diagram(img_90.jp2)]
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if isinstance(item, numbers.Integral):
            return self._get_diagram_from_index(item)
        if isinstance(item, slice):
            item = range(*item.indices(max(self._diagrams)+1))
        if isinstance(item, range):  # faster than torch.asarray
            item = np.fromiter(item, dtype=np.int64)
        if isinstance(item, (list, np.ndarray, torch.Tensor)):
            item = torch.asarray(item).reshape(-1)
            if item.dtype is torch.bool:
                item = torch.arange(len(item), dtype=torch.int64, device=item.device)[item]
            elif item.dtype != torch.int64:
                item = item.to(torch.int64)
            return self._get_diagrams_from_indices(item)
        # if isinstance(item, tuple):  # case grid
        #     if self._position[0] is None:
        #         raise AttributeError(
        #             &#34;you must provide the `position` argument to acces the position&#34;
        #         )
        #     assert len(item) == 2, f&#34;only 2d position allow, not {len(item)}d&#34;
        #     if isinstance(item[0], numbers.Real) and isinstance(item[1], numbers.Real):
        #         return self._get_diagram_from_coord(*item)

        raise TypeError(f&#34;only int, slices and tuple[float, float] are allowed, not {item}&#34;)

    def __iter__(self) -&gt; Diagram:
        &#34;&#34;&#34;Yield the diagrams ready.

        * This function is dynamic in the sense that if a new diagram is poping up
        during iterating, it&#39;s gotta be yield as well.
        * Diagrams are iterated in an arbitray, non-repeatable order

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
        &gt;&gt;&gt; from laueimproc.io import get_samples
        &gt;&gt;&gt; dataset = DiagramsDataset(get_samples())
        &gt;&gt;&gt; count = 0
        &gt;&gt;&gt; for diagram in dataset:
        ...     count += 1
        ...
        &gt;&gt;&gt; count
        100
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        yielded = set()  # the yielded diagrams
        while True:
            with self._lock:
                if not (toyield := self._diagrams.keys() - yielded):
                    break
            for index in toyield:
                try:
                    diag = self._get_diagram_from_index(index)
                except IndexError:
                    pass
                yielded.add(index)
                yield diag

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Return the numbers of diagrams currently present in the dataset.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
        &gt;&gt;&gt; from laueimproc.io import get_samples
        &gt;&gt;&gt; len(DiagramsDataset(get_samples()))
        100
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return len(self._diagrams)

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Give a very compact representation.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
        &gt;&gt;&gt; from laueimproc.io import get_samples
        &gt;&gt;&gt; DiagramsDataset(get_samples())
        &lt;DiagramsDataset with 100 diagrams&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return f&#34;&lt;{self.__class__.__name__} with {len(self)} diagrams&gt;&#34;

    def __setstate__(self, state: tuple):
        &#34;&#34;&#34;Fill the internal attributes.

        Usefull for pickle.

        Notes
        -----
        * No verification is made because the user is not supposed to call this method.

        Examples
        --------
        &gt;&gt;&gt; import pickle
        &gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
        &gt;&gt;&gt; from laueimproc.io import get_samples
        &gt;&gt;&gt; dataset = DiagramsDataset(get_samples())
        &gt;&gt;&gt; dataset_bis = pickle.loads(pickle.dumps(dataset))
        &gt;&gt;&gt; assert id(dataset) != id(dataset_bis)
        &gt;&gt;&gt; assert dataset.state == dataset_bis.state
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        # not verification for thread safe
        # because this method is never meant to be call from a thread.
        (
            diag2ind_ser,
            self._position,
            self._diagrams,
            operations_chain_ser,
            self._properties,
        ) = state
        self._diag2ind = cloudpickle.loads(diag2ind_ser)
        self._position[0] = cloudpickle.loads(self._position[0])
        self._operations_chain = cloudpickle.loads(operations_chain_ser)
        self._lock = threading.Lock()
        self._to_sniff: dict = {&#34;dirs&#34;: [], &#34;readed&#34;: set()}  # for the async run method
        super().__init__(daemon=True)

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Return an exaustive printable string giving informations on the dataset.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
        &gt;&gt;&gt; from laueimproc.io import get_samples
        &gt;&gt;&gt; print(DiagramsDataset(get_samples()))  # doctest: +ELLIPSIS
        DiagramsDataset from the folder /home/.../.cache/laueimproc/samples:
            No function has been applied.
            No Properties
            Current state:
                * id, state: ...
                * nbr diags: 100
                * 2d indexing: no
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        # title
        if len(folders := {d.file.parent for d in self if d.file is not None}) == 1:
            text = f&#34;DiagramsDataset from the folder {folders.pop()}:&#34;
        else:
            text = &#34;DiagramsDataset:&#34;

        with self._lock:
            # history
            if self._operations_chain:
                text += &#34;\n    Function chain:&#34;
                for i, (func, args) in enumerate(self._operations_chain):
                    args = &#34;, &#34;.join((&#34;diag&#34;,) + tuple(repr(a) for a in args))
                    text += f&#34;\n        {i+1}: [{func.__name__}({args}) for diag in self]&#34;
            else:
                text += &#34;\n    No function has been applied.&#34;

            # properties
            if self._properties:
                text += &#34;\n    Properties:&#34;
                for name, (_, value) in self._properties.items():
                    if len(value_str := str(value).replace(&#34;\n&#34;, &#34;\\n&#34;)) &gt;= 80:
                        value_str = f&#34;&lt;{value.__class__.__name__} object&gt;&#34;
                    text += f&#34;\n        * {name}: {value_str}&#34;
            else:
                text += &#34;\n    No Properties&#34;

            # stats
            text += &#34;\n    Current state:&#34;
            text += f&#34;\n        * id, state: {id(self)}, {self.state}&#34;
            text += f&#34;\n        * nbr diags: {len(self)}&#34;
            if self._position[0] is None:
                text += &#34;\n        * 2d indexing: no&#34;
            else:
                text += f&#34;\n        * 2d indexing: {self._position[0]}&#34;

        return text

    @staticmethod
    def _check_apply(func: typing.Callable[[Diagram], object]) -&gt; bytes:
        &#34;&#34;&#34;Ensure that the function has right input / output.&#34;&#34;&#34;
        assert callable(func), f&#34;`func` has to be callable, not {func.__class__.__name__}&#34;
        try:
            serfunc = cloudpickle.dumps(func)
        except TypeError as err:
            raise AssertionError(f&#34;the function `func` {func} is not pickleable&#34;) from err
        signature = inspect.signature(func)
        assert len(signature.parameters) &gt;= 1, \
            &#34;the function `func` has to take at least 1 parameter&#34;
        parameter = next(iter(signature.parameters.values()))
        assert parameter.kind in {parameter.POSITIONAL_ONLY, parameter.POSITIONAL_OR_KEYWORD}
        if parameter.annotation is parameter.empty:
            warnings.warn(&#34;please specify the input type of `func`&#34;, SyntaxWarning)
        elif parameter.annotation is not Diagram:
            raise AssertionError(
                f&#34;the function `func` has to get a Diagram, not {parameter.annotation}&#34;
            )
        return serfunc

    @staticmethod
    def _check_diag2ind(diag2ind: typing.Callable[[Diagram], numbers.Integral]) -&gt; bytes:
        &#34;&#34;&#34;Ensure that the indexing function has right input / output.&#34;&#34;&#34;
        assert callable(diag2ind), \
            f&#34;`diag2ind` has to be callable, not {diag2ind.__class__.__name__}&#34;
        try:
            serfunc = cloudpickle.dumps(diag2ind)
        except TypeError as err:
            raise AssertionError(f&#34;the function `diag2ind` {diag2ind} is not picklable&#34;) from err
        signature = inspect.signature(diag2ind)
        assert len(signature.parameters) == 1, &#34;the function `diag2ind` has to take 1 parameter&#34;
        parameter = next(iter(signature.parameters.values()))
        assert parameter.kind in {parameter.POSITIONAL_ONLY, parameter.POSITIONAL_OR_KEYWORD}
        if parameter.annotation is parameter.empty:
            warnings.warn(&#34;please specify the input type of `diag2ind`&#34;, SyntaxWarning)
        elif parameter.annotation is not Diagram:
            raise AssertionError(
                f&#34;the function `diag2ind` has to get a Diagram, not {parameter.annotation}&#34;
            )
        if signature.return_annotation is parameter.empty:
            warnings.warn(&#34;please specify the return type of `diag2ind`&#34;, SyntaxWarning)
        elif not issubclass(signature.return_annotation, numbers.Integral):
            raise AssertionError(
                f&#34;the function `diag2ind` has to return int, not {signature.return_annotation}&#34;
            )
        return serfunc

    @staticmethod
    def _check_position(
        position: typing.Callable[[int], tuple[numbers.Real, numbers.Real]]
    ) -&gt; bytes:
        &#34;&#34;&#34;Ensure that the position function has the right input / outputs.&#34;&#34;&#34;
        assert callable(position), \
            f&#34;`position` has to be callable, not {position.__class__.__name__}&#34;
        try:
            serfunc = cloudpickle.dumps(position)
        except TypeError as err:
            raise AssertionError(f&#34;the function `position` {position} is not picklable&#34;) from err
        signature = inspect.signature(position)
        assert len(signature.parameters) == 1, &#34;the function `position` has to take 1 parameter&#34;
        parameter = next(iter(signature.parameters.values()))
        if parameter.annotation is parameter.empty:
            warnings.warn(&#34;please specify the input type of `position`&#34;, SyntaxWarning)
        elif parameter.annotation is not int:
            raise AssertionError(
                f&#34;the function `position` has to get a int, not {parameter.annotation}&#34;
            )
        if signature.return_annotation is parameter.empty:
            warnings.warn(&#34;please specify the return type of `position`&#34;, SyntaxWarning)
        elif (
            signature.return_annotation is not tuple
            and typing.get_origin(signature.return_annotation) is not tuple
        ):
            raise AssertionError(
                f&#34;the function `position` has to return tuple, not {signature.return_annotation}&#34;
            )
        return_args = typing.get_args(signature.return_annotation)
        assert len(return_args) == 2, \
            f&#34;the function `position` has to return 2 elements, not {len(return_args)}&#34;
        assert issubclass(return_args[0], numbers.Real), \
            f&#34;first output element of `position` has to be a real number, not a {return_args[0]}&#34;
        assert issubclass(return_args[1], numbers.Real), \
            f&#34;second output element of `position` has to be a real number, not a {return_args[1]}&#34;
        return serfunc

    def _get_diagram_from_coord(self, first_idx: numbers.Real, second_idx: numbers.Real) -&gt; Diagram:
        &#34;&#34;&#34;Return the closest diagram of the given position.&#34;&#34;&#34;
        assert isinstance(first_idx, numbers.Real), first_idx.__class__.__name__
        assert isinstance(second_idx, numbers.Real), second_idx.__class__.__name__
        with self._lock:
            if isinstance(self._position[1], dict):  # dict to tensor
                coords, indices = zip(*self._position[1].items())
                self._position[1] = (
                    torch.tensor(coords, dtype=torch.float32),
                    torch.tensor(indices, dtype=torch.int64),
                )
            coord = torch.tensor(
                [[first_idx, second_idx]],
                dtype=self._position[1][0].dtype,
                device=self._position[1][0].device,
            )
            dist = torch.sum((self._position[1][0].unsqueeze(0) - coord.unsqueeze(1))**2, dim=2)
            pos = torch.argmin(dist, dim=1).item()
            index = self._position[1][1][pos].item()
        return self._get_diagram_from_index(index)

    def _get_diagram_from_index(self, index: numbers.Integral) -&gt; Diagram:
        &#34;&#34;&#34;Return the diagram of index `index`.&#34;&#34;&#34;
        assert isinstance(index, numbers.Integral), index.__class__.__name__
        if index &lt; 0:
            index += len(self)
            assert index &gt;= 0, &#34;the provided index is to negative&#34;
        index = int(index)
        with self._lock:
            try:
                diagram = self._diagrams[index]
            except KeyError as err:
                raise IndexError(f&#34;The diagram of index {index} is not in the dataset&#34;) from err
            if isinstance(diagram, queue.Queue):
                diagram, nb_ops = diagram.get()  # passive waiting
                for func, args in self._operations_chain[nb_ops:]:  # simple precaution
                    func(diagram, *args)
                self._diagrams[index] = diagram
        return diagram

    def _get_diagrams_from_indices(self, indices: torch.Tensor):
        &#34;&#34;&#34;Return a frozen sub dataset view.&#34;&#34;&#34;
        if (isneg := indices &lt; 0).any():
            with self._lock:
                corrected_indices = indices[isneg] + len(self)
            assert (corrected_indices &gt;= 0).all(), &#34;some provided indices are to negative&#34;
            indices[isneg] = corrected_indices
        diagrams = {i: self._get_diagram_from_index(i) for i in indices.tolist()}
        new_dataset = self.__class__.__new__(self.__class__)
        new_dataset.__setstate__(self.__getstate__())
        new_dataset._diagrams = diagrams  # pylint: disable=W0212
        return new_dataset

    def add_property(self, name: str, value: object, *, erasable: bool = True):
        &#34;&#34;&#34;Add a property to the dataset.

        Parameters
        ----------
        name : str
            The identifiant of the property for the requests.
            If the property is already defined with the same name, the new one erase the older one.
        value
            The property value. If a number is provided, it will be faster.
        erasable : boolean, default=True
            If set to False, the property will be set in stone,
            overwise, the property will desappear as soon as the dataset state changed.
        &#34;&#34;&#34;
        assert isinstance(name, str), name.__class__.__name__
        assert isinstance(erasable, bool), erasable.__class__.__name__
        with self._lock:
            self._properties[name] = ((self.state if erasable else None), value)

    def add_diagram(self, new_diagram: Diagram):
        &#34;&#34;&#34;Append a new diagram into the dataset.

        Parameters
        ----------
        new_diagram : laueimproc.classes.diagram.Diagram
            The new instanciated diagram not already present in the dataset.

        Raises
        ------
        LookupError
            If the diagram is already present in the dataset.
        &#34;&#34;&#34;
        assert isinstance(new_diagram, Diagram), new_diagram.__class__.__name__

        # get and check index
        index = self._diag2ind(new_diagram)
        assert isinstance(index, numbers.Integral), (
            f&#34;the function {self._diag2ind} must return an integer, &#34;
            f&#34;not a {index.__class__.__name__}&#34;
        )
        assert index &gt;= 0, \
            f&#34;the function {self._diag2ind} must return a positive number, not {index}&#34;
        index = int(index)

        # get an check sample position
        if self._position[0] is not None:
            coord = self._position[0](index)
            assert isinstance(coord, tuple), \
                f&#34;the function {self._position[0]} must return a tuple, not {coord}&#34;
            assert len(coord) == 2, \
                f&#34;the function {self._position[0]} must return 2 elements, not {len(coord)}&#34;
            assert isinstance(coord[0], numbers.Real), \
                f&#34;the first element returned by {self._position[0]} must be a number not {coord[0]}&#34;
            assert isinstance(coord[1], numbers.Real), \
                f&#34;the first element returned by {self._position[1]} must be a number not {coord[1]}&#34;
            coord = (float(coord[0]), float(coord[1]))
        else:
            coord = None

        # add diagram and check unicity
        with self._lock:
            if index in self._diagrams:
                raise LookupError(f&#34;the diagram of index {index} is already present in the dataset&#34;)
            if coord is not None:
                if isinstance(self._position[1], tuple):  # tensor to dict
                    self._position[1] = {
                        (x, y): i for (x, y), i in
                        zip(self._position[1][0].tolist(), self._position[1][1].tolist())
                    }
                self._position[1][coord] = index
            if new_diagram.file is not None:
                self._to_sniff[&#34;readed&#34;].add(new_diagram.file)
            if self._operations_chain:
                self._diagrams[index] = queue.Queue()
                thread = _ChainThread(new_diagram, self._operations_chain, self._diagrams[index])
            else:
                self._diagrams[index] = new_diagram
                thread = None
        if thread is not None:
            if len([None for t in threading.enumerate() if isinstance(t, _ChainThread)]) &lt; 3*NCPU:
                thread.start()  # asnyc
                if not self._started.is_set():
                    self.start()
            else:
                thread.run()  # blocking

    def add_diagrams(
        self, new_diagrams: typing.Union[typing.Iterable, Diagram, str, pathlib.Path]
    ):
        &#34;&#34;&#34;Append the new diagrams into the datset.

        Parameters
        ----------
        new_diagrams
            The diagram references, they can be of this natures:

                * laueimproc.classes.diagram.Diagram : Could be a simple Diagram instance.
                * iterable : An iterable of any of the types specified above.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
        &gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
        &gt;&gt;&gt; from laueimproc.io import get_samples
        &gt;&gt;&gt; file = min(get_samples().iterdir())
        &gt;&gt;&gt;
        &gt;&gt;&gt; dataset = DiagramsDataset()
        &gt;&gt;&gt; dataset.add_diagrams(Diagram(file))  # from Diagram instance
        &gt;&gt;&gt; dataset
        &lt;DiagramsDataset with 1 diagrams&gt;
        &gt;&gt;&gt;
        &gt;&gt;&gt; dataset = DiagramsDataset()
        &gt;&gt;&gt; dataset.add_diagrams(file)  # from filename (pathlib)
        &gt;&gt;&gt; dataset
        &lt;DiagramsDataset with 1 diagrams&gt;
        &gt;&gt;&gt; dataset = DiagramsDataset()
        &gt;&gt;&gt; dataset.add_diagrams(str(file))  # from filename (str)
        &gt;&gt;&gt; dataset
        &lt;DiagramsDataset with 1 diagrams&gt;
        &gt;&gt;&gt;
        &gt;&gt;&gt; dataset = DiagramsDataset()
        &gt;&gt;&gt; dataset.add_diagrams(get_samples())  # from folder (pathlib)
        &gt;&gt;&gt; dataset
        &lt;DiagramsDataset with 100 diagrams&gt;
        &gt;&gt;&gt; dataset = DiagramsDataset()
        &gt;&gt;&gt; dataset.add_diagrams(str(get_samples()))  # from folder (str)
        &gt;&gt;&gt; dataset
        &lt;DiagramsDataset with 100 diagrams&gt;
        &gt;&gt;&gt;
        &gt;&gt;&gt; # from iterable (DiagramDataset, list, tuple, ...)
        &gt;&gt;&gt; # ok with nested iterables
        &gt;&gt;&gt; dataset = DiagramsDataset()
        &gt;&gt;&gt; dataset.add_diagrams([Diagram(f) for f in get_samples().iterdir()])
        &gt;&gt;&gt; dataset
        &lt;DiagramsDataset with 100 diagrams&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if isinstance(new_diagrams, Diagram):
            self.add_diagram(new_diagrams)
        elif isinstance(new_diagrams, pathlib.Path):
            new_diagrams.expanduser().resolve()
            assert new_diagrams.exists(), f&#34;{new_diagrams} if not an existing path&#34;
            if new_diagrams.is_dir():
                self.add_diagrams(  # optional, no procrastination
                    f for f in new_diagrams.iterdir()
                    if f.suffix.lower() in {&#34;.jp2&#34;, &#34;.mccd&#34;, &#34;.tif&#34;, &#34;.tiff&#34;}
                )
                self._to_sniff[&#34;dirs&#34;].append([new_diagrams, 0.0])
                if not self._started.is_set():
                    self.start()
            else:
                self.add_diagram(Diagram(new_diagrams))  # case file
        elif isinstance(new_diagrams, (str, bytes)):
            self.add_diagrams(pathlib.Path(new_diagrams))
        elif isinstance(
            new_diagrams, (tuple, list, set, frozenset, typing.Generator, self.__class__)
        ):
            for new_diagram in new_diagrams:
                self.add_diagrams(new_diagram)
        else:
            raise ValueError(f&#34;the `new_diagrams` {new_diagrams} are not recognised&#34;)

    def apply(
        self,
        func: typing.Callable[[Diagram], object],
        args: typing.Optional[tuple] = None,
    ) -&gt; dict[int, object]:
        &#34;&#34;&#34;Apply an operation in all the diagrams of the dataset.

        Parameters
        ----------
        func : callable
            A function that take a diagram and optionaly other parameters, and return anything.
            The function can modify the diagram inplace. It has to be pickaleable.
        args : tuple, optional
            Positional arguments to forward to the provided func.

        Returns
        -------
        res : dict
            The result of the function for each diagrams.
            To each diagram index, associate the result.

        Notes
        -----
        This function will be automaticaly applided on the new diagrams, but the result is throw.

        Examples
        --------
        &gt;&gt;&gt; from pprint import pprint
        &gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
        &gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
        &gt;&gt;&gt; from laueimproc.io import get_samples
        &gt;&gt;&gt; dataset = DiagramsDataset(get_samples())[::10]  # subset to go faster
        &gt;&gt;&gt; def peak_search(diagram: Diagram, density: float) -&gt; int:
        ...     &#39;&#39;&#39;Return the number of spots.&#39;&#39;&#39;
        ...     diagram.find_spots(density=density)
        ...     return len(diagram)
        ...
        &gt;&gt;&gt; res = dataset.apply(peak_search, args=(0.5,))
        &gt;&gt;&gt; pprint(res)
        {0: 204,
         10: 547,
         20: 551,
         30: 477,
         40: 404,
         50: 537,
         60: 2121,
         70: 274,
         80: 271,
         90: 481}
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        # verifications
        func = cloudpickle.loads(self._check_apply(func))
        if args is None:
            args = ()
        else:
            assert isinstance(args, tuple), args.__class__.__name__
            try:
                cloudpickle.dumps(args)
            except TypeError as err:
                raise AssertionError(
                    f&#34;the arguments `args` {args} are not pickleable&#34;
                ) from err

        # apply
        with self._lock:
            idxs = list(self._diagrams)
        idxs_diags = [(i, self._get_diagram_from_index(i)) for i in idxs]
        with self._lock, multiprocessing.pool.ThreadPool(NCPU) as pool:
            res = dict(
                tqdm.tqdm(
                    pool.imap_unordered(
                        lambda idx_diag: (idx_diag[0], func(idx_diag[1], *args)), idxs_diags
                    ),
                    desc=func.__name__,
                    unit=&#34;diag&#34;,
                    total=len(idxs_diags)
                )
            )
            self._operations_chain.append((func, args))

        return res

    def clone(self, **kwargs):
        &#34;&#34;&#34;Instanciate a new identical dataset.

        Parameters
        ----------
        **kwargs : dict
            Transmitted to ``laueimproc.classes.base_diagram.BaseDiagram.clone``.

        Returns
        -------
        DiagramsDataset
            The new copy of self.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
        &gt;&gt;&gt; from laueimproc.io import get_samples
        &gt;&gt;&gt; dataset = DiagramsDataset(get_samples())
        &gt;&gt;&gt; dataset_bis = dataset.clone()
        &gt;&gt;&gt; assert id(dataset) != id(dataset_bis)
        &gt;&gt;&gt; assert dataset.state == dataset_bis.state
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        new_dataset = self.__class__.__new__(self.__class__)
        new_dataset.__setstate__(self.__getstate__())
        new_dataset._diagrams = {  # pylint: disable=W0212
            i: d.clone(**kwargs) for i, d in new_dataset._diagrams.items()  # pylint: disable=W0212
        }
        return new_dataset

    def get_property(self, name: str) -&gt; object:
        &#34;&#34;&#34;Return the property associated to the given id.

        Parameters
        ----------
        name : str
            The name of the property to get.

        Returns
        -------
        property : object
            The property value set with ``add_property``.

        Raises
        ------
        KeyError
            Is the property has never been defined or if the state changed.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
        &gt;&gt;&gt; from laueimproc.io import get_samples
        &gt;&gt;&gt; dataset = DiagramsDataset(get_samples())
        &gt;&gt;&gt; dataset.add_property(&#34;prop1&#34;, value=&#34;any python object 1&#34;, erasable=False)
        &gt;&gt;&gt; dataset.add_property(&#34;prop2&#34;, value=&#34;any python object 2&#34;)
        &gt;&gt;&gt; dataset.get_property(&#34;prop1&#34;)
        &#39;any python object 1&#39;
        &gt;&gt;&gt; dataset.get_property(&#34;prop2&#34;)
        &#39;any python object 2&#39;
        &gt;&gt;&gt; dataset = dataset[:1]  # change state
        &gt;&gt;&gt; dataset.get_property(&#34;prop1&#34;)
        &#39;any python object 1&#39;
        &gt;&gt;&gt; try:
        ...     dataset.get_property(&#34;prop2&#34;)
        ... except KeyError as err:
        ...     print(err)
        ...
        &#34;the property &#39;prop2&#39; is no longer valid because the state of the dataset has changed&#34;
        &gt;&gt;&gt; try:
        ...     dataset.get_property(&#34;prop3&#34;)
        ... except KeyError as err:
        ...     print(err)
        ...
        &#34;the property &#39;prop3&#39; does no exist&#34;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert isinstance(name, str), name.__class__.__name__
        with self._lock:
            try:
                state, value = self._properties[name]
            except KeyError as err:
                raise KeyError(f&#34;the property {repr(name)} does no exist&#34;) from err
        if state is not None and state != self.state:
            # with self._lock:
            #     self._properties[name] = (state, None)
            raise KeyError(
                f&#34;the property {repr(name)} is no longer valid &#34;
                &#34;because the state of the dataset has changed&#34;
            )
        return value

    @property
    def state(self) -&gt; str:
        &#34;&#34;&#34;Return a hash of the dataset.

        If two datasets gots the same state, it means they are the same.
        The hash take in consideration the indices of the diagrams and the functions applyed.
        The retruned value is a hexadecimal string of length 32.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
        &gt;&gt;&gt; from laueimproc.io import get_samples
        &gt;&gt;&gt; dataset = DiagramsDataset(get_samples())
        &gt;&gt;&gt; dataset.state
        &#39;a25b4674e8dbda3caa20b033d02bb1af&#39;
        &gt;&gt;&gt; dataset[:].state
        &#39;a25b4674e8dbda3caa20b033d02bb1af&#39;
        &gt;&gt;&gt; dataset[:1].state
        &#39;e3a17156c95f980f709cea805ac6193d&#39;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        hasher = hashlib.md5(usedforsecurity=False)
        hasher.update(str(sorted(self._diagrams)).encode())
        hasher.update(cloudpickle.dumps(self._diag2ind))
        hasher.update(cloudpickle.dumps(self._position[0]))
        hasher.update(cloudpickle.dumps(self._operations_chain))
        return hasher.hexdigest()

    def run(self):
        &#34;&#34;&#34;Run asynchronousely in a child thread, called by self.start().&#34;&#34;&#34;
        while True:
            # scan if a new diagram has arrived in the folder
            for directory_time in self._to_sniff[&#34;dirs&#34;]:
                if directory_time[0].stat().st_mtime == directory_time[1]:
                    continue
                directory_time[1] = directory_time[0].stat().st_mtime
                for file in directory_time[0].iterdir():
                    if (
                        file in self._to_sniff[&#34;readed&#34;]
                        or file.suffix.lower() not in {&#34;.jp2&#34;, &#34;.mccd&#34;, &#34;.tif&#34;, &#34;.tiff&#34;}
                    ):
                        continue
                    diagram = Diagram(file)
                    self.add_diagram(diagram)  # update self._to_sniff[&#34;readed&#34;]

            # # make accessible the just borned diagrams
            # with self._lock:
            #     for idx in list(self._diagrams):  # copy for allowing modification
            #         if not isinstance(self._diagrams[idx], queue.Queue):
            #             continue
            #         try:
            #             diagram, nb_ops = self._diagrams[idx].get_nowait()
            #         except queue.Empty:
            #             continue
            #         if nb_ops != len(self._operations_chain):  # if apply called during thread run
            #             for func, args in self._operations_chain[nb_ops:]:
            #                 func(diagram, *args)
            #         self._diagrams[idx] = diagram

            time.sleep(10)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>threading.Thread</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="laueimproc.classes.DiagramsDataset.state"><code class="name">var <span class="ident">state</span> : str</code></dt>
<dd>
<div class="desc"><p>Return a hash of the dataset.</p>
<p>If two datasets gots the same state, it means they are the same.
The hash take in consideration the indices of the diagrams and the functions applyed.
The retruned value is a hexadecimal string of length 32.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
&gt;&gt;&gt; from laueimproc.io import get_samples
&gt;&gt;&gt; dataset = DiagramsDataset(get_samples())
&gt;&gt;&gt; dataset.state
'a25b4674e8dbda3caa20b033d02bb1af'
&gt;&gt;&gt; dataset[:].state
'a25b4674e8dbda3caa20b033d02bb1af'
&gt;&gt;&gt; dataset[:1].state
'e3a17156c95f980f709cea805ac6193d'
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state(self) -&gt; str:
    &#34;&#34;&#34;Return a hash of the dataset.

    If two datasets gots the same state, it means they are the same.
    The hash take in consideration the indices of the diagrams and the functions applyed.
    The retruned value is a hexadecimal string of length 32.

    Examples
    --------
    &gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
    &gt;&gt;&gt; from laueimproc.io import get_samples
    &gt;&gt;&gt; dataset = DiagramsDataset(get_samples())
    &gt;&gt;&gt; dataset.state
    &#39;a25b4674e8dbda3caa20b033d02bb1af&#39;
    &gt;&gt;&gt; dataset[:].state
    &#39;a25b4674e8dbda3caa20b033d02bb1af&#39;
    &gt;&gt;&gt; dataset[:1].state
    &#39;e3a17156c95f980f709cea805ac6193d&#39;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    hasher = hashlib.md5(usedforsecurity=False)
    hasher.update(str(sorted(self._diagrams)).encode())
    hasher.update(cloudpickle.dumps(self._diag2ind))
    hasher.update(cloudpickle.dumps(self._position[0]))
    hasher.update(cloudpickle.dumps(self._operations_chain))
    return hasher.hexdigest()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="laueimproc.classes.DiagramsDataset.add_diagram"><code class="name flex">
<span>def <span class="ident">add_diagram</span></span>(<span>self, new_diagram: <a title="laueimproc.classes.diagram.Diagram" href="diagram.html#laueimproc.classes.diagram.Diagram">Diagram</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Append a new diagram into the dataset.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>new_diagram</code></strong> :&ensp;<code><a title="laueimproc.classes.diagram.Diagram" href="diagram.html#laueimproc.classes.diagram.Diagram">Diagram</a></code></dt>
<dd>The new instanciated diagram not already present in the dataset.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>LookupError</code></dt>
<dd>If the diagram is already present in the dataset.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_diagram(self, new_diagram: Diagram):
    &#34;&#34;&#34;Append a new diagram into the dataset.

    Parameters
    ----------
    new_diagram : laueimproc.classes.diagram.Diagram
        The new instanciated diagram not already present in the dataset.

    Raises
    ------
    LookupError
        If the diagram is already present in the dataset.
    &#34;&#34;&#34;
    assert isinstance(new_diagram, Diagram), new_diagram.__class__.__name__

    # get and check index
    index = self._diag2ind(new_diagram)
    assert isinstance(index, numbers.Integral), (
        f&#34;the function {self._diag2ind} must return an integer, &#34;
        f&#34;not a {index.__class__.__name__}&#34;
    )
    assert index &gt;= 0, \
        f&#34;the function {self._diag2ind} must return a positive number, not {index}&#34;
    index = int(index)

    # get an check sample position
    if self._position[0] is not None:
        coord = self._position[0](index)
        assert isinstance(coord, tuple), \
            f&#34;the function {self._position[0]} must return a tuple, not {coord}&#34;
        assert len(coord) == 2, \
            f&#34;the function {self._position[0]} must return 2 elements, not {len(coord)}&#34;
        assert isinstance(coord[0], numbers.Real), \
            f&#34;the first element returned by {self._position[0]} must be a number not {coord[0]}&#34;
        assert isinstance(coord[1], numbers.Real), \
            f&#34;the first element returned by {self._position[1]} must be a number not {coord[1]}&#34;
        coord = (float(coord[0]), float(coord[1]))
    else:
        coord = None

    # add diagram and check unicity
    with self._lock:
        if index in self._diagrams:
            raise LookupError(f&#34;the diagram of index {index} is already present in the dataset&#34;)
        if coord is not None:
            if isinstance(self._position[1], tuple):  # tensor to dict
                self._position[1] = {
                    (x, y): i for (x, y), i in
                    zip(self._position[1][0].tolist(), self._position[1][1].tolist())
                }
            self._position[1][coord] = index
        if new_diagram.file is not None:
            self._to_sniff[&#34;readed&#34;].add(new_diagram.file)
        if self._operations_chain:
            self._diagrams[index] = queue.Queue()
            thread = _ChainThread(new_diagram, self._operations_chain, self._diagrams[index])
        else:
            self._diagrams[index] = new_diagram
            thread = None
    if thread is not None:
        if len([None for t in threading.enumerate() if isinstance(t, _ChainThread)]) &lt; 3*NCPU:
            thread.start()  # asnyc
            if not self._started.is_set():
                self.start()
        else:
            thread.run()  # blocking</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.DiagramsDataset.add_diagrams"><code class="name flex">
<span>def <span class="ident">add_diagrams</span></span>(<span>self, new_diagrams: Union[Iterable, <a title="laueimproc.classes.diagram.Diagram" href="diagram.html#laueimproc.classes.diagram.Diagram">Diagram</a>, str, pathlib.Path])</span>
</code></dt>
<dd>
<div class="desc"><p>Append the new diagrams into the datset.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>new_diagrams</code></strong></dt>
<dd>The diagram references, they can be of this natures:<pre><code>* laueimproc.classes.diagram.Diagram : Could be a simple Diagram instance.
* iterable : An iterable of any of the types specified above.
</code></pre>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
&gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
&gt;&gt;&gt; from laueimproc.io import get_samples
&gt;&gt;&gt; file = min(get_samples().iterdir())
&gt;&gt;&gt;
&gt;&gt;&gt; dataset = DiagramsDataset()
&gt;&gt;&gt; dataset.add_diagrams(Diagram(file))  # from Diagram instance
&gt;&gt;&gt; dataset
&lt;DiagramsDataset with 1 diagrams&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; dataset = DiagramsDataset()
&gt;&gt;&gt; dataset.add_diagrams(file)  # from filename (pathlib)
&gt;&gt;&gt; dataset
&lt;DiagramsDataset with 1 diagrams&gt;
&gt;&gt;&gt; dataset = DiagramsDataset()
&gt;&gt;&gt; dataset.add_diagrams(str(file))  # from filename (str)
&gt;&gt;&gt; dataset
&lt;DiagramsDataset with 1 diagrams&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; dataset = DiagramsDataset()
&gt;&gt;&gt; dataset.add_diagrams(get_samples())  # from folder (pathlib)
&gt;&gt;&gt; dataset
&lt;DiagramsDataset with 100 diagrams&gt;
&gt;&gt;&gt; dataset = DiagramsDataset()
&gt;&gt;&gt; dataset.add_diagrams(str(get_samples()))  # from folder (str)
&gt;&gt;&gt; dataset
&lt;DiagramsDataset with 100 diagrams&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; # from iterable (DiagramDataset, list, tuple, ...)
&gt;&gt;&gt; # ok with nested iterables
&gt;&gt;&gt; dataset = DiagramsDataset()
&gt;&gt;&gt; dataset.add_diagrams([Diagram(f) for f in get_samples().iterdir()])
&gt;&gt;&gt; dataset
&lt;DiagramsDataset with 100 diagrams&gt;
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_diagrams(
    self, new_diagrams: typing.Union[typing.Iterable, Diagram, str, pathlib.Path]
):
    &#34;&#34;&#34;Append the new diagrams into the datset.

    Parameters
    ----------
    new_diagrams
        The diagram references, they can be of this natures:

            * laueimproc.classes.diagram.Diagram : Could be a simple Diagram instance.
            * iterable : An iterable of any of the types specified above.

    Examples
    --------
    &gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
    &gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
    &gt;&gt;&gt; from laueimproc.io import get_samples
    &gt;&gt;&gt; file = min(get_samples().iterdir())
    &gt;&gt;&gt;
    &gt;&gt;&gt; dataset = DiagramsDataset()
    &gt;&gt;&gt; dataset.add_diagrams(Diagram(file))  # from Diagram instance
    &gt;&gt;&gt; dataset
    &lt;DiagramsDataset with 1 diagrams&gt;
    &gt;&gt;&gt;
    &gt;&gt;&gt; dataset = DiagramsDataset()
    &gt;&gt;&gt; dataset.add_diagrams(file)  # from filename (pathlib)
    &gt;&gt;&gt; dataset
    &lt;DiagramsDataset with 1 diagrams&gt;
    &gt;&gt;&gt; dataset = DiagramsDataset()
    &gt;&gt;&gt; dataset.add_diagrams(str(file))  # from filename (str)
    &gt;&gt;&gt; dataset
    &lt;DiagramsDataset with 1 diagrams&gt;
    &gt;&gt;&gt;
    &gt;&gt;&gt; dataset = DiagramsDataset()
    &gt;&gt;&gt; dataset.add_diagrams(get_samples())  # from folder (pathlib)
    &gt;&gt;&gt; dataset
    &lt;DiagramsDataset with 100 diagrams&gt;
    &gt;&gt;&gt; dataset = DiagramsDataset()
    &gt;&gt;&gt; dataset.add_diagrams(str(get_samples()))  # from folder (str)
    &gt;&gt;&gt; dataset
    &lt;DiagramsDataset with 100 diagrams&gt;
    &gt;&gt;&gt;
    &gt;&gt;&gt; # from iterable (DiagramDataset, list, tuple, ...)
    &gt;&gt;&gt; # ok with nested iterables
    &gt;&gt;&gt; dataset = DiagramsDataset()
    &gt;&gt;&gt; dataset.add_diagrams([Diagram(f) for f in get_samples().iterdir()])
    &gt;&gt;&gt; dataset
    &lt;DiagramsDataset with 100 diagrams&gt;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    if isinstance(new_diagrams, Diagram):
        self.add_diagram(new_diagrams)
    elif isinstance(new_diagrams, pathlib.Path):
        new_diagrams.expanduser().resolve()
        assert new_diagrams.exists(), f&#34;{new_diagrams} if not an existing path&#34;
        if new_diagrams.is_dir():
            self.add_diagrams(  # optional, no procrastination
                f for f in new_diagrams.iterdir()
                if f.suffix.lower() in {&#34;.jp2&#34;, &#34;.mccd&#34;, &#34;.tif&#34;, &#34;.tiff&#34;}
            )
            self._to_sniff[&#34;dirs&#34;].append([new_diagrams, 0.0])
            if not self._started.is_set():
                self.start()
        else:
            self.add_diagram(Diagram(new_diagrams))  # case file
    elif isinstance(new_diagrams, (str, bytes)):
        self.add_diagrams(pathlib.Path(new_diagrams))
    elif isinstance(
        new_diagrams, (tuple, list, set, frozenset, typing.Generator, self.__class__)
    ):
        for new_diagram in new_diagrams:
            self.add_diagrams(new_diagram)
    else:
        raise ValueError(f&#34;the `new_diagrams` {new_diagrams} are not recognised&#34;)</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.DiagramsDataset.add_property"><code class="name flex">
<span>def <span class="ident">add_property</span></span>(<span>self, name: str, value: object, *, erasable: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a property to the dataset.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The identifiant of the property for the requests.
If the property is already defined with the same name, the new one erase the older one.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The property value. If a number is provided, it will be faster.</dd>
<dt><strong><code>erasable</code></strong> :&ensp;<code>boolean</code>, default=<code>True</code></dt>
<dd>If set to False, the property will be set in stone,
overwise, the property will desappear as soon as the dataset state changed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_property(self, name: str, value: object, *, erasable: bool = True):
    &#34;&#34;&#34;Add a property to the dataset.

    Parameters
    ----------
    name : str
        The identifiant of the property for the requests.
        If the property is already defined with the same name, the new one erase the older one.
    value
        The property value. If a number is provided, it will be faster.
    erasable : boolean, default=True
        If set to False, the property will be set in stone,
        overwise, the property will desappear as soon as the dataset state changed.
    &#34;&#34;&#34;
    assert isinstance(name, str), name.__class__.__name__
    assert isinstance(erasable, bool), erasable.__class__.__name__
    with self._lock:
        self._properties[name] = ((self.state if erasable else None), value)</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.DiagramsDataset.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, func: Callable[[<a title="laueimproc.classes.diagram.Diagram" href="diagram.html#laueimproc.classes.diagram.Diagram">Diagram</a>], object], args: Optional[tuple] = None) ‑> dict[int, object]</span>
</code></dt>
<dd>
<div class="desc"><p>Apply an operation in all the diagrams of the dataset.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>callable</code></dt>
<dd>A function that take a diagram and optionaly other parameters, and return anything.
The function can modify the diagram inplace. It has to be pickaleable.</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>Positional arguments to forward to the provided func.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>res</code></strong> :&ensp;<code>dict</code></dt>
<dd>The result of the function for each diagrams.
To each diagram index, associate the result.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This function will be automaticaly applided on the new diagrams, but the result is throw.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
&gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
&gt;&gt;&gt; from laueimproc.io import get_samples
&gt;&gt;&gt; dataset = DiagramsDataset(get_samples())[::10]  # subset to go faster
&gt;&gt;&gt; def peak_search(diagram: Diagram, density: float) -&gt; int:
...     '''Return the number of spots.'''
...     diagram.find_spots(density=density)
...     return len(diagram)
...
&gt;&gt;&gt; res = dataset.apply(peak_search, args=(0.5,))
&gt;&gt;&gt; pprint(res)
{0: 204,
 10: 547,
 20: 551,
 30: 477,
 40: 404,
 50: 537,
 60: 2121,
 70: 274,
 80: 271,
 90: 481}
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(
    self,
    func: typing.Callable[[Diagram], object],
    args: typing.Optional[tuple] = None,
) -&gt; dict[int, object]:
    &#34;&#34;&#34;Apply an operation in all the diagrams of the dataset.

    Parameters
    ----------
    func : callable
        A function that take a diagram and optionaly other parameters, and return anything.
        The function can modify the diagram inplace. It has to be pickaleable.
    args : tuple, optional
        Positional arguments to forward to the provided func.

    Returns
    -------
    res : dict
        The result of the function for each diagrams.
        To each diagram index, associate the result.

    Notes
    -----
    This function will be automaticaly applided on the new diagrams, but the result is throw.

    Examples
    --------
    &gt;&gt;&gt; from pprint import pprint
    &gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
    &gt;&gt;&gt; from laueimproc.classes.diagram import Diagram
    &gt;&gt;&gt; from laueimproc.io import get_samples
    &gt;&gt;&gt; dataset = DiagramsDataset(get_samples())[::10]  # subset to go faster
    &gt;&gt;&gt; def peak_search(diagram: Diagram, density: float) -&gt; int:
    ...     &#39;&#39;&#39;Return the number of spots.&#39;&#39;&#39;
    ...     diagram.find_spots(density=density)
    ...     return len(diagram)
    ...
    &gt;&gt;&gt; res = dataset.apply(peak_search, args=(0.5,))
    &gt;&gt;&gt; pprint(res)
    {0: 204,
     10: 547,
     20: 551,
     30: 477,
     40: 404,
     50: 537,
     60: 2121,
     70: 274,
     80: 271,
     90: 481}
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    # verifications
    func = cloudpickle.loads(self._check_apply(func))
    if args is None:
        args = ()
    else:
        assert isinstance(args, tuple), args.__class__.__name__
        try:
            cloudpickle.dumps(args)
        except TypeError as err:
            raise AssertionError(
                f&#34;the arguments `args` {args} are not pickleable&#34;
            ) from err

    # apply
    with self._lock:
        idxs = list(self._diagrams)
    idxs_diags = [(i, self._get_diagram_from_index(i)) for i in idxs]
    with self._lock, multiprocessing.pool.ThreadPool(NCPU) as pool:
        res = dict(
            tqdm.tqdm(
                pool.imap_unordered(
                    lambda idx_diag: (idx_diag[0], func(idx_diag[1], *args)), idxs_diags
                ),
                desc=func.__name__,
                unit=&#34;diag&#34;,
                total=len(idxs_diags)
            )
        )
        self._operations_chain.append((func, args))

    return res</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.DiagramsDataset.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Instanciate a new identical dataset.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Transmitted to <code><a title="laueimproc.classes.base_diagram.BaseDiagram.clone" href="base_diagram.html#laueimproc.classes.base_diagram.BaseDiagram.clone">BaseDiagram.clone()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="laueimproc.classes.DiagramsDataset" href="#laueimproc.classes.DiagramsDataset">DiagramsDataset</a></code></dt>
<dd>The new copy of self.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
&gt;&gt;&gt; from laueimproc.io import get_samples
&gt;&gt;&gt; dataset = DiagramsDataset(get_samples())
&gt;&gt;&gt; dataset_bis = dataset.clone()
&gt;&gt;&gt; assert id(dataset) != id(dataset_bis)
&gt;&gt;&gt; assert dataset.state == dataset_bis.state
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clone(self, **kwargs):
    &#34;&#34;&#34;Instanciate a new identical dataset.

    Parameters
    ----------
    **kwargs : dict
        Transmitted to ``laueimproc.classes.base_diagram.BaseDiagram.clone``.

    Returns
    -------
    DiagramsDataset
        The new copy of self.

    Examples
    --------
    &gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
    &gt;&gt;&gt; from laueimproc.io import get_samples
    &gt;&gt;&gt; dataset = DiagramsDataset(get_samples())
    &gt;&gt;&gt; dataset_bis = dataset.clone()
    &gt;&gt;&gt; assert id(dataset) != id(dataset_bis)
    &gt;&gt;&gt; assert dataset.state == dataset_bis.state
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    new_dataset = self.__class__.__new__(self.__class__)
    new_dataset.__setstate__(self.__getstate__())
    new_dataset._diagrams = {  # pylint: disable=W0212
        i: d.clone(**kwargs) for i, d in new_dataset._diagrams.items()  # pylint: disable=W0212
    }
    return new_dataset</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.DiagramsDataset.get_property"><code class="name flex">
<span>def <span class="ident">get_property</span></span>(<span>self, name: str) ‑> object</span>
</code></dt>
<dd>
<div class="desc"><p>Return the property associated to the given id.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the property to get.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>property</code></strong> :&ensp;<code>object</code></dt>
<dd>The property value set with <code>add_property</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>Is the property has never been defined or if the state changed.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
&gt;&gt;&gt; from laueimproc.io import get_samples
&gt;&gt;&gt; dataset = DiagramsDataset(get_samples())
&gt;&gt;&gt; dataset.add_property(&quot;prop1&quot;, value=&quot;any python object 1&quot;, erasable=False)
&gt;&gt;&gt; dataset.add_property(&quot;prop2&quot;, value=&quot;any python object 2&quot;)
&gt;&gt;&gt; dataset.get_property(&quot;prop1&quot;)
'any python object 1'
&gt;&gt;&gt; dataset.get_property(&quot;prop2&quot;)
'any python object 2'
&gt;&gt;&gt; dataset = dataset[:1]  # change state
&gt;&gt;&gt; dataset.get_property(&quot;prop1&quot;)
'any python object 1'
&gt;&gt;&gt; try:
...     dataset.get_property(&quot;prop2&quot;)
... except KeyError as err:
...     print(err)
...
&quot;the property 'prop2' is no longer valid because the state of the dataset has changed&quot;
&gt;&gt;&gt; try:
...     dataset.get_property(&quot;prop3&quot;)
... except KeyError as err:
...     print(err)
...
&quot;the property 'prop3' does no exist&quot;
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_property(self, name: str) -&gt; object:
    &#34;&#34;&#34;Return the property associated to the given id.

    Parameters
    ----------
    name : str
        The name of the property to get.

    Returns
    -------
    property : object
        The property value set with ``add_property``.

    Raises
    ------
    KeyError
        Is the property has never been defined or if the state changed.

    Examples
    --------
    &gt;&gt;&gt; from laueimproc.classes.dataset import DiagramsDataset
    &gt;&gt;&gt; from laueimproc.io import get_samples
    &gt;&gt;&gt; dataset = DiagramsDataset(get_samples())
    &gt;&gt;&gt; dataset.add_property(&#34;prop1&#34;, value=&#34;any python object 1&#34;, erasable=False)
    &gt;&gt;&gt; dataset.add_property(&#34;prop2&#34;, value=&#34;any python object 2&#34;)
    &gt;&gt;&gt; dataset.get_property(&#34;prop1&#34;)
    &#39;any python object 1&#39;
    &gt;&gt;&gt; dataset.get_property(&#34;prop2&#34;)
    &#39;any python object 2&#39;
    &gt;&gt;&gt; dataset = dataset[:1]  # change state
    &gt;&gt;&gt; dataset.get_property(&#34;prop1&#34;)
    &#39;any python object 1&#39;
    &gt;&gt;&gt; try:
    ...     dataset.get_property(&#34;prop2&#34;)
    ... except KeyError as err:
    ...     print(err)
    ...
    &#34;the property &#39;prop2&#39; is no longer valid because the state of the dataset has changed&#34;
    &gt;&gt;&gt; try:
    ...     dataset.get_property(&#34;prop3&#34;)
    ... except KeyError as err:
    ...     print(err)
    ...
    &#34;the property &#39;prop3&#39; does no exist&#34;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(name, str), name.__class__.__name__
    with self._lock:
        try:
            state, value = self._properties[name]
        except KeyError as err:
            raise KeyError(f&#34;the property {repr(name)} does no exist&#34;) from err
    if state is not None and state != self.state:
        # with self._lock:
        #     self._properties[name] = (state, None)
        raise KeyError(
            f&#34;the property {repr(name)} is no longer valid &#34;
            &#34;because the state of the dataset has changed&#34;
        )
    return value</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.DiagramsDataset.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run asynchronousely in a child thread, called by self.start().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;Run asynchronousely in a child thread, called by self.start().&#34;&#34;&#34;
    while True:
        # scan if a new diagram has arrived in the folder
        for directory_time in self._to_sniff[&#34;dirs&#34;]:
            if directory_time[0].stat().st_mtime == directory_time[1]:
                continue
            directory_time[1] = directory_time[0].stat().st_mtime
            for file in directory_time[0].iterdir():
                if (
                    file in self._to_sniff[&#34;readed&#34;]
                    or file.suffix.lower() not in {&#34;.jp2&#34;, &#34;.mccd&#34;, &#34;.tif&#34;, &#34;.tiff&#34;}
                ):
                    continue
                diagram = Diagram(file)
                self.add_diagram(diagram)  # update self._to_sniff[&#34;readed&#34;]

        # # make accessible the just borned diagrams
        # with self._lock:
        #     for idx in list(self._diagrams):  # copy for allowing modification
        #         if not isinstance(self._diagrams[idx], queue.Queue):
        #             continue
        #         try:
        #             diagram, nb_ops = self._diagrams[idx].get_nowait()
        #         except queue.Empty:
        #             continue
        #         if nb_ops != len(self._operations_chain):  # if apply called during thread run
        #             for func, args in self._operations_chain[nb_ops:]:
        #                 func(diagram, *args)
        #         self._diagrams[idx] = diagram

        time.sleep(10)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="laueimproc" href="../index.html">laueimproc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="laueimproc.classes.base_diagram" href="base_diagram.html">laueimproc.classes.base_diagram</a></code></li>
<li><code><a title="laueimproc.classes.dataset" href="dataset.html">laueimproc.classes.dataset</a></code></li>
<li><code><a title="laueimproc.classes.diagram" href="diagram.html">laueimproc.classes.diagram</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="laueimproc.classes.Diagram" href="#laueimproc.classes.Diagram">Diagram</a></code></h4>
<ul class="">
<li><code><a title="laueimproc.classes.Diagram.compute_rois_centroid" href="#laueimproc.classes.Diagram.compute_rois_centroid">compute_rois_centroid</a></code></li>
<li><code><a title="laueimproc.classes.Diagram.compute_rois_max" href="#laueimproc.classes.Diagram.compute_rois_max">compute_rois_max</a></code></li>
<li><code><a title="laueimproc.classes.Diagram.compute_rois_nb_peaks" href="#laueimproc.classes.Diagram.compute_rois_nb_peaks">compute_rois_nb_peaks</a></code></li>
<li><code><a title="laueimproc.classes.Diagram.compute_rois_pca" href="#laueimproc.classes.Diagram.compute_rois_pca">compute_rois_pca</a></code></li>
<li><code><a title="laueimproc.classes.Diagram.compute_rois_sum" href="#laueimproc.classes.Diagram.compute_rois_sum">compute_rois_sum</a></code></li>
<li><code><a title="laueimproc.classes.Diagram.fit_gaussian" href="#laueimproc.classes.Diagram.fit_gaussian">fit_gaussian</a></code></li>
<li><code><a title="laueimproc.classes.Diagram.fit_gaussian_em" href="#laueimproc.classes.Diagram.fit_gaussian_em">fit_gaussian_em</a></code></li>
<li><code><a title="laueimproc.classes.Diagram.fit_gaussians" href="#laueimproc.classes.Diagram.fit_gaussians">fit_gaussians</a></code></li>
<li><code><a title="laueimproc.classes.Diagram.fit_gaussians_em" href="#laueimproc.classes.Diagram.fit_gaussians_em">fit_gaussians_em</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="laueimproc.classes.DiagramsDataset" href="#laueimproc.classes.DiagramsDataset">DiagramsDataset</a></code></h4>
<ul class="two-column">
<li><code><a title="laueimproc.classes.DiagramsDataset.add_diagram" href="#laueimproc.classes.DiagramsDataset.add_diagram">add_diagram</a></code></li>
<li><code><a title="laueimproc.classes.DiagramsDataset.add_diagrams" href="#laueimproc.classes.DiagramsDataset.add_diagrams">add_diagrams</a></code></li>
<li><code><a title="laueimproc.classes.DiagramsDataset.add_property" href="#laueimproc.classes.DiagramsDataset.add_property">add_property</a></code></li>
<li><code><a title="laueimproc.classes.DiagramsDataset.apply" href="#laueimproc.classes.DiagramsDataset.apply">apply</a></code></li>
<li><code><a title="laueimproc.classes.DiagramsDataset.clone" href="#laueimproc.classes.DiagramsDataset.clone">clone</a></code></li>
<li><code><a title="laueimproc.classes.DiagramsDataset.get_property" href="#laueimproc.classes.DiagramsDataset.get_property">get_property</a></code></li>
<li><code><a title="laueimproc.classes.DiagramsDataset.run" href="#laueimproc.classes.DiagramsDataset.run">run</a></code></li>
<li><code><a title="laueimproc.classes.DiagramsDataset.state" href="#laueimproc.classes.DiagramsDataset.state">state</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>