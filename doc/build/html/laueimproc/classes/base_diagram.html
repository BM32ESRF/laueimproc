<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>laueimproc.classes.base_diagram API documentation</title>
<meta name="description" content="Define the pytonic structure of a basic Diagram." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>laueimproc.classes.base_diagram</code></h1>
</header>
<section id="section-intro">
<p>Define the pytonic structure of a basic Diagram.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#34;&#34;&#34;Define the pytonic structure of a basic Diagram.&#34;&#34;&#34;

import functools
import hashlib
import math
import numbers
import pathlib
import pickle
import re
import sys
import threading
import typing
import warnings

import numpy as np
import torch

from laueimproc.common import bytes2human
from laueimproc.improc.peaks_search import peaks_search
from laueimproc.io.read import read_image, to_floattensor
from laueimproc.opti.cache import CacheManager, getsizeof
from laueimproc.opti.rois import filter_by_indices
from laueimproc.opti.rois import imgbboxes2raw
from laueimproc.opti.rois import rawshapes2rois


def check_init(meth: typing.Callable) -&gt; typing.Callable:
    &#34;&#34;&#34;Decorate a Diagram method to ensure the diagram has been init.&#34;&#34;&#34;
    assert callable(meth), meth.__class__.__name__

    @functools.wraps(meth)
    def check_init_meth(diagram, *args, **kwargs):
        if not diagram.is_init():
            raise RuntimeError(
                f&#34;before calling the {meth} diagram method, initialize the diagram &#34;
                f&#34;{repr(diagram)} by invoking &#39;find_spots&#39; or &#39;set_spots&#39;&#34;
            )
        return meth(diagram, *args, **kwargs)

    return check_init_meth


class BaseDiagram:
    &#34;&#34;&#34;A Basic diagram with the fondamental structure.

    Attributes
    ----------
    areas : torch.Tensor
        The int32 area of each bboxes.
        Return None until spots are initialized.
    bboxes : torch.Tensor or None
        The int16 tensor of the bounding boxes (anchor_i, anchor_j, height, width)
        for each spots, of shape (n, 4) (readonly).
        Return None until spots are initialized.
    file : pathlib.Path or None
        The absolute file path to the image if provided, None otherwise (readonly).
    history : list[str]
        The actions performed on the Diagram from the initialisation (readonly).
    image : torch.Tensor
        The complete brut image of the diagram (readonly).
    rawrois : torch.Tensor or None
        The tensor of the raw regions of interest for each spots (readonly).
        Return None until spots are initialized. The shape is (n, h, w).
        Contrary to `self.rois`, it is only a view of `self.image`.
    rois : torch.Tensor or None
        The tensor of the provided regions of interest for each spots (readonly).
        For writing, use `self.find_spost(...)` or  `self.set_spots(...)`.
        Return None until spots are initialized. The shape is (n, h, w).
    &#34;&#34;&#34;

    def __init__(
        self,
        data: typing.Union[np.ndarray, torch.Tensor, str, pathlib.Path],
        *,
        _check: bool = True,
    ):
        &#34;&#34;&#34;Create a new diagram with appropriated metadata.

        Parameters
        ----------
        data : pathlike or arraylike
            The filename or the array/tensor use as a diagram.
            For memory management, it is better to provide a pathlike rather than an array.
        &#34;&#34;&#34;
        # declaration
        self._cache: tuple[threading.Lock, dict[str]] = (  # contains the optional cached data
            threading.Lock(), {}
        )
        self._file_or_data: typing.Union[pathlib.Path, torch.Tensor]  # the path to the image file
        self._history: list[str] = []  # the history of the actions performed
        self._properties: dict[str, tuple[typing.Union[None, str], object]] = {}  # the properties
        self._rois: typing.Optional[tuple[bytearray, torch.Tensor]] = None  # datarois, bboxes
        self._rois_lock = threading.Lock()  # make the rois acces thread safe

        # initialisation
        if isinstance(data, (str, pathlib.Path)):
            self._file_or_data = data
            if _check:
                self._file_or_data = pathlib.Path(self._file_or_data).expanduser().resolve()
                assert self._file_or_data.is_file(), self._file_or_data
        else:
            warnings.warn(&#34;please provide a path rather than an array&#34;, RuntimeWarning)
            self._file_or_data = to_floattensor(data)
            assert self._file_or_data.ndim == 2, self._file_or_data.shape

    def __getstate__(self, cache: bool = False):
        &#34;&#34;&#34;Make the diagram pickleable.&#34;&#34;&#34;
        with self._rois_lock:
            rois = None if self._rois is None else (self._rois[0].copy(), self._rois[1].clone())
        if cache:
            with self._cache[0]:
                return (
                    self._file_or_data,
                    self._history,
                    self._properties,
                    rois,
                    self._cache[1].copy(),
                )
        return (
            self._file_or_data,
            self._history,
            self._properties,
            rois,
        )

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Return the nbr of spots or 0.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; len(diagram)
        0
        &gt;&gt;&gt; diagram.find_spots()
        &gt;&gt;&gt; len(diagram)
        240
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        try:  # it doesn&#39;t matter if acces is not thread safe
            return len(self._rois[1])
        except TypeError:
            return 0

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Give a very compact representation.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; BaseDiagram(get_sample())
        BaseDiagram(ge.jp2)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if self.file is None:
            return f&#34;{self.__class__.__name__}(Tensor(...))&#34;
        return f&#34;{self.__class__.__name__}({self.file.name})&#34;

    def __setstate__(self, state: tuple):
        &#34;&#34;&#34;Fill the internal attributes.

        Usefull for pickle.

        Notes
        -----
        * No verification is made because the user is not supposed to call this method.

        Examples
        --------
        &gt;&gt;&gt; import pickle
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram_bis = pickle.loads(pickle.dumps(diagram))
        &gt;&gt;&gt; assert id(diagram) != id(diagram_bis)
        &gt;&gt;&gt; assert diagram.state == diagram_bis.state
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        # not verification for thread safe
        # because this method is never meant to be call from a thread.
        (
            self._file_or_data,
            self._history,
            self._properties,
            self._rois,
        ) = state[:4]
        self._cache = (threading.Lock(), (state[4] if len(state) == 5 else {}))
        self._rois_lock = threading.Lock()
        CacheManager().track(self)

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Return a nice sumary of the history of this diagram.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; print(BaseDiagram(get_sample()))  # doctest: +ELLIPSIS
        Diagram from ge.jp2:
            History empty, please initialize the spots `self.find_spots()`.
            No Properties
            Current state:
                * id, state: ...
                * total mem: ...
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        # title
        text = (
            f&#34;Diagram from {self._file_or_data.name}:&#34;
            if isinstance(self._file_or_data, pathlib.Path) else
            f&#34;Diagram from Tensor of id {id(self._file_or_data)}:&#34;
        )

        # history
        if self.is_init():
            text += &#34;\n    History:&#34;
            for i, history in enumerate(self.history):  # not ._history to be updated
                text += f&#34;\n        {i+1}. {history}&#34;
        else:
            text += &#34;\n    History empty, please initialize the spots `self.find_spots()`.&#34;

        # properties
        properties = []
        for name in sorted(self._properties):
            try:
                properties.append((name, self.get_property(name)))
            except KeyError:
                pass
        if properties:
            text += &#34;\n    Properties:&#34;
            for name, value in properties:
                if len(value_str := str(value).replace(&#34;\n&#34;, &#34;\\n&#34;)) &gt;= 80:
                    value_str = f&#34;&lt;{value.__class__.__name__} object&gt;&#34;
                text += f&#34;\n        * {name}: {value_str}&#34;
        else:
            text += &#34;\n    No Properties&#34;

        # stats
        text += &#34;\n    Current state:&#34;
        text += f&#34;\n        * id, state: {id(self)}, {self.state}&#34;
        if self.is_init():
            text += f&#34;\n        * nbr spots: {len(self)}&#34;
        with self._cache[0], self._rois_lock:
            size = sys.getsizeof(self) + sum(getsizeof(e) for e in self.__dict__.values())
        text += f&#34;\n        * total mem: {bytes2human(size)}&#34;
        return text

    def add_property(self, name: str, value: object, *, erasable: bool = True):
        &#34;&#34;&#34;Add a property to the diagram.

        Parameters
        ----------
        name : str
            The identifiant of the property for the requests.
            If the property is already defined with the same name, the new one erase the older one.
        value
            The property value. If a number is provided, it will be faster.
        erasable : boolean, default=True
            If set to False, the property will be set in stone,
            overwise, the property will desappear as soon as the diagram state changed.
        &#34;&#34;&#34;
        assert isinstance(name, str), name.__class__.__name__
        assert isinstance(erasable, bool), erasable.__class__.__name__
        with self._cache[0]:
            self._properties[name] = ((self.state if erasable else None), value)

    @property
    def areas(self) -&gt; typing.Union[None, torch.Tensor]:
        &#34;&#34;&#34;Return the int32 area of each bboxes.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; print(diagram.areas)
        None
        &gt;&gt;&gt; diagram.find_spots()
        &gt;&gt;&gt; print(diagram.areas)  # doctest: +ELLIPSIS
        tensor([289,  36,  33,  20,  40,  81,  49,  15,  36,  25,  36, 110,  49,  56,
                 64,  56,  72,  56,  90, 143,  64,  42,  36,  25, 169, 110,  81,  64,
                100,  49,  36,  42, 121,  36,  36, 121,  81,  56,  72,  80, 110,  56,
                ...,
                100,  25, 225, 182,  72, 156,  90,  25, 320, 288, 144, 143, 240, 208,
                 64,  81,  25,  25, 144, 323, 300,  90, 144, 240, 270, 168, 352, 270,
                210, 456], dtype=torch.int32)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if not self.is_init():
            return None
        shapes = self.bboxes[:, 2:].to(torch.int32)
        return shapes[:, 0] * shapes[:, 1]

    @property
    def bboxes(self) -&gt; typing.Union[None, torch.Tensor]:
        &#34;&#34;&#34;Return the tensor of the bounding boxes (anchor_i, anchor_j, height, width).

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; print(diagram.bboxes)
        None
        &gt;&gt;&gt; diagram.find_spots()
        &gt;&gt;&gt; print(diagram.bboxes)  # doctest: +ELLIPSIS
        tensor([[   0,    0,   17,   17],
                [   0,   20,    3,   12],
                [   0, 1949,    3,   11],
                ...,
                [1903,  180,   18,   15],
                [1930, 1967,   15,   14],
                [1963, 1170,   24,   19]], dtype=torch.int16)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if not self.is_init():
            return None
        with self._rois_lock:
            bboxes = self._rois[1]
        return bboxes.clone()

    def clone(self, deep: bool = True, cache: bool = True):
        &#34;&#34;&#34;Instanciate a new identical diagram.

        Parameters
        ----------
        deep : boolean, default=True
            If True, the memory of the new created diagram object is totally
            independ of this object (slow but safe). Otherwise, `image` and `rois` attributes
            and cached big data share the same memory view (Tensor). So modifying one of these
            attributes in one diagram will modify the same attribute in the other diagram.
            It if realy faster but not safe.
        cache : boolean, default=True
            Copy the cache into the new diagram if True (default), or live the cache empty if False.

        Returns
        -------
        Diagram
            The new copy of self.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram_bis = diagram.clone()
        &gt;&gt;&gt; assert id(diagram) != id(diagram_bis)
        &gt;&gt;&gt; assert diagram.state == diagram_bis.state
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert isinstance(deep, bool), deep.__class__.__name__
        assert isinstance(cache, bool), cache.__class__.__name__

        state = self.__getstate__(cache=cache)
        if deep:
            state = pickle.loads(pickle.dumps(state))
        new_diagram = self.__class__.__new__(self.__class__)  # create a new diagram
        new_diagram.__setstate__(state)  # initialise (fill) the new diagram
        return new_diagram

    def compress(self, size: numbers.Real = math.inf, *, _levels: set[int] = None) -&gt; int:
        &#34;&#34;&#34;Delete attributes and elements in the cache.

        Paremeters
        ----------
        size : int
            The quantity of bytes to remove from the cache.

        Returns
        -------
        removed : int
            The number of bytes removed from the cache.
        &#34;&#34;&#34;
        # verifiactions
        assert isinstance(size, numbers.Real), size.__class__.__name__
        assert size &gt; 0, size

        _levels = _levels or {0, 1}

        # declaration
        removed = 0

        # delete obsolete cache
        if 0 in _levels:
            pattern = r&#34;(?P&lt;state&gt;[0-9a-f]{32})\.\w+\([0-9a-f]{32}\)&#34;
            state = self.state
            with self._cache[0]:
                for key in list(self._cache[1]):  # copy keys for pop
                    if (match := re.search(pattern, key)) is None:
                        continue
                    if match[&#34;state&#34;] != state:
                        removed += sys.getsizeof(key) + getsizeof(self._cache[1].pop(key))
                # for key in list(self._properties):
                #     match = self._properties[key][0]
                #     if match is not None and match != state:
                #         removed += sys.getsizeof(key) + getsizeof(self._properties.pop(key))

        # delete valid cache
        if 1 in _levels:
            with self._cache[0]:
                size_to_key = {getsizeof(v): k for k, v in self._cache[1].items()}
                for item_size in sorted(size_to_key, reverse=True):  # delete biggest elements first
                    key = size_to_key[item_size]
                    removed += sys.getsizeof(key) + getsizeof(self._cache[1].pop(key))
                    if removed &gt;= size:
                        return removed

        return removed

    @functools.cached_property
    def file(self) -&gt; typing.Union[None, pathlib.Path]:
        &#34;&#34;&#34;Return the absolute file path to the image, if it is provided.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; BaseDiagram(get_sample()).file  # doctest: +ELLIPSIS
        PosixPath(&#39;/.../laueimproc/io/ge.jp2&#39;)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._file_or_data if isinstance(self._file_or_data, pathlib.Path) else None

    @check_init
    def filter_spots(
        self, criteria: typing.Container, msg: str = &#34;general filter&#34;, *, inplace: bool = True
    ):
        &#34;&#34;&#34;Keep only the given spots, delete the rest.

        This method can be used for filtering or sorting spots.

        Parameters
        ----------
        criteria : arraylike
            The list of the indices of the spots to keep (negatives indices are allow),
            or the boolean vector with True for keeping the spot, False otherwise like a mask.
        msg : str
            The message to happend to the history.
        inplace : boolean, default=True
            If True, modify the diagram self (no copy) and return a reference to self.
            If False, first clone the diagram, then apply the selection on the new diagram,
            It create a checkpoint (real copy) (but it is slowler).

        Returns
        -------
        filtered_diagram : BaseDiagram
            Return None if inplace is True, or a filtered clone of self otherwise.

        Examples
        --------
        &gt;&gt;&gt; from pprint import pprint
        &gt;&gt;&gt; import torch
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram.find_spots()
        &gt;&gt;&gt; indices = torch.arange(0, len(diagram), 2)
        &gt;&gt;&gt; diagram.filter_spots(indices, &#34;keep even spots&#34;)
        &gt;&gt;&gt; cond = diagram.bboxes[:, 1] &lt; diagram.image.shape[1]//2
        &gt;&gt;&gt; diag_final = diagram.filter_spots(cond, &#34;keep spots on left&#34;, inplace=False)
        &gt;&gt;&gt; pprint(diagram.history)
        [&#39;240 spots from self.find_spots()&#39;, &#39;240 to 120 spots: keep even spots&#39;]
        &gt;&gt;&gt; pprint(diag_final.history)
        [&#39;240 spots from self.find_spots()&#39;,
         &#39;240 to 120 spots: keep even spots&#39;,
         &#39;120 to 63 spots: keep spots on left&#39;]
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        # verifications and cast
        assert hasattr(criteria, &#34;__iter__&#34;), criteria.__class__.__name__
        assert isinstance(msg, str), msg.__class__.__name__
        assert isinstance(inplace, bool), inplace.__class__.__name__
        criteria = torch.squeeze(torch.asarray(criteria))
        assert criteria.ndim &lt;= 1, f&#34;only a 1d vector is accepted, shape is {criteria.shape}&#34;
        criteria = criteria.reshape(-1)  # for empty tensor
        if criteria.dtype is torch.bool:  # case mask -&gt; convert into index list
            assert criteria.shape[0] == len(self), (
                &#34;the mask has to have the same length as the number of spots, &#34;
                f&#34;there are {len(self)} spots and mask is of len {criteria.shape[0]}&#34;
            )
            criteria = torch.arange(len(self), dtype=torch.int64, device=criteria.device)[criteria]
        elif criteria.dtype != torch.int64:
            criteria = criteria.to(torch.int64)

        # manage inplace
        nb_spots = len(self)
        if not inplace:
            self = self.clone()  # pylint: disable=W0642

        # update history, it has to be done before changing state to be catched by signature
        self._history.append(f&#34;{nb_spots} to {len(criteria)} spots: {msg}&#34;)

        # apply filter
        with self._rois_lock:
            self._rois = filter_by_indices(criteria, *self._rois)

        return None if inplace else self

    def find_spots(self, **kwargs) -&gt; None:
        &#34;&#34;&#34;Search all the spots in this diagram, store the result into the `spots` attribute.

        Parameters
        ----------
        kwargs : dict
            Transmitted to ``laueimproc.improc.peaks_search.peaks_search``.
        &#34;&#34;&#34;
        datarois, bboxes = peaks_search(self.image, **kwargs)
        with self._rois_lock:
            self._rois = (datarois, bboxes)
        kwargs_str = &#34;, &#34;.join(f&#34;{k}={repr(v)}&#34; for k, v in kwargs.items())
        self._history = [f&#34;{len(self)} spots from self.find_spots({kwargs_str})&#34;]

    def get_property(self, name: str) -&gt; object:
        &#34;&#34;&#34;Return the property associated to te given id.

        Parameters
        ----------
        name : str
            The name of the property to get.

        Returns
        -------
        property : object
            The property value set with ``add_property``.

        Raises
        ------
        KeyError
            Is the property has never been defined or if the state changed.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram.add_property(&#34;prop1&#34;, value=&#34;any python object 1&#34;, erasable=False)
        &gt;&gt;&gt; diagram.add_property(&#34;prop2&#34;, value=&#34;any python object 2&#34;)
        &gt;&gt;&gt; diagram.get_property(&#34;prop1&#34;)
        &#39;any python object 1&#39;
        &gt;&gt;&gt; diagram.get_property(&#34;prop2&#34;)
        &#39;any python object 2&#39;
        &gt;&gt;&gt; diagram.find_spots()  # change state
        &gt;&gt;&gt; diagram.get_property(&#34;prop1&#34;)
        &#39;any python object 1&#39;
        &gt;&gt;&gt; try:
        ...     diagram.get_property(&#34;prop2&#34;)
        ... except KeyError as err:
        ...     print(err)
        ...
        &#34;the property &#39;prop2&#39; is no longer valid because the state of the diagram has changed&#34;
        &gt;&gt;&gt; try:
        ...     diagram.get_property(&#34;prop3&#34;)
        ... except KeyError as err:
        ...     print(err)
        ...
        &#34;the property &#39;prop3&#39; does no exist&#34;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert isinstance(name, str), name.__class__.__name__
        with self._cache[0]:
            try:
                state, value = self._properties[name]
            except KeyError as err:
                raise KeyError(f&#34;the property {repr(name)} does no exist&#34;) from err
        if state is not None and state != self.state:
            # with self._lock:
            #     self._properties[name] = (state, None)
            raise KeyError(
                f&#34;the property {repr(name)} is no longer valid &#34;
                &#34;because the state of the diagram has changed&#34;
            )
        return value

    @property
    def history(self) -&gt; list[str]:
        &#34;&#34;&#34;Return the actions performed on the Diagram since the initialisation.&#34;&#34;&#34;
        return self._history.copy()  # copy for user protection

    def is_init(self) -&gt; bool:
        &#34;&#34;&#34;Return True if the diagram has been initialized.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram.is_init()
        False
        &gt;&gt;&gt; diagram.find_spots()
        &gt;&gt;&gt; diagram.is_init()
        True
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._rois is not None

    @property
    def image(self) -&gt; torch.Tensor:
        &#34;&#34;&#34;Return the complete image of the diagram.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram.image.shape
        torch.Size([2018, 2016])
        &gt;&gt;&gt; diagram.image.min() &gt;= 0
        tensor(True)
        &gt;&gt;&gt; diagram.image.max() &lt;= 1
        tensor(True)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        with self._cache[0]:
            if &#34;image&#34; not in self._cache[1]:  # no auto ache because it is state invariant
                self._cache[1][&#34;image&#34;] = (
                    read_image(self._file_or_data)
                    if isinstance(self._file_or_data, pathlib.Path) else
                    self._file_or_data
                )
            image = self._cache[1][&#34;image&#34;]
        CacheManager().track(self)
        return image

    def plot(
        self,
        disp=None,
        vmin: typing.Optional[numbers.Real] = None,
        vmax: typing.Optional[numbers.Real] = None,
        **kwargs,
    ):
        &#34;&#34;&#34;Prepare for display the diagram and the spots.

        Parameters
        ----------
        disp : matplotlib.figure.Figure or matplotlib.axes.Axes
            The matplotlib figure to complete.
        vmin : float, optional
            The minimum intensity ploted.
        vmax : float, optional
            The maximum intensity ploted.
        show_axis: boolean, default=True
            Display the label and the axis if True.
        show_bboxes: boolean, default=True
            Draw all the bounding boxes if True.
        show_image: boolean, default=True
            Display the image if True, dont call imshow otherwise.

        Returns
        -------
        matplotlib.axes.Axes
            Filled graphical widget.

        Notes
        -----
        It doesn&#39;t create the figure and call show.
        Use `self.show()` to Display the diagram from scratch.
        &#34;&#34;&#34;
        from matplotlib.axes import Axes
        from matplotlib.colors import Normalize
        from matplotlib.figure import Figure

        assert disp is None or isinstance(disp, (Figure, Axes))
        image = self.image
        if vmin is None:
            vmin = torch.mean(image).item()
        assert vmin is None or isinstance(vmin, numbers.Real), vmin.__class__.__name__
        if vmax is None:
            vmax = vmin + 5.0*torch.std(image).item()
        assert isinstance(vmax, numbers.Real), vmax.__class__.__name__
        assert isinstance(kwargs.get(&#34;show_axis&#34;, True), bool), kwargs[&#34;show_axis&#34;]
        assert isinstance(kwargs.get(&#34;show_bboxes&#34;, True), bool), kwargs[&#34;show_bboxes&#34;]
        assert isinstance(kwargs.get(&#34;show_image&#34;, True), bool), kwargs[&#34;show_image&#34;]

        # fill figure metadata
        axes = disp  # is gonna changed
        disp = disp or Figure(layout=&#34;tight&#34;)
        if isinstance(disp, Figure):
            if isinstance(self._file_or_data, pathlib.Path):
                disp.suptitle(f&#34;Diagram {self._file_or_data.name}&#34;)
            else:
                disp.suptitle(f&#34;Diagram from Tensor of id {id(self._file_or_data)}&#34;)
            axes = disp.add_subplot()

        # fill axes
        if kwargs.get(&#34;show_axis&#34;, True):
            axes.set_xlabel(&#34;x (first dim in &#39;xy&#39; conv)&#34;)
            axes.xaxis.set_label_position(&#34;bottom&#34;)
            axes.xaxis.set_ticks_position(&#34;bottom&#34;)
            axes.set_ylabel(&#34;y (second dim in &#39;xy&#39; conv)&#34;)
            axes.yaxis.set_label_position(&#34;right&#34;)
            axes.yaxis.set_ticks_position(&#34;right&#34;)
            axes.secondary_xaxis(
                &#34;top&#34;, functions=(lambda x: x-.5, lambda j: j+.5)
            ).set_xlabel(&#34;j (second dim in &#39;ij&#39; conv)&#34;)
            axes.secondary_yaxis(
                &#34;left&#34;, functions=(lambda y: y-.5, lambda i: i+.5)
            ).set_ylabel(&#34;i (first dim in &#39;ij&#39; conv)&#34;)
        if kwargs.get(&#34;show_image&#34;, True):

            axes.imshow(
                image.numpy(force=True),
                aspect=&#34;equal&#34;,
                extent=(.5, self.image.shape[1]+.5, self.image.shape[0]+.5, .5),
                interpolation=None,  # antialiasing is True
                norm=Normalize(vmin, vmax),
                cmap=&#34;plasma&#34;,  # or gray
            )
        if kwargs.get(&#34;show_boxes&#34;, True) and len(self):
            bboxes = self.bboxes.numpy(force=True).astype(np.float32)
            bboxes[:, :2] += 0.5  # ok inplace because copy has been made at previous line
            axes.plot(
                np.vstack((
                    bboxes[:, 1],
                    bboxes[:, 1],
                    bboxes[:, 1]+bboxes[:, 3],
                    bboxes[:, 1]+bboxes[:, 3],
                    bboxes[:, 1],
                )),
                np.vstack((
                    bboxes[:, 0],
                    bboxes[:, 0]+bboxes[:, 2],
                    bboxes[:, 0]+bboxes[:, 2],
                    bboxes[:, 0],
                    bboxes[:, 0],
                )),
                color=&#34;green&#34;,
                scalex=False,
                scaley=False,
            )
        return axes

    @property
    def rawrois(self) -&gt; typing.Union[None, torch.Tensor]:
        &#34;&#34;&#34;Return the tensor of the raw rois of the spots.&#34;&#34;&#34;
        if not self.is_init():
            return None
        with self._rois_lock:
            _, bboxes = self._rois
        return rawshapes2rois(imgbboxes2raw(self.image, bboxes), bboxes[:, 2:])

    @property
    def rois(self) -&gt; typing.Union[None, torch.Tensor]:
        &#34;&#34;&#34;Return the tensor of the provided rois of the spots.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram.find_spots()
        &gt;&gt;&gt; diagram.rawrois.shape
        torch.Size([240, 24, 19])
        &gt;&gt;&gt; diagram.rois.shape
        torch.Size([240, 24, 19])
        &gt;&gt;&gt; diagram.rois.mean() &lt; diagram.rawrois.mean()  # no background
        tensor(True)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if not self.is_init():
            return None
        with self._rois_lock:
            datarois, bboxes = self._rois
        return rawshapes2rois(datarois, bboxes[:, 2:])

    def set_spots(self, *new_spots: tuple) -&gt; None:
        &#34;&#34;&#34;Set the new spots as the current spots, reset the history and the cache.

        Paremeters
        ----------
        new_spots : tuple
            Can be an over diagram of type Diagram.
            Can be an arraylike of bounding boxes n * (anchor_i, anchor_j, height, width).
            Can be an anchor and a picture n * (anchor_i, anchor_j, roi).
            It can also be a combination of the above elements to unite the spots.

        Examples
        --------
        &gt;&gt;&gt; import torch
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt;
        &gt;&gt;&gt; # from diagram
        &gt;&gt;&gt; diagram_ref = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram_ref.find_spots()
        &gt;&gt;&gt; diagram_ref.filter_spots(range(10))
        &gt;&gt;&gt;
        &gt;&gt;&gt; # from bboxes
        &gt;&gt;&gt; bboxes = [[300, 500, 10, 15], [600, 700, 20, 15]]
        &gt;&gt;&gt;
        &gt;&gt;&gt; # from anchor and roi
        &gt;&gt;&gt; spots = [[400, 600, torch.zeros((10, 15))], [700, 800, torch.zeros((20, 15))]]
        &gt;&gt;&gt;
        &gt;&gt;&gt; # union of the spots
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram.set_spots(diagram_ref, bboxes, spots)
        &gt;&gt;&gt; len(diagram)
        14
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        datarois_l, bboxes_l = [], []

        def unfold(iterable):
            if (
                isinstance(iterable, (set, frozenset))
                or (
                    isinstance(iterable, (tuple, list))
                    and not (
                        (  # bboxes
                            len(iterable) == 4
                            and all(isinstance(e, numbers.Integral) for e in iterable)
                        )
                        or (  # anchor, roi
                            len(iterable) == 3
                            and isinstance(iterable[0], numbers.Integral)
                            and isinstance(iterable[1], numbers.Integral)
                            and isinstance(iterable[2], (np.ndarray, torch.Tensor))
                        )
                    )
                )
            ):
                yield from (item_ for item in iterable for item_ in unfold(item))
            else:
                yield iterable

        # extract datarois and anchors
        for item in unfold(new_spots):
            if (
                isinstance(item, BaseDiagram)  # case diagram
                and (datarois_bboxes := item._rois) is not None  # pylint: disable=W0212
            ):
                datarois_l.append(datarois_bboxes[0])
                bboxes_l.append(datarois_bboxes[1])
                continue
            item = torch.from_numpy(item) if isinstance(item, np.ndarray) else item
            if isinstance(item, (tuple, list)) and len(item) == 4:  # case bbox
                item = torch.asarray([item], dtype=torch.int16)
            if (
                isinstance(item, torch.Tensor)
                and item.ndim == 2
                and item.shape[1] == 4
                and not (item.dtype.is_complex or item.dtype.is_floating_point)
            ):  # case bboxes
                item = item.to(torch.int16)
                datarois_l.append(imgbboxes2raw(self.image, item))
                bboxes_l.append(item)
                continue
            if isinstance(item, (tuple, list)):  # case anchor and roi
                datarois = item[2]
                datarois = to_floattensor(datarois)
                if isinstance(datarois, torch.Tensor):
                    datarois = datarois.numpy(force=True)
                datarois = datarois.astype(np.float32, copy=False)
                assert datarois.ndim == 2, datarois.shape
                bboxes_l.append(torch.asarray([[*item[:2], *datarois.shape]], dtype=torch.int16))
                datarois_l.append(bytearray(datarois.ravel().tobytes()))
                continue

            raise ValueError(f&#34;impossible to set new spots from {item}&#34;)

        # replace old spots by the new one
        datarois = bytearray(b&#34;&#34;).join(datarois_l)
        if bboxes_l:
            device = {bboxes.device for bboxes in bboxes_l}
            device = device.pop() if len(device) == 1 else &#34;cpu&#34;
            bboxes = torch.cat([bboxes.to(device) for bboxes in bboxes_l])
        else:
            bboxes = torch.empty((0, 4), dtype=torch.int16)
        with self._rois_lock:
            self._rois = (datarois, bboxes)
        self._history = [f&#34;{len(self)} spots from set_spots(...)&#34;]

    @property
    def state(self) -&gt; str:
        &#34;&#34;&#34;Return a hash of the diagram.

        If two diagrams gots the same state, it means they are the same.
        The hash take in consideration the internal state of the diagram.
        The retruned value is a hexadecimal string of length 32.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram.state
        &#39;9570d3b8743757aa3bf89a42bc4911de&#39;
        &gt;&gt;&gt; diagram.find_spots()
        &gt;&gt;&gt; diagram.state
        &#39;539428b799f2640150aab633de49b695&#39;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        hasher = hashlib.md5(usedforsecurity=False)
        if isinstance(self._file_or_data, pathlib.Path):
            hasher.update(str(self._file_or_data.name).encode())
        else:
            hasher.update(id(self._file_or_data).to_bytes(8, &#34;big&#34;))
        hasher.update(&#34;\n&#34;.join(self._history).encode())
        return hasher.hexdigest()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="laueimproc.classes.base_diagram.check_init"><code class="name flex">
<span>def <span class="ident">check_init</span></span>(<span>meth: Callable) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Decorate a Diagram method to ensure the diagram has been init.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_init(meth: typing.Callable) -&gt; typing.Callable:
    &#34;&#34;&#34;Decorate a Diagram method to ensure the diagram has been init.&#34;&#34;&#34;
    assert callable(meth), meth.__class__.__name__

    @functools.wraps(meth)
    def check_init_meth(diagram, *args, **kwargs):
        if not diagram.is_init():
            raise RuntimeError(
                f&#34;before calling the {meth} diagram method, initialize the diagram &#34;
                f&#34;{repr(diagram)} by invoking &#39;find_spots&#39; or &#39;set_spots&#39;&#34;
            )
        return meth(diagram, *args, **kwargs)

    return check_init_meth</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="laueimproc.classes.base_diagram.BaseDiagram"><code class="flex name class">
<span>class <span class="ident">BaseDiagram</span></span>
<span>(</span><span>data: Union[numpy.ndarray, torch.Tensor, str, pathlib.Path])</span>
</code></dt>
<dd>
<div class="desc"><p>A Basic diagram with the fondamental structure.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>areas</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The int32 area of each bboxes.
Return None until spots are initialized.</dd>
<dt><strong><code>bboxes</code></strong> :&ensp;<code>torch.Tensor</code> or <code>None</code></dt>
<dd>The int16 tensor of the bounding boxes (anchor_i, anchor_j, height, width)
for each spots, of shape (n, 4) (readonly).
Return None until spots are initialized.</dd>
<dt><strong><code>file</code></strong> :&ensp;<code>pathlib.Path</code> or <code>None</code></dt>
<dd>The absolute file path to the image if provided, None otherwise (readonly).</dd>
<dt><strong><code>history</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>The actions performed on the Diagram from the initialisation (readonly).</dd>
<dt><strong><code>image</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>The complete brut image of the diagram (readonly).</dd>
<dt><strong><code>rawrois</code></strong> :&ensp;<code>torch.Tensor</code> or <code>None</code></dt>
<dd>The tensor of the raw regions of interest for each spots (readonly).
Return None until spots are initialized. The shape is (n, h, w).
Contrary to <code>self.rois</code>, it is only a view of <code>self.image</code>.</dd>
<dt><strong><code>rois</code></strong> :&ensp;<code>torch.Tensor</code> or <code>None</code></dt>
<dd>The tensor of the provided regions of interest for each spots (readonly).
For writing, use <code>self.find_spost(&hellip;)</code> or
<code>self.set_spots(&hellip;)</code>.
Return None until spots are initialized. The shape is (n, h, w).</dd>
</dl>
<p>Create a new diagram with appropriated metadata.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pathlike</code> or <code>arraylike</code></dt>
<dd>The filename or the array/tensor use as a diagram.
For memory management, it is better to provide a pathlike rather than an array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseDiagram:
    &#34;&#34;&#34;A Basic diagram with the fondamental structure.

    Attributes
    ----------
    areas : torch.Tensor
        The int32 area of each bboxes.
        Return None until spots are initialized.
    bboxes : torch.Tensor or None
        The int16 tensor of the bounding boxes (anchor_i, anchor_j, height, width)
        for each spots, of shape (n, 4) (readonly).
        Return None until spots are initialized.
    file : pathlib.Path or None
        The absolute file path to the image if provided, None otherwise (readonly).
    history : list[str]
        The actions performed on the Diagram from the initialisation (readonly).
    image : torch.Tensor
        The complete brut image of the diagram (readonly).
    rawrois : torch.Tensor or None
        The tensor of the raw regions of interest for each spots (readonly).
        Return None until spots are initialized. The shape is (n, h, w).
        Contrary to `self.rois`, it is only a view of `self.image`.
    rois : torch.Tensor or None
        The tensor of the provided regions of interest for each spots (readonly).
        For writing, use `self.find_spost(...)` or  `self.set_spots(...)`.
        Return None until spots are initialized. The shape is (n, h, w).
    &#34;&#34;&#34;

    def __init__(
        self,
        data: typing.Union[np.ndarray, torch.Tensor, str, pathlib.Path],
        *,
        _check: bool = True,
    ):
        &#34;&#34;&#34;Create a new diagram with appropriated metadata.

        Parameters
        ----------
        data : pathlike or arraylike
            The filename or the array/tensor use as a diagram.
            For memory management, it is better to provide a pathlike rather than an array.
        &#34;&#34;&#34;
        # declaration
        self._cache: tuple[threading.Lock, dict[str]] = (  # contains the optional cached data
            threading.Lock(), {}
        )
        self._file_or_data: typing.Union[pathlib.Path, torch.Tensor]  # the path to the image file
        self._history: list[str] = []  # the history of the actions performed
        self._properties: dict[str, tuple[typing.Union[None, str], object]] = {}  # the properties
        self._rois: typing.Optional[tuple[bytearray, torch.Tensor]] = None  # datarois, bboxes
        self._rois_lock = threading.Lock()  # make the rois acces thread safe

        # initialisation
        if isinstance(data, (str, pathlib.Path)):
            self._file_or_data = data
            if _check:
                self._file_or_data = pathlib.Path(self._file_or_data).expanduser().resolve()
                assert self._file_or_data.is_file(), self._file_or_data
        else:
            warnings.warn(&#34;please provide a path rather than an array&#34;, RuntimeWarning)
            self._file_or_data = to_floattensor(data)
            assert self._file_or_data.ndim == 2, self._file_or_data.shape

    def __getstate__(self, cache: bool = False):
        &#34;&#34;&#34;Make the diagram pickleable.&#34;&#34;&#34;
        with self._rois_lock:
            rois = None if self._rois is None else (self._rois[0].copy(), self._rois[1].clone())
        if cache:
            with self._cache[0]:
                return (
                    self._file_or_data,
                    self._history,
                    self._properties,
                    rois,
                    self._cache[1].copy(),
                )
        return (
            self._file_or_data,
            self._history,
            self._properties,
            rois,
        )

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Return the nbr of spots or 0.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; len(diagram)
        0
        &gt;&gt;&gt; diagram.find_spots()
        &gt;&gt;&gt; len(diagram)
        240
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        try:  # it doesn&#39;t matter if acces is not thread safe
            return len(self._rois[1])
        except TypeError:
            return 0

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Give a very compact representation.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; BaseDiagram(get_sample())
        BaseDiagram(ge.jp2)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if self.file is None:
            return f&#34;{self.__class__.__name__}(Tensor(...))&#34;
        return f&#34;{self.__class__.__name__}({self.file.name})&#34;

    def __setstate__(self, state: tuple):
        &#34;&#34;&#34;Fill the internal attributes.

        Usefull for pickle.

        Notes
        -----
        * No verification is made because the user is not supposed to call this method.

        Examples
        --------
        &gt;&gt;&gt; import pickle
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram_bis = pickle.loads(pickle.dumps(diagram))
        &gt;&gt;&gt; assert id(diagram) != id(diagram_bis)
        &gt;&gt;&gt; assert diagram.state == diagram_bis.state
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        # not verification for thread safe
        # because this method is never meant to be call from a thread.
        (
            self._file_or_data,
            self._history,
            self._properties,
            self._rois,
        ) = state[:4]
        self._cache = (threading.Lock(), (state[4] if len(state) == 5 else {}))
        self._rois_lock = threading.Lock()
        CacheManager().track(self)

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Return a nice sumary of the history of this diagram.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; print(BaseDiagram(get_sample()))  # doctest: +ELLIPSIS
        Diagram from ge.jp2:
            History empty, please initialize the spots `self.find_spots()`.
            No Properties
            Current state:
                * id, state: ...
                * total mem: ...
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        # title
        text = (
            f&#34;Diagram from {self._file_or_data.name}:&#34;
            if isinstance(self._file_or_data, pathlib.Path) else
            f&#34;Diagram from Tensor of id {id(self._file_or_data)}:&#34;
        )

        # history
        if self.is_init():
            text += &#34;\n    History:&#34;
            for i, history in enumerate(self.history):  # not ._history to be updated
                text += f&#34;\n        {i+1}. {history}&#34;
        else:
            text += &#34;\n    History empty, please initialize the spots `self.find_spots()`.&#34;

        # properties
        properties = []
        for name in sorted(self._properties):
            try:
                properties.append((name, self.get_property(name)))
            except KeyError:
                pass
        if properties:
            text += &#34;\n    Properties:&#34;
            for name, value in properties:
                if len(value_str := str(value).replace(&#34;\n&#34;, &#34;\\n&#34;)) &gt;= 80:
                    value_str = f&#34;&lt;{value.__class__.__name__} object&gt;&#34;
                text += f&#34;\n        * {name}: {value_str}&#34;
        else:
            text += &#34;\n    No Properties&#34;

        # stats
        text += &#34;\n    Current state:&#34;
        text += f&#34;\n        * id, state: {id(self)}, {self.state}&#34;
        if self.is_init():
            text += f&#34;\n        * nbr spots: {len(self)}&#34;
        with self._cache[0], self._rois_lock:
            size = sys.getsizeof(self) + sum(getsizeof(e) for e in self.__dict__.values())
        text += f&#34;\n        * total mem: {bytes2human(size)}&#34;
        return text

    def add_property(self, name: str, value: object, *, erasable: bool = True):
        &#34;&#34;&#34;Add a property to the diagram.

        Parameters
        ----------
        name : str
            The identifiant of the property for the requests.
            If the property is already defined with the same name, the new one erase the older one.
        value
            The property value. If a number is provided, it will be faster.
        erasable : boolean, default=True
            If set to False, the property will be set in stone,
            overwise, the property will desappear as soon as the diagram state changed.
        &#34;&#34;&#34;
        assert isinstance(name, str), name.__class__.__name__
        assert isinstance(erasable, bool), erasable.__class__.__name__
        with self._cache[0]:
            self._properties[name] = ((self.state if erasable else None), value)

    @property
    def areas(self) -&gt; typing.Union[None, torch.Tensor]:
        &#34;&#34;&#34;Return the int32 area of each bboxes.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; print(diagram.areas)
        None
        &gt;&gt;&gt; diagram.find_spots()
        &gt;&gt;&gt; print(diagram.areas)  # doctest: +ELLIPSIS
        tensor([289,  36,  33,  20,  40,  81,  49,  15,  36,  25,  36, 110,  49,  56,
                 64,  56,  72,  56,  90, 143,  64,  42,  36,  25, 169, 110,  81,  64,
                100,  49,  36,  42, 121,  36,  36, 121,  81,  56,  72,  80, 110,  56,
                ...,
                100,  25, 225, 182,  72, 156,  90,  25, 320, 288, 144, 143, 240, 208,
                 64,  81,  25,  25, 144, 323, 300,  90, 144, 240, 270, 168, 352, 270,
                210, 456], dtype=torch.int32)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if not self.is_init():
            return None
        shapes = self.bboxes[:, 2:].to(torch.int32)
        return shapes[:, 0] * shapes[:, 1]

    @property
    def bboxes(self) -&gt; typing.Union[None, torch.Tensor]:
        &#34;&#34;&#34;Return the tensor of the bounding boxes (anchor_i, anchor_j, height, width).

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; print(diagram.bboxes)
        None
        &gt;&gt;&gt; diagram.find_spots()
        &gt;&gt;&gt; print(diagram.bboxes)  # doctest: +ELLIPSIS
        tensor([[   0,    0,   17,   17],
                [   0,   20,    3,   12],
                [   0, 1949,    3,   11],
                ...,
                [1903,  180,   18,   15],
                [1930, 1967,   15,   14],
                [1963, 1170,   24,   19]], dtype=torch.int16)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if not self.is_init():
            return None
        with self._rois_lock:
            bboxes = self._rois[1]
        return bboxes.clone()

    def clone(self, deep: bool = True, cache: bool = True):
        &#34;&#34;&#34;Instanciate a new identical diagram.

        Parameters
        ----------
        deep : boolean, default=True
            If True, the memory of the new created diagram object is totally
            independ of this object (slow but safe). Otherwise, `image` and `rois` attributes
            and cached big data share the same memory view (Tensor). So modifying one of these
            attributes in one diagram will modify the same attribute in the other diagram.
            It if realy faster but not safe.
        cache : boolean, default=True
            Copy the cache into the new diagram if True (default), or live the cache empty if False.

        Returns
        -------
        Diagram
            The new copy of self.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram_bis = diagram.clone()
        &gt;&gt;&gt; assert id(diagram) != id(diagram_bis)
        &gt;&gt;&gt; assert diagram.state == diagram_bis.state
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert isinstance(deep, bool), deep.__class__.__name__
        assert isinstance(cache, bool), cache.__class__.__name__

        state = self.__getstate__(cache=cache)
        if deep:
            state = pickle.loads(pickle.dumps(state))
        new_diagram = self.__class__.__new__(self.__class__)  # create a new diagram
        new_diagram.__setstate__(state)  # initialise (fill) the new diagram
        return new_diagram

    def compress(self, size: numbers.Real = math.inf, *, _levels: set[int] = None) -&gt; int:
        &#34;&#34;&#34;Delete attributes and elements in the cache.

        Paremeters
        ----------
        size : int
            The quantity of bytes to remove from the cache.

        Returns
        -------
        removed : int
            The number of bytes removed from the cache.
        &#34;&#34;&#34;
        # verifiactions
        assert isinstance(size, numbers.Real), size.__class__.__name__
        assert size &gt; 0, size

        _levels = _levels or {0, 1}

        # declaration
        removed = 0

        # delete obsolete cache
        if 0 in _levels:
            pattern = r&#34;(?P&lt;state&gt;[0-9a-f]{32})\.\w+\([0-9a-f]{32}\)&#34;
            state = self.state
            with self._cache[0]:
                for key in list(self._cache[1]):  # copy keys for pop
                    if (match := re.search(pattern, key)) is None:
                        continue
                    if match[&#34;state&#34;] != state:
                        removed += sys.getsizeof(key) + getsizeof(self._cache[1].pop(key))
                # for key in list(self._properties):
                #     match = self._properties[key][0]
                #     if match is not None and match != state:
                #         removed += sys.getsizeof(key) + getsizeof(self._properties.pop(key))

        # delete valid cache
        if 1 in _levels:
            with self._cache[0]:
                size_to_key = {getsizeof(v): k for k, v in self._cache[1].items()}
                for item_size in sorted(size_to_key, reverse=True):  # delete biggest elements first
                    key = size_to_key[item_size]
                    removed += sys.getsizeof(key) + getsizeof(self._cache[1].pop(key))
                    if removed &gt;= size:
                        return removed

        return removed

    @functools.cached_property
    def file(self) -&gt; typing.Union[None, pathlib.Path]:
        &#34;&#34;&#34;Return the absolute file path to the image, if it is provided.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; BaseDiagram(get_sample()).file  # doctest: +ELLIPSIS
        PosixPath(&#39;/.../laueimproc/io/ge.jp2&#39;)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._file_or_data if isinstance(self._file_or_data, pathlib.Path) else None

    @check_init
    def filter_spots(
        self, criteria: typing.Container, msg: str = &#34;general filter&#34;, *, inplace: bool = True
    ):
        &#34;&#34;&#34;Keep only the given spots, delete the rest.

        This method can be used for filtering or sorting spots.

        Parameters
        ----------
        criteria : arraylike
            The list of the indices of the spots to keep (negatives indices are allow),
            or the boolean vector with True for keeping the spot, False otherwise like a mask.
        msg : str
            The message to happend to the history.
        inplace : boolean, default=True
            If True, modify the diagram self (no copy) and return a reference to self.
            If False, first clone the diagram, then apply the selection on the new diagram,
            It create a checkpoint (real copy) (but it is slowler).

        Returns
        -------
        filtered_diagram : BaseDiagram
            Return None if inplace is True, or a filtered clone of self otherwise.

        Examples
        --------
        &gt;&gt;&gt; from pprint import pprint
        &gt;&gt;&gt; import torch
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram.find_spots()
        &gt;&gt;&gt; indices = torch.arange(0, len(diagram), 2)
        &gt;&gt;&gt; diagram.filter_spots(indices, &#34;keep even spots&#34;)
        &gt;&gt;&gt; cond = diagram.bboxes[:, 1] &lt; diagram.image.shape[1]//2
        &gt;&gt;&gt; diag_final = diagram.filter_spots(cond, &#34;keep spots on left&#34;, inplace=False)
        &gt;&gt;&gt; pprint(diagram.history)
        [&#39;240 spots from self.find_spots()&#39;, &#39;240 to 120 spots: keep even spots&#39;]
        &gt;&gt;&gt; pprint(diag_final.history)
        [&#39;240 spots from self.find_spots()&#39;,
         &#39;240 to 120 spots: keep even spots&#39;,
         &#39;120 to 63 spots: keep spots on left&#39;]
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        # verifications and cast
        assert hasattr(criteria, &#34;__iter__&#34;), criteria.__class__.__name__
        assert isinstance(msg, str), msg.__class__.__name__
        assert isinstance(inplace, bool), inplace.__class__.__name__
        criteria = torch.squeeze(torch.asarray(criteria))
        assert criteria.ndim &lt;= 1, f&#34;only a 1d vector is accepted, shape is {criteria.shape}&#34;
        criteria = criteria.reshape(-1)  # for empty tensor
        if criteria.dtype is torch.bool:  # case mask -&gt; convert into index list
            assert criteria.shape[0] == len(self), (
                &#34;the mask has to have the same length as the number of spots, &#34;
                f&#34;there are {len(self)} spots and mask is of len {criteria.shape[0]}&#34;
            )
            criteria = torch.arange(len(self), dtype=torch.int64, device=criteria.device)[criteria]
        elif criteria.dtype != torch.int64:
            criteria = criteria.to(torch.int64)

        # manage inplace
        nb_spots = len(self)
        if not inplace:
            self = self.clone()  # pylint: disable=W0642

        # update history, it has to be done before changing state to be catched by signature
        self._history.append(f&#34;{nb_spots} to {len(criteria)} spots: {msg}&#34;)

        # apply filter
        with self._rois_lock:
            self._rois = filter_by_indices(criteria, *self._rois)

        return None if inplace else self

    def find_spots(self, **kwargs) -&gt; None:
        &#34;&#34;&#34;Search all the spots in this diagram, store the result into the `spots` attribute.

        Parameters
        ----------
        kwargs : dict
            Transmitted to ``laueimproc.improc.peaks_search.peaks_search``.
        &#34;&#34;&#34;
        datarois, bboxes = peaks_search(self.image, **kwargs)
        with self._rois_lock:
            self._rois = (datarois, bboxes)
        kwargs_str = &#34;, &#34;.join(f&#34;{k}={repr(v)}&#34; for k, v in kwargs.items())
        self._history = [f&#34;{len(self)} spots from self.find_spots({kwargs_str})&#34;]

    def get_property(self, name: str) -&gt; object:
        &#34;&#34;&#34;Return the property associated to te given id.

        Parameters
        ----------
        name : str
            The name of the property to get.

        Returns
        -------
        property : object
            The property value set with ``add_property``.

        Raises
        ------
        KeyError
            Is the property has never been defined or if the state changed.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram.add_property(&#34;prop1&#34;, value=&#34;any python object 1&#34;, erasable=False)
        &gt;&gt;&gt; diagram.add_property(&#34;prop2&#34;, value=&#34;any python object 2&#34;)
        &gt;&gt;&gt; diagram.get_property(&#34;prop1&#34;)
        &#39;any python object 1&#39;
        &gt;&gt;&gt; diagram.get_property(&#34;prop2&#34;)
        &#39;any python object 2&#39;
        &gt;&gt;&gt; diagram.find_spots()  # change state
        &gt;&gt;&gt; diagram.get_property(&#34;prop1&#34;)
        &#39;any python object 1&#39;
        &gt;&gt;&gt; try:
        ...     diagram.get_property(&#34;prop2&#34;)
        ... except KeyError as err:
        ...     print(err)
        ...
        &#34;the property &#39;prop2&#39; is no longer valid because the state of the diagram has changed&#34;
        &gt;&gt;&gt; try:
        ...     diagram.get_property(&#34;prop3&#34;)
        ... except KeyError as err:
        ...     print(err)
        ...
        &#34;the property &#39;prop3&#39; does no exist&#34;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert isinstance(name, str), name.__class__.__name__
        with self._cache[0]:
            try:
                state, value = self._properties[name]
            except KeyError as err:
                raise KeyError(f&#34;the property {repr(name)} does no exist&#34;) from err
        if state is not None and state != self.state:
            # with self._lock:
            #     self._properties[name] = (state, None)
            raise KeyError(
                f&#34;the property {repr(name)} is no longer valid &#34;
                &#34;because the state of the diagram has changed&#34;
            )
        return value

    @property
    def history(self) -&gt; list[str]:
        &#34;&#34;&#34;Return the actions performed on the Diagram since the initialisation.&#34;&#34;&#34;
        return self._history.copy()  # copy for user protection

    def is_init(self) -&gt; bool:
        &#34;&#34;&#34;Return True if the diagram has been initialized.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram.is_init()
        False
        &gt;&gt;&gt; diagram.find_spots()
        &gt;&gt;&gt; diagram.is_init()
        True
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._rois is not None

    @property
    def image(self) -&gt; torch.Tensor:
        &#34;&#34;&#34;Return the complete image of the diagram.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram.image.shape
        torch.Size([2018, 2016])
        &gt;&gt;&gt; diagram.image.min() &gt;= 0
        tensor(True)
        &gt;&gt;&gt; diagram.image.max() &lt;= 1
        tensor(True)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        with self._cache[0]:
            if &#34;image&#34; not in self._cache[1]:  # no auto ache because it is state invariant
                self._cache[1][&#34;image&#34;] = (
                    read_image(self._file_or_data)
                    if isinstance(self._file_or_data, pathlib.Path) else
                    self._file_or_data
                )
            image = self._cache[1][&#34;image&#34;]
        CacheManager().track(self)
        return image

    def plot(
        self,
        disp=None,
        vmin: typing.Optional[numbers.Real] = None,
        vmax: typing.Optional[numbers.Real] = None,
        **kwargs,
    ):
        &#34;&#34;&#34;Prepare for display the diagram and the spots.

        Parameters
        ----------
        disp : matplotlib.figure.Figure or matplotlib.axes.Axes
            The matplotlib figure to complete.
        vmin : float, optional
            The minimum intensity ploted.
        vmax : float, optional
            The maximum intensity ploted.
        show_axis: boolean, default=True
            Display the label and the axis if True.
        show_bboxes: boolean, default=True
            Draw all the bounding boxes if True.
        show_image: boolean, default=True
            Display the image if True, dont call imshow otherwise.

        Returns
        -------
        matplotlib.axes.Axes
            Filled graphical widget.

        Notes
        -----
        It doesn&#39;t create the figure and call show.
        Use `self.show()` to Display the diagram from scratch.
        &#34;&#34;&#34;
        from matplotlib.axes import Axes
        from matplotlib.colors import Normalize
        from matplotlib.figure import Figure

        assert disp is None or isinstance(disp, (Figure, Axes))
        image = self.image
        if vmin is None:
            vmin = torch.mean(image).item()
        assert vmin is None or isinstance(vmin, numbers.Real), vmin.__class__.__name__
        if vmax is None:
            vmax = vmin + 5.0*torch.std(image).item()
        assert isinstance(vmax, numbers.Real), vmax.__class__.__name__
        assert isinstance(kwargs.get(&#34;show_axis&#34;, True), bool), kwargs[&#34;show_axis&#34;]
        assert isinstance(kwargs.get(&#34;show_bboxes&#34;, True), bool), kwargs[&#34;show_bboxes&#34;]
        assert isinstance(kwargs.get(&#34;show_image&#34;, True), bool), kwargs[&#34;show_image&#34;]

        # fill figure metadata
        axes = disp  # is gonna changed
        disp = disp or Figure(layout=&#34;tight&#34;)
        if isinstance(disp, Figure):
            if isinstance(self._file_or_data, pathlib.Path):
                disp.suptitle(f&#34;Diagram {self._file_or_data.name}&#34;)
            else:
                disp.suptitle(f&#34;Diagram from Tensor of id {id(self._file_or_data)}&#34;)
            axes = disp.add_subplot()

        # fill axes
        if kwargs.get(&#34;show_axis&#34;, True):
            axes.set_xlabel(&#34;x (first dim in &#39;xy&#39; conv)&#34;)
            axes.xaxis.set_label_position(&#34;bottom&#34;)
            axes.xaxis.set_ticks_position(&#34;bottom&#34;)
            axes.set_ylabel(&#34;y (second dim in &#39;xy&#39; conv)&#34;)
            axes.yaxis.set_label_position(&#34;right&#34;)
            axes.yaxis.set_ticks_position(&#34;right&#34;)
            axes.secondary_xaxis(
                &#34;top&#34;, functions=(lambda x: x-.5, lambda j: j+.5)
            ).set_xlabel(&#34;j (second dim in &#39;ij&#39; conv)&#34;)
            axes.secondary_yaxis(
                &#34;left&#34;, functions=(lambda y: y-.5, lambda i: i+.5)
            ).set_ylabel(&#34;i (first dim in &#39;ij&#39; conv)&#34;)
        if kwargs.get(&#34;show_image&#34;, True):

            axes.imshow(
                image.numpy(force=True),
                aspect=&#34;equal&#34;,
                extent=(.5, self.image.shape[1]+.5, self.image.shape[0]+.5, .5),
                interpolation=None,  # antialiasing is True
                norm=Normalize(vmin, vmax),
                cmap=&#34;plasma&#34;,  # or gray
            )
        if kwargs.get(&#34;show_boxes&#34;, True) and len(self):
            bboxes = self.bboxes.numpy(force=True).astype(np.float32)
            bboxes[:, :2] += 0.5  # ok inplace because copy has been made at previous line
            axes.plot(
                np.vstack((
                    bboxes[:, 1],
                    bboxes[:, 1],
                    bboxes[:, 1]+bboxes[:, 3],
                    bboxes[:, 1]+bboxes[:, 3],
                    bboxes[:, 1],
                )),
                np.vstack((
                    bboxes[:, 0],
                    bboxes[:, 0]+bboxes[:, 2],
                    bboxes[:, 0]+bboxes[:, 2],
                    bboxes[:, 0],
                    bboxes[:, 0],
                )),
                color=&#34;green&#34;,
                scalex=False,
                scaley=False,
            )
        return axes

    @property
    def rawrois(self) -&gt; typing.Union[None, torch.Tensor]:
        &#34;&#34;&#34;Return the tensor of the raw rois of the spots.&#34;&#34;&#34;
        if not self.is_init():
            return None
        with self._rois_lock:
            _, bboxes = self._rois
        return rawshapes2rois(imgbboxes2raw(self.image, bboxes), bboxes[:, 2:])

    @property
    def rois(self) -&gt; typing.Union[None, torch.Tensor]:
        &#34;&#34;&#34;Return the tensor of the provided rois of the spots.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram.find_spots()
        &gt;&gt;&gt; diagram.rawrois.shape
        torch.Size([240, 24, 19])
        &gt;&gt;&gt; diagram.rois.shape
        torch.Size([240, 24, 19])
        &gt;&gt;&gt; diagram.rois.mean() &lt; diagram.rawrois.mean()  # no background
        tensor(True)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if not self.is_init():
            return None
        with self._rois_lock:
            datarois, bboxes = self._rois
        return rawshapes2rois(datarois, bboxes[:, 2:])

    def set_spots(self, *new_spots: tuple) -&gt; None:
        &#34;&#34;&#34;Set the new spots as the current spots, reset the history and the cache.

        Paremeters
        ----------
        new_spots : tuple
            Can be an over diagram of type Diagram.
            Can be an arraylike of bounding boxes n * (anchor_i, anchor_j, height, width).
            Can be an anchor and a picture n * (anchor_i, anchor_j, roi).
            It can also be a combination of the above elements to unite the spots.

        Examples
        --------
        &gt;&gt;&gt; import torch
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt;
        &gt;&gt;&gt; # from diagram
        &gt;&gt;&gt; diagram_ref = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram_ref.find_spots()
        &gt;&gt;&gt; diagram_ref.filter_spots(range(10))
        &gt;&gt;&gt;
        &gt;&gt;&gt; # from bboxes
        &gt;&gt;&gt; bboxes = [[300, 500, 10, 15], [600, 700, 20, 15]]
        &gt;&gt;&gt;
        &gt;&gt;&gt; # from anchor and roi
        &gt;&gt;&gt; spots = [[400, 600, torch.zeros((10, 15))], [700, 800, torch.zeros((20, 15))]]
        &gt;&gt;&gt;
        &gt;&gt;&gt; # union of the spots
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram.set_spots(diagram_ref, bboxes, spots)
        &gt;&gt;&gt; len(diagram)
        14
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        datarois_l, bboxes_l = [], []

        def unfold(iterable):
            if (
                isinstance(iterable, (set, frozenset))
                or (
                    isinstance(iterable, (tuple, list))
                    and not (
                        (  # bboxes
                            len(iterable) == 4
                            and all(isinstance(e, numbers.Integral) for e in iterable)
                        )
                        or (  # anchor, roi
                            len(iterable) == 3
                            and isinstance(iterable[0], numbers.Integral)
                            and isinstance(iterable[1], numbers.Integral)
                            and isinstance(iterable[2], (np.ndarray, torch.Tensor))
                        )
                    )
                )
            ):
                yield from (item_ for item in iterable for item_ in unfold(item))
            else:
                yield iterable

        # extract datarois and anchors
        for item in unfold(new_spots):
            if (
                isinstance(item, BaseDiagram)  # case diagram
                and (datarois_bboxes := item._rois) is not None  # pylint: disable=W0212
            ):
                datarois_l.append(datarois_bboxes[0])
                bboxes_l.append(datarois_bboxes[1])
                continue
            item = torch.from_numpy(item) if isinstance(item, np.ndarray) else item
            if isinstance(item, (tuple, list)) and len(item) == 4:  # case bbox
                item = torch.asarray([item], dtype=torch.int16)
            if (
                isinstance(item, torch.Tensor)
                and item.ndim == 2
                and item.shape[1] == 4
                and not (item.dtype.is_complex or item.dtype.is_floating_point)
            ):  # case bboxes
                item = item.to(torch.int16)
                datarois_l.append(imgbboxes2raw(self.image, item))
                bboxes_l.append(item)
                continue
            if isinstance(item, (tuple, list)):  # case anchor and roi
                datarois = item[2]
                datarois = to_floattensor(datarois)
                if isinstance(datarois, torch.Tensor):
                    datarois = datarois.numpy(force=True)
                datarois = datarois.astype(np.float32, copy=False)
                assert datarois.ndim == 2, datarois.shape
                bboxes_l.append(torch.asarray([[*item[:2], *datarois.shape]], dtype=torch.int16))
                datarois_l.append(bytearray(datarois.ravel().tobytes()))
                continue

            raise ValueError(f&#34;impossible to set new spots from {item}&#34;)

        # replace old spots by the new one
        datarois = bytearray(b&#34;&#34;).join(datarois_l)
        if bboxes_l:
            device = {bboxes.device for bboxes in bboxes_l}
            device = device.pop() if len(device) == 1 else &#34;cpu&#34;
            bboxes = torch.cat([bboxes.to(device) for bboxes in bboxes_l])
        else:
            bboxes = torch.empty((0, 4), dtype=torch.int16)
        with self._rois_lock:
            self._rois = (datarois, bboxes)
        self._history = [f&#34;{len(self)} spots from set_spots(...)&#34;]

    @property
    def state(self) -&gt; str:
        &#34;&#34;&#34;Return a hash of the diagram.

        If two diagrams gots the same state, it means they are the same.
        The hash take in consideration the internal state of the diagram.
        The retruned value is a hexadecimal string of length 32.

        Examples
        --------
        &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
        &gt;&gt;&gt; from laueimproc.io import get_sample
        &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
        &gt;&gt;&gt; diagram.state
        &#39;9570d3b8743757aa3bf89a42bc4911de&#39;
        &gt;&gt;&gt; diagram.find_spots()
        &gt;&gt;&gt; diagram.state
        &#39;539428b799f2640150aab633de49b695&#39;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        hasher = hashlib.md5(usedforsecurity=False)
        if isinstance(self._file_or_data, pathlib.Path):
            hasher.update(str(self._file_or_data.name).encode())
        else:
            hasher.update(id(self._file_or_data).to_bytes(8, &#34;big&#34;))
        hasher.update(&#34;\n&#34;.join(self._history).encode())
        return hasher.hexdigest()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="laueimproc.classes.diagram.Diagram" href="diagram.html#laueimproc.classes.diagram.Diagram">Diagram</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="laueimproc.classes.base_diagram.BaseDiagram.areas"><code class="name">var <span class="ident">areas</span> : Optional[None]</code></dt>
<dd>
<div class="desc"><p>Return the int32 area of each bboxes.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
&gt;&gt;&gt; from laueimproc.io import get_sample
&gt;&gt;&gt; diagram = BaseDiagram(get_sample())
&gt;&gt;&gt; print(diagram.areas)
None
&gt;&gt;&gt; diagram.find_spots()
&gt;&gt;&gt; print(diagram.areas)  # doctest: +ELLIPSIS
tensor([289,  36,  33,  20,  40,  81,  49,  15,  36,  25,  36, 110,  49,  56,
         64,  56,  72,  56,  90, 143,  64,  42,  36,  25, 169, 110,  81,  64,
        100,  49,  36,  42, 121,  36,  36, 121,  81,  56,  72,  80, 110,  56,
        ...,
        100,  25, 225, 182,  72, 156,  90,  25, 320, 288, 144, 143, 240, 208,
         64,  81,  25,  25, 144, 323, 300,  90, 144, 240, 270, 168, 352, 270,
        210, 456], dtype=torch.int32)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def areas(self) -&gt; typing.Union[None, torch.Tensor]:
    &#34;&#34;&#34;Return the int32 area of each bboxes.

    Examples
    --------
    &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
    &gt;&gt;&gt; from laueimproc.io import get_sample
    &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
    &gt;&gt;&gt; print(diagram.areas)
    None
    &gt;&gt;&gt; diagram.find_spots()
    &gt;&gt;&gt; print(diagram.areas)  # doctest: +ELLIPSIS
    tensor([289,  36,  33,  20,  40,  81,  49,  15,  36,  25,  36, 110,  49,  56,
             64,  56,  72,  56,  90, 143,  64,  42,  36,  25, 169, 110,  81,  64,
            100,  49,  36,  42, 121,  36,  36, 121,  81,  56,  72,  80, 110,  56,
            ...,
            100,  25, 225, 182,  72, 156,  90,  25, 320, 288, 144, 143, 240, 208,
             64,  81,  25,  25, 144, 323, 300,  90, 144, 240, 270, 168, 352, 270,
            210, 456], dtype=torch.int32)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    if not self.is_init():
        return None
    shapes = self.bboxes[:, 2:].to(torch.int32)
    return shapes[:, 0] * shapes[:, 1]</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.base_diagram.BaseDiagram.bboxes"><code class="name">var <span class="ident">bboxes</span> : Optional[None]</code></dt>
<dd>
<div class="desc"><p>Return the tensor of the bounding boxes (anchor_i, anchor_j, height, width).</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
&gt;&gt;&gt; from laueimproc.io import get_sample
&gt;&gt;&gt; diagram = BaseDiagram(get_sample())
&gt;&gt;&gt; print(diagram.bboxes)
None
&gt;&gt;&gt; diagram.find_spots()
&gt;&gt;&gt; print(diagram.bboxes)  # doctest: +ELLIPSIS
tensor([[   0,    0,   17,   17],
        [   0,   20,    3,   12],
        [   0, 1949,    3,   11],
        ...,
        [1903,  180,   18,   15],
        [1930, 1967,   15,   14],
        [1963, 1170,   24,   19]], dtype=torch.int16)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bboxes(self) -&gt; typing.Union[None, torch.Tensor]:
    &#34;&#34;&#34;Return the tensor of the bounding boxes (anchor_i, anchor_j, height, width).

    Examples
    --------
    &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
    &gt;&gt;&gt; from laueimproc.io import get_sample
    &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
    &gt;&gt;&gt; print(diagram.bboxes)
    None
    &gt;&gt;&gt; diagram.find_spots()
    &gt;&gt;&gt; print(diagram.bboxes)  # doctest: +ELLIPSIS
    tensor([[   0,    0,   17,   17],
            [   0,   20,    3,   12],
            [   0, 1949,    3,   11],
            ...,
            [1903,  180,   18,   15],
            [1930, 1967,   15,   14],
            [1963, 1170,   24,   19]], dtype=torch.int16)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    if not self.is_init():
        return None
    with self._rois_lock:
        bboxes = self._rois[1]
    return bboxes.clone()</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.base_diagram.BaseDiagram.file"><code class="name">var <span class="ident">file</span></code></dt>
<dd>
<div class="desc"><p>Return the absolute file path to the image, if it is provided.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
&gt;&gt;&gt; from laueimproc.io import get_sample
&gt;&gt;&gt; BaseDiagram(get_sample()).file  # doctest: +ELLIPSIS
PosixPath('/.../laueimproc/io/ge.jp2')
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if self.attrname is None:
        raise TypeError(
            &#34;Cannot use cached_property instance without calling __set_name__ on it.&#34;)
    try:
        cache = instance.__dict__
    except AttributeError:  # not all objects have __dict__ (e.g. class defines slots)
        msg = (
            f&#34;No &#39;__dict__&#39; attribute on {type(instance).__name__!r} &#34;
            f&#34;instance to cache {self.attrname!r} property.&#34;
        )
        raise TypeError(msg) from None
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                try:
                    cache[self.attrname] = val
                except TypeError:
                    msg = (
                        f&#34;The &#39;__dict__&#39; attribute on {type(instance).__name__!r} instance &#34;
                        f&#34;does not support item assignment for caching {self.attrname!r} property.&#34;
                    )
                    raise TypeError(msg) from None
    return val</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.base_diagram.BaseDiagram.history"><code class="name">var <span class="ident">history</span> : list[str]</code></dt>
<dd>
<div class="desc"><p>Return the actions performed on the Diagram since the initialisation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def history(self) -&gt; list[str]:
    &#34;&#34;&#34;Return the actions performed on the Diagram since the initialisation.&#34;&#34;&#34;
    return self._history.copy()  # copy for user protection</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.base_diagram.BaseDiagram.image"><code class="name">var <span class="ident">image</span> : torch.Tensor</code></dt>
<dd>
<div class="desc"><p>Return the complete image of the diagram.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
&gt;&gt;&gt; from laueimproc.io import get_sample
&gt;&gt;&gt; diagram = BaseDiagram(get_sample())
&gt;&gt;&gt; diagram.image.shape
torch.Size([2018, 2016])
&gt;&gt;&gt; diagram.image.min() &gt;= 0
tensor(True)
&gt;&gt;&gt; diagram.image.max() &lt;= 1
tensor(True)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def image(self) -&gt; torch.Tensor:
    &#34;&#34;&#34;Return the complete image of the diagram.

    Examples
    --------
    &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
    &gt;&gt;&gt; from laueimproc.io import get_sample
    &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
    &gt;&gt;&gt; diagram.image.shape
    torch.Size([2018, 2016])
    &gt;&gt;&gt; diagram.image.min() &gt;= 0
    tensor(True)
    &gt;&gt;&gt; diagram.image.max() &lt;= 1
    tensor(True)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    with self._cache[0]:
        if &#34;image&#34; not in self._cache[1]:  # no auto ache because it is state invariant
            self._cache[1][&#34;image&#34;] = (
                read_image(self._file_or_data)
                if isinstance(self._file_or_data, pathlib.Path) else
                self._file_or_data
            )
        image = self._cache[1][&#34;image&#34;]
    CacheManager().track(self)
    return image</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.base_diagram.BaseDiagram.rawrois"><code class="name">var <span class="ident">rawrois</span> : Optional[None]</code></dt>
<dd>
<div class="desc"><p>Return the tensor of the raw rois of the spots.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rawrois(self) -&gt; typing.Union[None, torch.Tensor]:
    &#34;&#34;&#34;Return the tensor of the raw rois of the spots.&#34;&#34;&#34;
    if not self.is_init():
        return None
    with self._rois_lock:
        _, bboxes = self._rois
    return rawshapes2rois(imgbboxes2raw(self.image, bboxes), bboxes[:, 2:])</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.base_diagram.BaseDiagram.rois"><code class="name">var <span class="ident">rois</span> : Optional[None]</code></dt>
<dd>
<div class="desc"><p>Return the tensor of the provided rois of the spots.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
&gt;&gt;&gt; from laueimproc.io import get_sample
&gt;&gt;&gt; diagram = BaseDiagram(get_sample())
&gt;&gt;&gt; diagram.find_spots()
&gt;&gt;&gt; diagram.rawrois.shape
torch.Size([240, 24, 19])
&gt;&gt;&gt; diagram.rois.shape
torch.Size([240, 24, 19])
&gt;&gt;&gt; diagram.rois.mean() &lt; diagram.rawrois.mean()  # no background
tensor(True)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rois(self) -&gt; typing.Union[None, torch.Tensor]:
    &#34;&#34;&#34;Return the tensor of the provided rois of the spots.

    Examples
    --------
    &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
    &gt;&gt;&gt; from laueimproc.io import get_sample
    &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
    &gt;&gt;&gt; diagram.find_spots()
    &gt;&gt;&gt; diagram.rawrois.shape
    torch.Size([240, 24, 19])
    &gt;&gt;&gt; diagram.rois.shape
    torch.Size([240, 24, 19])
    &gt;&gt;&gt; diagram.rois.mean() &lt; diagram.rawrois.mean()  # no background
    tensor(True)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    if not self.is_init():
        return None
    with self._rois_lock:
        datarois, bboxes = self._rois
    return rawshapes2rois(datarois, bboxes[:, 2:])</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.base_diagram.BaseDiagram.state"><code class="name">var <span class="ident">state</span> : str</code></dt>
<dd>
<div class="desc"><p>Return a hash of the diagram.</p>
<p>If two diagrams gots the same state, it means they are the same.
The hash take in consideration the internal state of the diagram.
The retruned value is a hexadecimal string of length 32.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
&gt;&gt;&gt; from laueimproc.io import get_sample
&gt;&gt;&gt; diagram = BaseDiagram(get_sample())
&gt;&gt;&gt; diagram.state
'9570d3b8743757aa3bf89a42bc4911de'
&gt;&gt;&gt; diagram.find_spots()
&gt;&gt;&gt; diagram.state
'539428b799f2640150aab633de49b695'
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state(self) -&gt; str:
    &#34;&#34;&#34;Return a hash of the diagram.

    If two diagrams gots the same state, it means they are the same.
    The hash take in consideration the internal state of the diagram.
    The retruned value is a hexadecimal string of length 32.

    Examples
    --------
    &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
    &gt;&gt;&gt; from laueimproc.io import get_sample
    &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
    &gt;&gt;&gt; diagram.state
    &#39;9570d3b8743757aa3bf89a42bc4911de&#39;
    &gt;&gt;&gt; diagram.find_spots()
    &gt;&gt;&gt; diagram.state
    &#39;539428b799f2640150aab633de49b695&#39;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    hasher = hashlib.md5(usedforsecurity=False)
    if isinstance(self._file_or_data, pathlib.Path):
        hasher.update(str(self._file_or_data.name).encode())
    else:
        hasher.update(id(self._file_or_data).to_bytes(8, &#34;big&#34;))
    hasher.update(&#34;\n&#34;.join(self._history).encode())
    return hasher.hexdigest()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="laueimproc.classes.base_diagram.BaseDiagram.add_property"><code class="name flex">
<span>def <span class="ident">add_property</span></span>(<span>self, name: str, value: object, *, erasable: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a property to the diagram.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The identifiant of the property for the requests.
If the property is already defined with the same name, the new one erase the older one.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The property value. If a number is provided, it will be faster.</dd>
<dt><strong><code>erasable</code></strong> :&ensp;<code>boolean</code>, default=<code>True</code></dt>
<dd>If set to False, the property will be set in stone,
overwise, the property will desappear as soon as the diagram state changed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_property(self, name: str, value: object, *, erasable: bool = True):
    &#34;&#34;&#34;Add a property to the diagram.

    Parameters
    ----------
    name : str
        The identifiant of the property for the requests.
        If the property is already defined with the same name, the new one erase the older one.
    value
        The property value. If a number is provided, it will be faster.
    erasable : boolean, default=True
        If set to False, the property will be set in stone,
        overwise, the property will desappear as soon as the diagram state changed.
    &#34;&#34;&#34;
    assert isinstance(name, str), name.__class__.__name__
    assert isinstance(erasable, bool), erasable.__class__.__name__
    with self._cache[0]:
        self._properties[name] = ((self.state if erasable else None), value)</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.base_diagram.BaseDiagram.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self, deep: bool = True, cache: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Instanciate a new identical diagram.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>deep</code></strong> :&ensp;<code>boolean</code>, default=<code>True</code></dt>
<dd>If True, the memory of the new created diagram object is totally
independ of this object (slow but safe). Otherwise, <code>image</code> and <code>rois</code> attributes
and cached big data share the same memory view (Tensor). So modifying one of these
attributes in one diagram will modify the same attribute in the other diagram.
It if realy faster but not safe.</dd>
<dt><strong><code>cache</code></strong> :&ensp;<code>boolean</code>, default=<code>True</code></dt>
<dd>Copy the cache into the new diagram if True (default), or live the cache empty if False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Diagram</code></dt>
<dd>The new copy of self.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
&gt;&gt;&gt; from laueimproc.io import get_sample
&gt;&gt;&gt; diagram = BaseDiagram(get_sample())
&gt;&gt;&gt; diagram_bis = diagram.clone()
&gt;&gt;&gt; assert id(diagram) != id(diagram_bis)
&gt;&gt;&gt; assert diagram.state == diagram_bis.state
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clone(self, deep: bool = True, cache: bool = True):
    &#34;&#34;&#34;Instanciate a new identical diagram.

    Parameters
    ----------
    deep : boolean, default=True
        If True, the memory of the new created diagram object is totally
        independ of this object (slow but safe). Otherwise, `image` and `rois` attributes
        and cached big data share the same memory view (Tensor). So modifying one of these
        attributes in one diagram will modify the same attribute in the other diagram.
        It if realy faster but not safe.
    cache : boolean, default=True
        Copy the cache into the new diagram if True (default), or live the cache empty if False.

    Returns
    -------
    Diagram
        The new copy of self.

    Examples
    --------
    &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
    &gt;&gt;&gt; from laueimproc.io import get_sample
    &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
    &gt;&gt;&gt; diagram_bis = diagram.clone()
    &gt;&gt;&gt; assert id(diagram) != id(diagram_bis)
    &gt;&gt;&gt; assert diagram.state == diagram_bis.state
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(deep, bool), deep.__class__.__name__
    assert isinstance(cache, bool), cache.__class__.__name__

    state = self.__getstate__(cache=cache)
    if deep:
        state = pickle.loads(pickle.dumps(state))
    new_diagram = self.__class__.__new__(self.__class__)  # create a new diagram
    new_diagram.__setstate__(state)  # initialise (fill) the new diagram
    return new_diagram</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.base_diagram.BaseDiagram.compress"><code class="name flex">
<span>def <span class="ident">compress</span></span>(<span>self, size: numbers.Real = inf) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Delete attributes and elements in the cache.</p>
<h2 id="paremeters">Paremeters</h2>
<p>size : int
The quantity of bytes to remove from the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>removed</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of bytes removed from the cache.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compress(self, size: numbers.Real = math.inf, *, _levels: set[int] = None) -&gt; int:
    &#34;&#34;&#34;Delete attributes and elements in the cache.

    Paremeters
    ----------
    size : int
        The quantity of bytes to remove from the cache.

    Returns
    -------
    removed : int
        The number of bytes removed from the cache.
    &#34;&#34;&#34;
    # verifiactions
    assert isinstance(size, numbers.Real), size.__class__.__name__
    assert size &gt; 0, size

    _levels = _levels or {0, 1}

    # declaration
    removed = 0

    # delete obsolete cache
    if 0 in _levels:
        pattern = r&#34;(?P&lt;state&gt;[0-9a-f]{32})\.\w+\([0-9a-f]{32}\)&#34;
        state = self.state
        with self._cache[0]:
            for key in list(self._cache[1]):  # copy keys for pop
                if (match := re.search(pattern, key)) is None:
                    continue
                if match[&#34;state&#34;] != state:
                    removed += sys.getsizeof(key) + getsizeof(self._cache[1].pop(key))
            # for key in list(self._properties):
            #     match = self._properties[key][0]
            #     if match is not None and match != state:
            #         removed += sys.getsizeof(key) + getsizeof(self._properties.pop(key))

    # delete valid cache
    if 1 in _levels:
        with self._cache[0]:
            size_to_key = {getsizeof(v): k for k, v in self._cache[1].items()}
            for item_size in sorted(size_to_key, reverse=True):  # delete biggest elements first
                key = size_to_key[item_size]
                removed += sys.getsizeof(key) + getsizeof(self._cache[1].pop(key))
                if removed &gt;= size:
                    return removed

    return removed</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.base_diagram.BaseDiagram.filter_spots"><code class="name flex">
<span>def <span class="ident">filter_spots</span></span>(<span>self, criteria: Container, msg: str = 'general filter', *, inplace: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Keep only the given spots, delete the rest.</p>
<p>This method can be used for filtering or sorting spots.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>criteria</code></strong> :&ensp;<code>arraylike</code></dt>
<dd>The list of the indices of the spots to keep (negatives indices are allow),
or the boolean vector with True for keeping the spot, False otherwise like a mask.</dd>
<dt><strong><code>msg</code></strong> :&ensp;<code>str</code></dt>
<dd>The message to happend to the history.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>boolean</code>, default=<code>True</code></dt>
<dd>If True, modify the diagram self (no copy) and return a reference to self.
If False, first clone the diagram, then apply the selection on the new diagram,
It create a checkpoint (real copy) (but it is slowler).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filtered_diagram</code></strong> :&ensp;<code><a title="laueimproc.classes.base_diagram.BaseDiagram" href="#laueimproc.classes.base_diagram.BaseDiagram">BaseDiagram</a></code></dt>
<dd>Return None if inplace is True, or a filtered clone of self otherwise.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; import torch
&gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
&gt;&gt;&gt; from laueimproc.io import get_sample
&gt;&gt;&gt; diagram = BaseDiagram(get_sample())
&gt;&gt;&gt; diagram.find_spots()
&gt;&gt;&gt; indices = torch.arange(0, len(diagram), 2)
&gt;&gt;&gt; diagram.filter_spots(indices, &quot;keep even spots&quot;)
&gt;&gt;&gt; cond = diagram.bboxes[:, 1] &lt; diagram.image.shape[1]//2
&gt;&gt;&gt; diag_final = diagram.filter_spots(cond, &quot;keep spots on left&quot;, inplace=False)
&gt;&gt;&gt; pprint(diagram.history)
['240 spots from self.find_spots()', '240 to 120 spots: keep even spots']
&gt;&gt;&gt; pprint(diag_final.history)
['240 spots from self.find_spots()',
 '240 to 120 spots: keep even spots',
 '120 to 63 spots: keep spots on left']
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_init
def filter_spots(
    self, criteria: typing.Container, msg: str = &#34;general filter&#34;, *, inplace: bool = True
):
    &#34;&#34;&#34;Keep only the given spots, delete the rest.

    This method can be used for filtering or sorting spots.

    Parameters
    ----------
    criteria : arraylike
        The list of the indices of the spots to keep (negatives indices are allow),
        or the boolean vector with True for keeping the spot, False otherwise like a mask.
    msg : str
        The message to happend to the history.
    inplace : boolean, default=True
        If True, modify the diagram self (no copy) and return a reference to self.
        If False, first clone the diagram, then apply the selection on the new diagram,
        It create a checkpoint (real copy) (but it is slowler).

    Returns
    -------
    filtered_diagram : BaseDiagram
        Return None if inplace is True, or a filtered clone of self otherwise.

    Examples
    --------
    &gt;&gt;&gt; from pprint import pprint
    &gt;&gt;&gt; import torch
    &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
    &gt;&gt;&gt; from laueimproc.io import get_sample
    &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
    &gt;&gt;&gt; diagram.find_spots()
    &gt;&gt;&gt; indices = torch.arange(0, len(diagram), 2)
    &gt;&gt;&gt; diagram.filter_spots(indices, &#34;keep even spots&#34;)
    &gt;&gt;&gt; cond = diagram.bboxes[:, 1] &lt; diagram.image.shape[1]//2
    &gt;&gt;&gt; diag_final = diagram.filter_spots(cond, &#34;keep spots on left&#34;, inplace=False)
    &gt;&gt;&gt; pprint(diagram.history)
    [&#39;240 spots from self.find_spots()&#39;, &#39;240 to 120 spots: keep even spots&#39;]
    &gt;&gt;&gt; pprint(diag_final.history)
    [&#39;240 spots from self.find_spots()&#39;,
     &#39;240 to 120 spots: keep even spots&#39;,
     &#39;120 to 63 spots: keep spots on left&#39;]
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    # verifications and cast
    assert hasattr(criteria, &#34;__iter__&#34;), criteria.__class__.__name__
    assert isinstance(msg, str), msg.__class__.__name__
    assert isinstance(inplace, bool), inplace.__class__.__name__
    criteria = torch.squeeze(torch.asarray(criteria))
    assert criteria.ndim &lt;= 1, f&#34;only a 1d vector is accepted, shape is {criteria.shape}&#34;
    criteria = criteria.reshape(-1)  # for empty tensor
    if criteria.dtype is torch.bool:  # case mask -&gt; convert into index list
        assert criteria.shape[0] == len(self), (
            &#34;the mask has to have the same length as the number of spots, &#34;
            f&#34;there are {len(self)} spots and mask is of len {criteria.shape[0]}&#34;
        )
        criteria = torch.arange(len(self), dtype=torch.int64, device=criteria.device)[criteria]
    elif criteria.dtype != torch.int64:
        criteria = criteria.to(torch.int64)

    # manage inplace
    nb_spots = len(self)
    if not inplace:
        self = self.clone()  # pylint: disable=W0642

    # update history, it has to be done before changing state to be catched by signature
    self._history.append(f&#34;{nb_spots} to {len(criteria)} spots: {msg}&#34;)

    # apply filter
    with self._rois_lock:
        self._rois = filter_by_indices(criteria, *self._rois)

    return None if inplace else self</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.base_diagram.BaseDiagram.find_spots"><code class="name flex">
<span>def <span class="ident">find_spots</span></span>(<span>self, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Search all the spots in this diagram, store the result into the <code>spots</code> attribute.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Transmitted to <code><a title="laueimproc.improc.peaks_search.peaks_search" href="../improc/peaks_search.html#laueimproc.improc.peaks_search.peaks_search">peaks_search()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_spots(self, **kwargs) -&gt; None:
    &#34;&#34;&#34;Search all the spots in this diagram, store the result into the `spots` attribute.

    Parameters
    ----------
    kwargs : dict
        Transmitted to ``laueimproc.improc.peaks_search.peaks_search``.
    &#34;&#34;&#34;
    datarois, bboxes = peaks_search(self.image, **kwargs)
    with self._rois_lock:
        self._rois = (datarois, bboxes)
    kwargs_str = &#34;, &#34;.join(f&#34;{k}={repr(v)}&#34; for k, v in kwargs.items())
    self._history = [f&#34;{len(self)} spots from self.find_spots({kwargs_str})&#34;]</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.base_diagram.BaseDiagram.get_property"><code class="name flex">
<span>def <span class="ident">get_property</span></span>(<span>self, name: str) ‑> object</span>
</code></dt>
<dd>
<div class="desc"><p>Return the property associated to te given id.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the property to get.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>property</code></strong> :&ensp;<code>object</code></dt>
<dd>The property value set with <code>add_property</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>Is the property has never been defined or if the state changed.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
&gt;&gt;&gt; from laueimproc.io import get_sample
&gt;&gt;&gt; diagram = BaseDiagram(get_sample())
&gt;&gt;&gt; diagram.add_property(&quot;prop1&quot;, value=&quot;any python object 1&quot;, erasable=False)
&gt;&gt;&gt; diagram.add_property(&quot;prop2&quot;, value=&quot;any python object 2&quot;)
&gt;&gt;&gt; diagram.get_property(&quot;prop1&quot;)
'any python object 1'
&gt;&gt;&gt; diagram.get_property(&quot;prop2&quot;)
'any python object 2'
&gt;&gt;&gt; diagram.find_spots()  # change state
&gt;&gt;&gt; diagram.get_property(&quot;prop1&quot;)
'any python object 1'
&gt;&gt;&gt; try:
...     diagram.get_property(&quot;prop2&quot;)
... except KeyError as err:
...     print(err)
...
&quot;the property 'prop2' is no longer valid because the state of the diagram has changed&quot;
&gt;&gt;&gt; try:
...     diagram.get_property(&quot;prop3&quot;)
... except KeyError as err:
...     print(err)
...
&quot;the property 'prop3' does no exist&quot;
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_property(self, name: str) -&gt; object:
    &#34;&#34;&#34;Return the property associated to te given id.

    Parameters
    ----------
    name : str
        The name of the property to get.

    Returns
    -------
    property : object
        The property value set with ``add_property``.

    Raises
    ------
    KeyError
        Is the property has never been defined or if the state changed.

    Examples
    --------
    &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
    &gt;&gt;&gt; from laueimproc.io import get_sample
    &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
    &gt;&gt;&gt; diagram.add_property(&#34;prop1&#34;, value=&#34;any python object 1&#34;, erasable=False)
    &gt;&gt;&gt; diagram.add_property(&#34;prop2&#34;, value=&#34;any python object 2&#34;)
    &gt;&gt;&gt; diagram.get_property(&#34;prop1&#34;)
    &#39;any python object 1&#39;
    &gt;&gt;&gt; diagram.get_property(&#34;prop2&#34;)
    &#39;any python object 2&#39;
    &gt;&gt;&gt; diagram.find_spots()  # change state
    &gt;&gt;&gt; diagram.get_property(&#34;prop1&#34;)
    &#39;any python object 1&#39;
    &gt;&gt;&gt; try:
    ...     diagram.get_property(&#34;prop2&#34;)
    ... except KeyError as err:
    ...     print(err)
    ...
    &#34;the property &#39;prop2&#39; is no longer valid because the state of the diagram has changed&#34;
    &gt;&gt;&gt; try:
    ...     diagram.get_property(&#34;prop3&#34;)
    ... except KeyError as err:
    ...     print(err)
    ...
    &#34;the property &#39;prop3&#39; does no exist&#34;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(name, str), name.__class__.__name__
    with self._cache[0]:
        try:
            state, value = self._properties[name]
        except KeyError as err:
            raise KeyError(f&#34;the property {repr(name)} does no exist&#34;) from err
    if state is not None and state != self.state:
        # with self._lock:
        #     self._properties[name] = (state, None)
        raise KeyError(
            f&#34;the property {repr(name)} is no longer valid &#34;
            &#34;because the state of the diagram has changed&#34;
        )
    return value</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.base_diagram.BaseDiagram.is_init"><code class="name flex">
<span>def <span class="ident">is_init</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if the diagram has been initialized.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
&gt;&gt;&gt; from laueimproc.io import get_sample
&gt;&gt;&gt; diagram = BaseDiagram(get_sample())
&gt;&gt;&gt; diagram.is_init()
False
&gt;&gt;&gt; diagram.find_spots()
&gt;&gt;&gt; diagram.is_init()
True
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_init(self) -&gt; bool:
    &#34;&#34;&#34;Return True if the diagram has been initialized.

    Examples
    --------
    &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
    &gt;&gt;&gt; from laueimproc.io import get_sample
    &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
    &gt;&gt;&gt; diagram.is_init()
    False
    &gt;&gt;&gt; diagram.find_spots()
    &gt;&gt;&gt; diagram.is_init()
    True
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    return self._rois is not None</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.base_diagram.BaseDiagram.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, disp=None, vmin: Optional[numbers.Real] = None, vmax: Optional[numbers.Real] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare for display the diagram and the spots.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>disp</code></strong> :&ensp;<code>matplotlib.figure.Figure</code> or <code>matplotlib.axes.Axes</code></dt>
<dd>The matplotlib figure to complete.</dd>
<dt><strong><code>vmin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The minimum intensity ploted.</dd>
<dt><strong><code>vmax</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The maximum intensity ploted.</dd>
<dt><strong><code>show_axis</code></strong> :&ensp;<code>boolean</code>, default=<code>True</code></dt>
<dd>Display the label and the axis if True.</dd>
<dt><strong><code>show_bboxes</code></strong> :&ensp;<code>boolean</code>, default=<code>True</code></dt>
<dd>Draw all the bounding boxes if True.</dd>
<dt><strong><code>show_image</code></strong> :&ensp;<code>boolean</code>, default=<code>True</code></dt>
<dd>Display the image if True, dont call imshow otherwise.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>matplotlib.axes.Axes</code></dt>
<dd>Filled graphical widget.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>It doesn't create the figure and call show.
Use <code>self.show()</code> to Display the diagram from scratch.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(
    self,
    disp=None,
    vmin: typing.Optional[numbers.Real] = None,
    vmax: typing.Optional[numbers.Real] = None,
    **kwargs,
):
    &#34;&#34;&#34;Prepare for display the diagram and the spots.

    Parameters
    ----------
    disp : matplotlib.figure.Figure or matplotlib.axes.Axes
        The matplotlib figure to complete.
    vmin : float, optional
        The minimum intensity ploted.
    vmax : float, optional
        The maximum intensity ploted.
    show_axis: boolean, default=True
        Display the label and the axis if True.
    show_bboxes: boolean, default=True
        Draw all the bounding boxes if True.
    show_image: boolean, default=True
        Display the image if True, dont call imshow otherwise.

    Returns
    -------
    matplotlib.axes.Axes
        Filled graphical widget.

    Notes
    -----
    It doesn&#39;t create the figure and call show.
    Use `self.show()` to Display the diagram from scratch.
    &#34;&#34;&#34;
    from matplotlib.axes import Axes
    from matplotlib.colors import Normalize
    from matplotlib.figure import Figure

    assert disp is None or isinstance(disp, (Figure, Axes))
    image = self.image
    if vmin is None:
        vmin = torch.mean(image).item()
    assert vmin is None or isinstance(vmin, numbers.Real), vmin.__class__.__name__
    if vmax is None:
        vmax = vmin + 5.0*torch.std(image).item()
    assert isinstance(vmax, numbers.Real), vmax.__class__.__name__
    assert isinstance(kwargs.get(&#34;show_axis&#34;, True), bool), kwargs[&#34;show_axis&#34;]
    assert isinstance(kwargs.get(&#34;show_bboxes&#34;, True), bool), kwargs[&#34;show_bboxes&#34;]
    assert isinstance(kwargs.get(&#34;show_image&#34;, True), bool), kwargs[&#34;show_image&#34;]

    # fill figure metadata
    axes = disp  # is gonna changed
    disp = disp or Figure(layout=&#34;tight&#34;)
    if isinstance(disp, Figure):
        if isinstance(self._file_or_data, pathlib.Path):
            disp.suptitle(f&#34;Diagram {self._file_or_data.name}&#34;)
        else:
            disp.suptitle(f&#34;Diagram from Tensor of id {id(self._file_or_data)}&#34;)
        axes = disp.add_subplot()

    # fill axes
    if kwargs.get(&#34;show_axis&#34;, True):
        axes.set_xlabel(&#34;x (first dim in &#39;xy&#39; conv)&#34;)
        axes.xaxis.set_label_position(&#34;bottom&#34;)
        axes.xaxis.set_ticks_position(&#34;bottom&#34;)
        axes.set_ylabel(&#34;y (second dim in &#39;xy&#39; conv)&#34;)
        axes.yaxis.set_label_position(&#34;right&#34;)
        axes.yaxis.set_ticks_position(&#34;right&#34;)
        axes.secondary_xaxis(
            &#34;top&#34;, functions=(lambda x: x-.5, lambda j: j+.5)
        ).set_xlabel(&#34;j (second dim in &#39;ij&#39; conv)&#34;)
        axes.secondary_yaxis(
            &#34;left&#34;, functions=(lambda y: y-.5, lambda i: i+.5)
        ).set_ylabel(&#34;i (first dim in &#39;ij&#39; conv)&#34;)
    if kwargs.get(&#34;show_image&#34;, True):

        axes.imshow(
            image.numpy(force=True),
            aspect=&#34;equal&#34;,
            extent=(.5, self.image.shape[1]+.5, self.image.shape[0]+.5, .5),
            interpolation=None,  # antialiasing is True
            norm=Normalize(vmin, vmax),
            cmap=&#34;plasma&#34;,  # or gray
        )
    if kwargs.get(&#34;show_boxes&#34;, True) and len(self):
        bboxes = self.bboxes.numpy(force=True).astype(np.float32)
        bboxes[:, :2] += 0.5  # ok inplace because copy has been made at previous line
        axes.plot(
            np.vstack((
                bboxes[:, 1],
                bboxes[:, 1],
                bboxes[:, 1]+bboxes[:, 3],
                bboxes[:, 1]+bboxes[:, 3],
                bboxes[:, 1],
            )),
            np.vstack((
                bboxes[:, 0],
                bboxes[:, 0]+bboxes[:, 2],
                bboxes[:, 0]+bboxes[:, 2],
                bboxes[:, 0],
                bboxes[:, 0],
            )),
            color=&#34;green&#34;,
            scalex=False,
            scaley=False,
        )
    return axes</code></pre>
</details>
</dd>
<dt id="laueimproc.classes.base_diagram.BaseDiagram.set_spots"><code class="name flex">
<span>def <span class="ident">set_spots</span></span>(<span>self, *new_spots: tuple) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the new spots as the current spots, reset the history and the cache.</p>
<h2 id="paremeters">Paremeters</h2>
<p>new_spots : tuple
Can be an over diagram of type Diagram.
Can be an arraylike of bounding boxes n * (anchor_i, anchor_j, height, width).
Can be an anchor and a picture n * (anchor_i, anchor_j, roi).
It can also be a combination of the above elements to unite the spots.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import torch
&gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
&gt;&gt;&gt; from laueimproc.io import get_sample
&gt;&gt;&gt;
&gt;&gt;&gt; # from diagram
&gt;&gt;&gt; diagram_ref = BaseDiagram(get_sample())
&gt;&gt;&gt; diagram_ref.find_spots()
&gt;&gt;&gt; diagram_ref.filter_spots(range(10))
&gt;&gt;&gt;
&gt;&gt;&gt; # from bboxes
&gt;&gt;&gt; bboxes = [[300, 500, 10, 15], [600, 700, 20, 15]]
&gt;&gt;&gt;
&gt;&gt;&gt; # from anchor and roi
&gt;&gt;&gt; spots = [[400, 600, torch.zeros((10, 15))], [700, 800, torch.zeros((20, 15))]]
&gt;&gt;&gt;
&gt;&gt;&gt; # union of the spots
&gt;&gt;&gt; diagram = BaseDiagram(get_sample())
&gt;&gt;&gt; diagram.set_spots(diagram_ref, bboxes, spots)
&gt;&gt;&gt; len(diagram)
14
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_spots(self, *new_spots: tuple) -&gt; None:
    &#34;&#34;&#34;Set the new spots as the current spots, reset the history and the cache.

    Paremeters
    ----------
    new_spots : tuple
        Can be an over diagram of type Diagram.
        Can be an arraylike of bounding boxes n * (anchor_i, anchor_j, height, width).
        Can be an anchor and a picture n * (anchor_i, anchor_j, roi).
        It can also be a combination of the above elements to unite the spots.

    Examples
    --------
    &gt;&gt;&gt; import torch
    &gt;&gt;&gt; from laueimproc.classes.base_diagram import BaseDiagram
    &gt;&gt;&gt; from laueimproc.io import get_sample
    &gt;&gt;&gt;
    &gt;&gt;&gt; # from diagram
    &gt;&gt;&gt; diagram_ref = BaseDiagram(get_sample())
    &gt;&gt;&gt; diagram_ref.find_spots()
    &gt;&gt;&gt; diagram_ref.filter_spots(range(10))
    &gt;&gt;&gt;
    &gt;&gt;&gt; # from bboxes
    &gt;&gt;&gt; bboxes = [[300, 500, 10, 15], [600, 700, 20, 15]]
    &gt;&gt;&gt;
    &gt;&gt;&gt; # from anchor and roi
    &gt;&gt;&gt; spots = [[400, 600, torch.zeros((10, 15))], [700, 800, torch.zeros((20, 15))]]
    &gt;&gt;&gt;
    &gt;&gt;&gt; # union of the spots
    &gt;&gt;&gt; diagram = BaseDiagram(get_sample())
    &gt;&gt;&gt; diagram.set_spots(diagram_ref, bboxes, spots)
    &gt;&gt;&gt; len(diagram)
    14
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    datarois_l, bboxes_l = [], []

    def unfold(iterable):
        if (
            isinstance(iterable, (set, frozenset))
            or (
                isinstance(iterable, (tuple, list))
                and not (
                    (  # bboxes
                        len(iterable) == 4
                        and all(isinstance(e, numbers.Integral) for e in iterable)
                    )
                    or (  # anchor, roi
                        len(iterable) == 3
                        and isinstance(iterable[0], numbers.Integral)
                        and isinstance(iterable[1], numbers.Integral)
                        and isinstance(iterable[2], (np.ndarray, torch.Tensor))
                    )
                )
            )
        ):
            yield from (item_ for item in iterable for item_ in unfold(item))
        else:
            yield iterable

    # extract datarois and anchors
    for item in unfold(new_spots):
        if (
            isinstance(item, BaseDiagram)  # case diagram
            and (datarois_bboxes := item._rois) is not None  # pylint: disable=W0212
        ):
            datarois_l.append(datarois_bboxes[0])
            bboxes_l.append(datarois_bboxes[1])
            continue
        item = torch.from_numpy(item) if isinstance(item, np.ndarray) else item
        if isinstance(item, (tuple, list)) and len(item) == 4:  # case bbox
            item = torch.asarray([item], dtype=torch.int16)
        if (
            isinstance(item, torch.Tensor)
            and item.ndim == 2
            and item.shape[1] == 4
            and not (item.dtype.is_complex or item.dtype.is_floating_point)
        ):  # case bboxes
            item = item.to(torch.int16)
            datarois_l.append(imgbboxes2raw(self.image, item))
            bboxes_l.append(item)
            continue
        if isinstance(item, (tuple, list)):  # case anchor and roi
            datarois = item[2]
            datarois = to_floattensor(datarois)
            if isinstance(datarois, torch.Tensor):
                datarois = datarois.numpy(force=True)
            datarois = datarois.astype(np.float32, copy=False)
            assert datarois.ndim == 2, datarois.shape
            bboxes_l.append(torch.asarray([[*item[:2], *datarois.shape]], dtype=torch.int16))
            datarois_l.append(bytearray(datarois.ravel().tobytes()))
            continue

        raise ValueError(f&#34;impossible to set new spots from {item}&#34;)

    # replace old spots by the new one
    datarois = bytearray(b&#34;&#34;).join(datarois_l)
    if bboxes_l:
        device = {bboxes.device for bboxes in bboxes_l}
        device = device.pop() if len(device) == 1 else &#34;cpu&#34;
        bboxes = torch.cat([bboxes.to(device) for bboxes in bboxes_l])
    else:
        bboxes = torch.empty((0, 4), dtype=torch.int16)
    with self._rois_lock:
        self._rois = (datarois, bboxes)
    self._history = [f&#34;{len(self)} spots from set_spots(...)&#34;]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="laueimproc.classes" href="index.html">laueimproc.classes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="laueimproc.classes.base_diagram.check_init" href="#laueimproc.classes.base_diagram.check_init">check_init</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="laueimproc.classes.base_diagram.BaseDiagram" href="#laueimproc.classes.base_diagram.BaseDiagram">BaseDiagram</a></code></h4>
<ul class="two-column">
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.add_property" href="#laueimproc.classes.base_diagram.BaseDiagram.add_property">add_property</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.areas" href="#laueimproc.classes.base_diagram.BaseDiagram.areas">areas</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.bboxes" href="#laueimproc.classes.base_diagram.BaseDiagram.bboxes">bboxes</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.clone" href="#laueimproc.classes.base_diagram.BaseDiagram.clone">clone</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.compress" href="#laueimproc.classes.base_diagram.BaseDiagram.compress">compress</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.file" href="#laueimproc.classes.base_diagram.BaseDiagram.file">file</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.filter_spots" href="#laueimproc.classes.base_diagram.BaseDiagram.filter_spots">filter_spots</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.find_spots" href="#laueimproc.classes.base_diagram.BaseDiagram.find_spots">find_spots</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.get_property" href="#laueimproc.classes.base_diagram.BaseDiagram.get_property">get_property</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.history" href="#laueimproc.classes.base_diagram.BaseDiagram.history">history</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.image" href="#laueimproc.classes.base_diagram.BaseDiagram.image">image</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.is_init" href="#laueimproc.classes.base_diagram.BaseDiagram.is_init">is_init</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.plot" href="#laueimproc.classes.base_diagram.BaseDiagram.plot">plot</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.rawrois" href="#laueimproc.classes.base_diagram.BaseDiagram.rawrois">rawrois</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.rois" href="#laueimproc.classes.base_diagram.BaseDiagram.rois">rois</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.set_spots" href="#laueimproc.classes.base_diagram.BaseDiagram.set_spots">set_spots</a></code></li>
<li><code><a title="laueimproc.classes.base_diagram.BaseDiagram.state" href="#laueimproc.classes.base_diagram.BaseDiagram.state">state</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>